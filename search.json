[{"title":"hexo使用笔记","path":"/2024/01/23/hexo使用记录/","content":"1、文章内加图片（stellar主题）_config.yml里配置post_asset_folder。 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 在_posts文件夹下新建一个与markdown文件同名的文件夹，放置图片资源。 在markdown文件内，使用’&#x2F;test01.jpg’的路径引入。 2、配色方案https://www.colorhunt.co/ 提供赏心悦目的色彩搭配方案，可以直接复制十六进制。 3、文章的toc（stellar主题）默认从H2开始，分级要严格按照2→3→4→5这样降级，否则会显示错误。 4、配置文章的默认信息如果是手动把已经写好的markdown文件拖入post文件夹上传，需要在markdown文件开始的地方配置默认YAML信息，快捷键为三个➖加换行。本博客使用的配置信息格式为： 12345title: hexo使用笔记categories: blog搭建tags: [blog,踩坑记录]cover: /picture/blog.jpgdate: 2024-01-23 14:52","tags":["blog","踩坑记录"],"categories":["blog搭建"]},{"title":"Javascript 正则表达式","path":"/2024/01/22/正则表达式/","content":"概念定义正则表达式（Regular Expression）是一种字符串匹配的模式（规则）。 使用场景 例如验证表单：手机号表单要求用户只能输入11位的数字 (匹配) 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 正则基本使用 定义规则1const reg = /表达式/ 其中/ /是正则表达式字面量 正则表达式也是对象 使用正则 test()方法 用来查看正则表达式与指定的字符串是否匹配 如果正则表达式与指定的字符串匹配 ，返回true，否则false 123456789101112&lt;body&gt; &lt;script&gt; // 正则表达式的基本使用 const str = &#x27;web前端开发&#x27; // 1. 定义规则 const reg = /web/ // 2. 使用正则 test() console.log(reg.test(str)) // true 如果符合规则匹配上则返回true console.log(reg.test(&#x27;java开发&#x27;)) // false 如果不符合规则匹配上则返回 false &lt;/script&gt;&lt;/body&gt; 元字符普通字符: 大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。 普通字符只能够匹配字符串中与它们相同的字符。 &#x20; 比如，规定用户只能输入英文26个英文字母，普通字符的话 &#x2F;[abcdefghijklmnopqrstuvwxyz]&#x2F; 元字符(特殊字符） 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，换成元字符写法： &#x2F;[a-z]&#x2F; 1. 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 如果 ^ 和 $ 在一起，表示必须是精确匹配 123456789101112131415161718192021222324252627&lt;body&gt; &lt;script&gt; // 元字符之边界符 // 1. 匹配开头的位置 ^ const reg = /^web/ console.log(reg.test(&#x27;web前端&#x27;)) // true console.log(reg.test(&#x27;前端web&#x27;)) // false console.log(reg.test(&#x27;前端web学习&#x27;)) // false console.log(reg.test(&#x27;we&#x27;)) // false // 2. 匹配结束的位置 $ const reg1 = /web$/ console.log(reg1.test(&#x27;web前端&#x27;)) // false console.log(reg1.test(&#x27;前端web&#x27;)) // true console.log(reg1.test(&#x27;前端web学习&#x27;)) // false console.log(reg1.test(&#x27;we&#x27;)) // false // 3. 精确匹配 ^ $ const reg2 = /^web$/ console.log(reg2.test(&#x27;web前端&#x27;)) // false console.log(reg2.test(&#x27;前端web&#x27;)) // false console.log(reg2.test(&#x27;前端web学习&#x27;)) // false console.log(reg2.test(&#x27;we&#x27;)) // false console.log(reg2.test(&#x27;web&#x27;)) // true console.log(reg2.test(&#x27;webweb&#x27;)) // flase &lt;/script&gt;&lt;/body&gt; 2. 量词量词用来设定某个模式重复次数 📌注意： 逗号左右两侧千万不要出现空格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;script&gt; // 元字符之量词 // 1. * 重复次数 &gt;= 0 次 const reg1 = /^w*$/ console.log(reg1.test(&#x27;&#x27;)) // true console.log(reg1.test(&#x27;w&#x27;)) // true console.log(reg1.test(&#x27;ww&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 2. + 重复次数 &gt;= 1 次 const reg2 = /^w+$/ console.log(reg2.test(&#x27;&#x27;)) // false console.log(reg2.test(&#x27;w&#x27;)) // true console.log(reg2.test(&#x27;ww&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 3. ? 重复次数 0 || 1 const reg3 = /^w?$/ console.log(reg3.test(&#x27;&#x27;)) // true console.log(reg3.test(&#x27;w&#x27;)) // true console.log(reg3.test(&#x27;ww&#x27;)) // false console.log(&#x27;-----------------------&#x27;) // 4. &#123;n&#125; 重复 n 次 const reg4 = /^w&#123;3&#125;$/ console.log(reg4.test(&#x27;&#x27;)) // false console.log(reg4.test(&#x27;w&#x27;)) // flase console.log(reg4.test(&#x27;ww&#x27;)) // false console.log(reg4.test(&#x27;www&#x27;)) // true console.log(reg4.test(&#x27;wwww&#x27;)) // false console.log(&#x27;-----------------------&#x27;) // 5. &#123;n,&#125; 重复次数 &gt;= n const reg5 = /^w&#123;2,&#125;$/ console.log(reg5.test(&#x27;&#x27;)) // false console.log(reg5.test(&#x27;w&#x27;)) // false console.log(reg5.test(&#x27;ww&#x27;)) // true console.log(reg5.test(&#x27;www&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 6. &#123;n,m&#125; n =&lt; 重复次数 &lt;= m const reg6 = /^w&#123;2,4&#125;$/ console.log(reg6.test(&#x27;w&#x27;)) // false console.log(reg6.test(&#x27;ww&#x27;)) // true console.log(reg6.test(&#x27;www&#x27;)) // true console.log(reg6.test(&#x27;wwww&#x27;)) // true console.log(reg6.test(&#x27;wwwww&#x27;)) // false // 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败 &lt;/script&gt; 3. 范围表示字符的范围，定义的规则限定在某个范围，比如只能是英文字母，或者数字等等，用表示范围 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;script&gt; // 元字符之范围 [] // 1. [abc] 匹配包含的单个字符， 多选1 const reg1 = /^[abc]$/ console.log(reg1.test(&#x27;a&#x27;)) // true console.log(reg1.test(&#x27;b&#x27;)) // true console.log(reg1.test(&#x27;c&#x27;)) // true console.log(reg1.test(&#x27;d&#x27;)) // false console.log(reg1.test(&#x27;ab&#x27;)) // false // 2. [a-z] 连字符 单个 const reg2 = /^[a-z]$/ console.log(reg2.test(&#x27;a&#x27;)) // true console.log(reg2.test(&#x27;p&#x27;)) // true console.log(reg2.test(&#x27;0&#x27;)) // false console.log(reg2.test(&#x27;A&#x27;)) // false // 想要包含小写字母，大写字母 ，数字 const reg3 = /^[a-zA-Z0-9]$/ console.log(reg3.test(&#x27;B&#x27;)) // true console.log(reg3.test(&#x27;b&#x27;)) // true console.log(reg3.test(9)) // true console.log(reg3.test(&#x27;,&#x27;)) // flase // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位 const reg4 = /^[a-zA-Z0-9_]&#123;6,16&#125;$/ console.log(reg4.test(&#x27;abcd1&#x27;)) // false console.log(reg4.test(&#x27;abcd12&#x27;)) // true console.log(reg4.test(&#x27;ABcd12&#x27;)) // true console.log(reg4.test(&#x27;ABcd12_&#x27;)) // true // 3. [^a-z] 取反符 const reg5 = /^[^a-z]$/ console.log(reg5.test(&#x27;a&#x27;)) // false console.log(reg5.test(&#x27;A&#x27;)) // true console.log(reg5.test(8)) // true &lt;/script&gt;&lt;/body&gt; 4. 字符类某些常见模式的简写方式，区分字母和数字 替换和修饰符replace 替换方法，可以完成字符的替换 123456789&lt;body&gt; &lt;script&gt; // 替换和修饰符 const str = &#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个 &lt;/script&gt;&lt;/body&gt; 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 i 是单词 ignore 的缩写，正则匹配时字母不区分大小写 g 是单词 global 的缩写，匹配所有满足正则表达式的结果 12345678910111213&lt;body&gt; &lt;script&gt; // 替换和修饰符 const str = &#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个 // 2. 修饰符 g 全部替换 const strEnd = str.replace(/前端/g, &#x27;web&#x27;) console.log(strEnd) &lt;/script&gt;&lt;/body&gt; change 事件给input注册 change 事件，值被修改并且失去焦点后触发 判断是否有类 元素.classList.contains() 看看有没有包含某个类，如果有则返回true，么有则返回false","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 本地存储","path":"/2024/01/22/本地存储/","content":"本地存储：将数据存储在本地浏览器中 常见的使用场景： https://todomvc.com/examples/vanilla-es6/ 页面刷新数据不丢失 好处： 1、页面刷新或者关闭不丢失数据，实现数据持久化 2、容量较大，sessionStorage和 localStorage 约 5M 左右 localStorage（重点）作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失 特性：以键值对的形式存储，并且存储的是字符串， 省略了window 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;本地存储-localstorage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 本地存储 - localstorage 存储的是字符串 // 1. 存储 localStorage.setItem(&#x27;age&#x27;, 18) // 2. 获取 console.log(typeof localStorage.getItem(&#x27;age&#x27;)) // 3. 删除 localStorage.removeItem(&#x27;age&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; sessionStorage（了解）特性： 用法跟localStorage基本相同 区别是：当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除 存储：sessionStorage.setItem(key,value) 获取：sessionStorage.getItem(key) 删除：sessionStorage.removeItem(key) localStorage 存储复杂数据类型问题：本地只能存储字符串,无法存储复杂数据类型. 解决：需要将复杂数据类型转换成 JSON字符串,在存储到本地 语法：JSON.stringify(复杂数据类型) JSON字符串： 首先是1个字符串 属性名使用双引号引起来，不能单引号 属性值如果是字符串型也必须双引号 12345678910111213141516&lt;body&gt; &lt;script&gt; // 本地存储复杂数据类型 const goods = &#123; name: &#x27;小米&#x27;, price: 1999 &#125; // localStorage.setItem(&#x27;goods&#x27;, goods) // console.log(localStorage.getItem(&#x27;goods&#x27;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(&#x27;goods&#x27;)) &lt;/script&gt;&lt;/body&gt; 问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用 解决： 把取出来的字符串转换为对象 语法：JSON.parse(JSON字符串) 123456789&lt;body&gt; &lt;script&gt; // 本地存储复杂数据类型 const goods = &#123; name: &#x27;小米&#x27;, price: 1999 &#125; // localStorage.setItem(&#x27;goods&#x27;, goods) // console.log(localStorage.getItem(&#x27;goods&#x27;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(&#x27;goods&#x27;)) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem(&#x27;goods&#x27;))) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"hexo+stellar+github actions实现自动部署","path":"/2024/01/16/hexo+stellar+github actions实现自动部署/","content":"博客的持续部署抛开定义，直观上，持续部署，顾名思义，就是持续不断地去部署，部署自动紧跟代码改变：你的提交了源码修改，部署上就自动更新了。对于我们的博客系统，也就是新建&#x2F;修改&#x2F;删除了文章，博客站点就自动更新、修改对应内容。从效果上来说，就是我们不用再去手动 hexo g -d 生成、部署了。 用持续部署，首先提交源码，然后在云端就自动生成(编译)、部署，这个生成、部署的工作是不需要在本地完成的，由github提供的 CI&#x2F;CD 服务的服务器自动来完成。GitHub 免费提供的这项服务叫做 GitHub Actions。 1. 前提工作本教程在以下环境搭建。 12345hexo: 6.3.0hexo-cli: 4.3.0os: win32 10.0.19042node: 16.17.1hexo-deployer-git: 4.0.0 1.1创建所需仓库 创建 blog 仓库用来存放 Hexo 项目 创建 your.github.io 仓库用来存放静态博客页面 1.2生成部署密钥12$ ssh-keygen -f github-deploy-key 一路按回车直到生成成功 当前目录下会有 github-deploy-key 和 github-deploy-key.pub 两个文件。 1.3 配置部署密钥复制 github-deploy-key 文件内容，在 blog 仓库 Settings -&gt; Secrets and variables -&gt; Actions 页面上添加。 在 Name 输入框填写 HEXO_DEPLOY_PRI。 在 Value 输入框填写 github-deploy-key 文件内容。 复制 github-deploy-key.pub 文件内容，在 your.github.io 仓库 Settings -&gt; Deploy keys -&gt; Add deploy key 页面上添加。 在 Title 输入框填写 HEXO_DEPLOY_PUB。 在 Key 输入框填写 github-deploy-key.pub 文件内容。 勾选 Allow write access 选项。 2. 配置workflow在 blog 仓库根目录下创建 .github/workflows/deploy.yml 文件。 在 deploy.yml 文件中粘贴以下内容。 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667name: CIon: push: branches: - mainenv: GIT_USER: YYYutang GIT_EMAIL: email@email.com THEME_REPO: YYYutang/hexo-theme-stellar THEME_BRANCH: main DEPLOY_REPO: YYYutang/YYYutang.github.io DEPLOY_BRANCH: mainjobs: build: name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125; runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v2 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.THEME_REPO &#125;&#125; ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125; path: themes/stellar - name: Checkout deploy repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125; ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125; path: .deploy_git - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node_version &#125;&#125; - name: Configuration environment env: HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125; run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL cp _config.theme.yml themes/stellar/_config.yml - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 模版参数说明 name 为此 Action 的名字 on 触发条件，当满足条件时会触发此任务，这里的 on.push.branches.$.master 是指当 master 分支收到 push 后执行任务。 env 为环境变量对象 env.GIT_USER 为 Hexo 编译后使用此 git 用户部署到仓库。 env.GIT_EMAIL 为 Hexo 编译后使用此 git 邮箱部署到仓库。 env.THEME_REPO 为您的 Hexo 所使用的主题的仓库，这里为 sanonz/hexo-theme-concise。 env.THEME_BRANCH 为您的 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA。 env.DEPLOY_REPO 为 Hexo 编译后要部署的仓库，例如：sanonz/sanonz.github.io。 env.DEPLOY_BRANCH 为 Hexo 编译后要部署到的分支，例如：master。 jobs 为此 Action 下的任务列表 jobs.{job}.name 任务名称 jobs.{job}.runs-on 任务所需容器，可选值：ubuntu-latest、windows-latest、macos-latest。 jobs.{job}.strategy 策略下可以写 array 格式，此 job 会遍历此数组执行。 jobs.{job}.steps 一个步骤数组，可以把所要干的事分步骤放到这里。 jobs.{job}.steps.$.name 步骤名，编译时会会以 LOG 形式输出。 jobs.{job}.steps.$.uses 所要调用的 Action，可以到 https://github.com/actions 查看更多。 jobs.{job}.steps.$.with 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。 这里踩的坑有： 1、path: themes&#x2F;stellar的主题地址忘记换成自己的，导致部署上去之后，所有的html文件均为空文件，并且页面加载不出来。 2、部署成功，但在workflow里deploy那一步有大量报错，说找不到avatar属性，一开始以为是部署流程只识别了_config.theme.yml,所以没有识别_config.yml里设置的avatar，遂修改_config.theme.yml，但没有起作用。 仔细检查发现主题是通过THEME_REPO设置的github连接引入的，而我github上fork的是一个比较早的版本的stellar，本地使用的_config.theme.yml是最新版本的stellar里提供的配置文件。将github上的主题仓库更新至最新版，问题解决。 3、报大量的语法错误 是指定的node_version过低的问题，最新版的stellar不适配12.x的版本，修改为15.x以上即可。 4、报错ERROR Deployer not found: git，需要安装 hexo-deployer-git。 1npm install hexo-deployer-git --save 3. 修改_config.yml里的deploy配置1234567# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: &#x27;git&#x27; repo: git@github.com:yyyutang/YYYutang.github.io.git branch: main message: $&#123;&#123; github.event.head_commit.message &#125;&#125; 4. 配置theme的_config文件复制一份 使用的theme根目录下的_config.yml，放到 blog 根目录下，名为 _config.theme.yml，如果您已经配置过此文件，只需要把您的复制过来就行。 这里注意需要把网站的基础信息，如头像Avatar、标题Title等设置好。 5.执行任务写一篇文章，push 到 blog 仓库的 main 分支，在此仓库 Actions 页面查看当前 task。 当任务完成后查看您的博客 https://your.github.io，如果不出意外的话已经可以看到新添加的文章了。","tags":["blog","踩坑记录"],"categories":["blog搭建"]},{"title":"Javascript Windows对象","path":"/2024/01/16/Window对象/","content":"JavaScript的组成 ECMAScript: 规定了js基础语法核心知识。 比如：变量、分支语句、循环语句、对象等等 Web APIs : DOM 文档对象模型， 定义了一套操作HTML文档的API BOM 浏览器对象模型，定义了一套操作浏览器窗口的API JS执行机制同步任务同步任务都在主线程上执行，形成一个执行栈。 异步任务JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型: 1、普通事件，如 click、resize 等 2、资源加载，如 load、error 等 3、定时器，包括 setInterval、setTimeout 等 异步任务相关添加到任务队列中（任务队列也称为消息队列）。 事件循环 先执行执行栈中的同步任务。 异步任务放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 BOM对象BOM (Browser Object Model ) 是浏览器对象模型 window对象是一个全局对象，也可以说是JavaScript中的顶级对象 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window 定时器-延迟函数JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout 语法： 1setTimeout(回调函数, 延迟时间) setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window 间歇函数 setInterval : 每隔一段时间就执行一次, 平时省略window 清除延时函数： 1clearTimeout(timerId) 注意点1. 延时函数需要等待,所以后面的代码先执行2. 返回值是一个正整数，表示定时器的编号 12345678910111213141516171819&lt;body&gt; &lt;script&gt; // 定时器之延迟函数 // 1. 开启延迟函数 let timerId = setTimeout(function () &#123; console.log(&#x27;我只执行一次&#x27;) &#125;, 3000) // 1.1 延迟函数返回的还是一个正整数数字，表示延迟函数的编号 console.log(timerId) // 1.2 延迟函数需要等待时间，所以下面的代码优先执行 // 2. 关闭延迟函数 clearTimeout(timerId) &lt;/script&gt;&lt;/body&gt; location对象location (地址) 它拆分并保存了 URL 地址的各个组成部分， 它是一个对象 属性&#x2F;方法 说明 href 属性，获取完整的 URL 地址，赋值时用于地址的跳转 search 属性，获取地址中携带的参数，符号 ？后面部分 hash 属性，获取地址中的哈希值，符号 # 后面部分 reload() 方法，用来刷新当前页面，传入参数 true 时表示强制刷新 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;search&quot;&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;a href=&quot;#/music&quot;&gt;音乐&lt;/a&gt; &lt;a href=&quot;#/download&quot;&gt;下载&lt;/a&gt; &lt;button class=&quot;reload&quot;&gt;刷新页面&lt;/button&gt; &lt;script&gt; // location 对象 // 1. href属性 （重点） 得到完整地址，赋值则是跳转到新地址 console.log(location.href) // location.href = &#x27;http://www.itcast.cn&#x27; // 2. search属性 得到 ? 后面的地址 console.log(location.search) // ?search=笔记本 // 3. hash属性 得到 # 后面的地址 console.log(location.hash) // 4. reload 方法 刷新页面 const btn = document.querySelector(&#x27;.reload&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // location.reload() // 页面刷新 location.reload(true) // 强制页面刷新 ctrl+f5 &#125;) &lt;/script&gt;&lt;/body&gt; navigator对象navigator是对象，该对象下记录了浏览器自身的相关信息 常用属性和方法： 通过 userAgent 检测浏览器的版本及平台 12345678910// 检测 userAgent（浏览器信息）(function () &#123; const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) &#123; location.href = &#x27;http://m.itcast.cn&#x27; &#125;&#125;)(); histroy对象history (历史)是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退等 使用场景 history对象一般在实际开发中比较少用，但是会在一些OA 办公系统中见到。 常见方法： 123456789101112131415161718192021&lt;body&gt; &lt;button class=&quot;back&quot;&gt;←后退&lt;/button&gt; &lt;button class=&quot;forward&quot;&gt;前进→&lt;/button&gt; &lt;script&gt; // histroy对象 // 1.前进 const forward = document.querySelector(&#x27;.forward&#x27;) forward.addEventListener(&#x27;click&#x27;, function () &#123; // history.forward() history.go(1) &#125;) // 2.后退 const back = document.querySelector(&#x27;.back&#x27;) back.addEventListener(&#x27;click&#x27;, function () &#123; // history.back() history.go(-1) &#125;) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript M端事件","path":"/2024/01/16/M端事件/","content":"移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。 touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 常见的触屏事件如下：","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM节点","path":"/2024/01/16/DOM节点/","content":"回顾之前 DOM 的操作都是针对元素节点的属性或文本的，除此之外也有专门针对元素节点本身的操作，如插入、复制、删除、替换等。 插入节点在已有的 DOM 节点中插入新的 DOM 节点时，需要关注两个关键因素：首先要得到新的 DOM 节点，其次在哪个位置插入这个节点。 如下代码演示： 123456789101112131415161718192021222324252627&lt;body&gt; &lt;h3&gt;插入节点&lt;/h3&gt; &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt; &lt;hr&gt; &lt;!-- 普通盒子 --&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!-- 点击按钮向 box 盒子插入节点 --&gt; &lt;button class=&quot;btn&quot;&gt;插入节点&lt;/button&gt; &lt;script&gt; // 点击按钮，在网页中插入节点 const btn = document.querySelector(&#x27;.btn&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // 1. 获得一个 DOM 元素节点 const p = document.createElement(&#x27;p&#x27;) p.innerText = &#x27;创建的新的p标签&#x27; p.className = &#x27;info&#x27; // 复制原有的 DOM 节点 const p2 = document.querySelector(&#x27;p&#x27;).cloneNode(true) p2.style.color = &#x27;red&#x27; // 2. 插入盒子 box 盒子 document.querySelector(&#x27;.box&#x27;).appendChild(p) document.querySelector(&#x27;.box&#x27;).appendChild(p2) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： createElement 动态创建任意 DOM 节点 cloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点 appendChild 在末尾（结束标签前）插入节点 再来看另一种情形的代码演示： 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;h3&gt;插入节点&lt;/h3&gt; &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt; &lt;hr&gt; &lt;button class=&quot;btn1&quot;&gt;在任意节点前插入&lt;/button&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 点击按钮，在已有 DOM 中插入新节点 const btn1 = document.querySelector(&#x27;.btn1&#x27;) btn1.addEventListener(&#x27;click&#x27;, function () &#123; // 第 2 个 li 元素 const relative = document.querySelector(&#x27;li:nth-child(2)&#x27;) // 1. 动态创建新的节点 const li1 = document.createElement(&#x27;li&#x27;) li1.style.color = &#x27;red&#x27; li1.innerText = &#x27;Web APIs&#x27; // 复制现有的节点 const li2 = document.querySelector(&#x27;li:first-child&#x27;).cloneNode(true) li2.style.color = &#x27;blue&#x27; // 2. 在 relative 节点前插入 document.querySelector(&#x27;ul&#x27;).insertBefore(li1, relative) document.querySelector(&#x27;ul&#x27;).insertBefore(li2, relative) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： createElement 动态创建任意 DOM 节点 cloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点 insertBefore 在父节点中任意子节点之前插入新节点 删除节点删除现有的 DOM 节点，也需要关注两个因素：首先由父节点删除子节点，其次是要删除哪个子节点。 12345678910111213141516171819202122&lt;body&gt; &lt;!-- 点击按钮删除节点 --&gt; &lt;button&gt;删除节点&lt;/button&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const btn = document.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // 获取 ul 父节点 let ul = document.querySelector(&#x27;ul&#x27;) // 待删除的子节点 let lis = document.querySelectorAll(&#x27;li&#x27;) // 删除节点 ul.removeChild(lis[0]) &#125;) &lt;/script&gt;&lt;/body&gt; 结论：removeChild 删除节点时一定是由父子关系。 查找节点DOM 树中的任意节点都不是孤立存在的，它们要么是父子关系，要么是兄弟关系，不仅如此，我们可以依据节点之间的关系查找节点。 父子关系12345678910111213141516171819202122&lt;body&gt; &lt;button class=&quot;btn1&quot;&gt;所有的子节点&lt;/button&gt; &lt;!-- 获取 ul 的子节点 --&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript 基础&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const btn1 = document.querySelector(&#x27;.btn1&#x27;) btn1.addEventListener(&#x27;click&#x27;, function () &#123; // 父节点 const ul = document.querySelector(&#x27;ul&#x27;) // 所有的子节点 console.log(ul.childNodes) // 只包含元素子节点 console.log(ul.children) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： childNodes 获取全部的子节点，回车换行会被认为是空白文本节点 children 只获取元素类型节点 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td width=&quot;60&quot;&gt;序号&lt;/td&gt; &lt;td&gt;课程名&lt;/td&gt; &lt;td&gt;难度&lt;/td&gt; &lt;td width=&quot;80&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;/td&gt; &lt;td&gt;初级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;/td&gt; &lt;td&gt;初级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;&lt;span&gt;Web APIs&lt;/span&gt;&lt;/td&gt; &lt;td&gt;中级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script&gt; // 获取所有 button 节点，并添加事件监听 const buttons = document.querySelectorAll(&#x27;table button&#x27;) for(let i = 0; i &lt; buttons.length; i++) &#123; buttons[i].addEventListener(&#x27;click&#x27;, function () &#123; // console.log(this.parentNode); // 父节点 td // console.log(this.parentNode.parentNode); // 爷爷节点 tr this.parentNode.parentNode.style.color = &#x27;red&#x27; &#125;) &#125; &lt;/script&gt;&lt;/body&gt; 结论：parentNode 获取父节点，以相对位置查找节点，实际应用中非常灵活。 兄弟关系12345678910111213141516171819202122&lt;body&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript 基础&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 获取所有 li 节点 const lis = document.querySelectorAll(&#x27;ul li&#x27;) // 对所有的 li 节点添加事件监听 for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].addEventListener(&#x27;click&#x27;, function () &#123; // 前一个节点 console.log(this.previousSibling) // 下一下节点 console.log(this.nextSibling) &#125;) &#125; &lt;/script&gt;&lt;/body&gt; 12345678910111213141516&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // const ul = document.querySelector(&#x27;ul&#x27;) // ul // console.log(ul.children) // 得到伪数组 选择的是 亲儿子 const li2 = document.querySelector(&#x27;ul li:nth-child(2)&#x27;) console.log(li2.previousElementSibling) // 上一个兄弟 console.log(li2.nextElementSibling) // 下一个兄弟 &lt;/script&gt;&lt;/body&gt; 结论： previousSibling 获取前一个节点，回车换行会被认为是空白文本节点 nextSibling 获取后一个节点，回车换行会被认为是空白文本节点 previousElementSibling 获取前一个节点，以相对位置查找节点，实际应用中非常灵活。 nextElementSibling 获取后一个节点，以相对位置查找节点，实际应用中非常灵活。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM事件基础","path":"/2024/01/16/DOM事件基础/","content":"事件监听结合 DOM 使用事件时，需要为 DOM 对象添加事件监听，等待事件发生（触发）时，便立即调用一个函数。 addEventListener 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为【事件类型】和【事件回调】。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;事件监听&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;事件监听&lt;/h3&gt; &lt;p id=&quot;text&quot;&gt;为 DOM 元素添加事件监听，等待事件发生，便立即执行一个函数。&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;点击改变文字颜色&lt;/button&gt; &lt;script&gt; // 1. 获取 button 对应的 DOM 对象 const btn = document.querySelector(&#x27;#btn&#x27;) // 2. 添加事件监听 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;等待事件被触发...&#x27;) // 改变 p 标签的文字颜色 let text = document.getElementById(&#x27;text&#x27;) text.style.color = &#x27;red&#x27; &#125;) // 3. 只要用户点击了按钮，事件便触发了！！！ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 完成事件监听分成3个步骤： 获取 DOM 元素 通过 addEventListener 方法为 DOM 节点添加事件监听 等待事件触发，如用户点击了某个按钮时便会触发 click 事件类型 事件触发后，相对应的回调函数会被执行 大白话描述：所谓的事件无非就是找个机会（事件触发）调用一个函数（回调函数）。&#x20; 事件类型将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等，我们逐一展开学习。 鼠标事件鼠标事件是指跟鼠标操作相关的事件，如单击、双击、移动等。 `mouseenter 监听鼠标是否移入 DOM 元素 123456789101112131415161718&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移入当前 DOM 元素 box.addEventListener(&#x27;mouseenter&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移入了...&#x27;; // 修改光标的风格 this.style.cursor = &#x27;move&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; 2.`mouseleave 监听鼠标是否移出 DOM 元素 12345678910111213141516&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移出当前 DOM 元素 box.addEventListener(&#x27;mouseleave&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移出了...&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; 键盘事件keydown 键盘按下触发keyup 键盘抬起触发 焦点事件focus 获得焦点 blur 失去焦点 文本框输入事件input 事件对象任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。 123456789101112131415161718&lt;body&gt; &lt;h3&gt;事件对象&lt;/h3&gt; &lt;p&gt;任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取 .box 元素 const box = document.querySelector(&#x27;.box&#x27;) // 添加事件监听 box.addEventListener(&#x27;click&#x27;, function (e) &#123; console.log(&#x27;任意事件类型被触发后，相关信息会以对象形式被记录下来...&#x27;); // 事件回调函数的第1个参数即所谓的事件对象 console.log(e) &#125;) &lt;/script&gt;&lt;/body&gt; 事件回调函数的【第1个参数】即所谓的事件对象，通常习惯性的将这个对数命名为 event、ev 、ev 。 接下来简单看一下事件对象中包含了哪些有用的信息： ev.type 当前事件的类型 ev.clientX/Y 光标相对浏览器窗口的位置 ev.offsetX/Y 光标相于当前 DOM 元素的位置 注：在事件回调函数内部通过 window.event 同样可以获取事件对象。 环境对象 能够分析判断函数运行在不同环境中 this 所指代的对象。 环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境。 123456789101112131415161718192021222324252627&lt;script&gt; // 声明函数 function sayHi() &#123; // this 是一个变量 console.log(this); &#125; // 声明一个对象 let user = &#123; name: &#x27;张三&#x27;, sayHi: sayHi // 此处把 sayHi 函数，赋值给 sayHi 属性 &#125; let person = &#123; name: &#x27;李四&#x27;, sayHi: sayHi &#125; // 直接调用 sayHi() // window window.sayHi() // window // 做为对象方法调用 user.sayHi()// user person.sayHi()// person&lt;/script&gt; 结论： this 本质上是一个变量，数据类型为对象 函数的调用方式不同 this 变量的值也不同 【谁调用 this 就是谁】是判断 this 值的粗略规则 函数直接调用时实际上 window.sayHi() 所以 this 的值为 window 回调函数如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数。 1234567891011121314151617&lt;script&gt; // 声明 foo 函数 function foo(arg) &#123; console.log(arg); &#125; // 普通的值做为参数 foo(10); foo(&#x27;hello world!&#x27;); foo([&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]); function bar() &#123; console.log(&#x27;函数也能当参数...&#x27;); &#125; // 函数也可以做为参数！！！！ foo(bar);&lt;/script&gt; 结论： 回调函数本质还是函数，只不过把它当成参数使用 使用匿名函数做为回调函数比较常见","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM事件进阶","path":"/2024/01/16/DOM事件进阶/","content":"事件流事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。 如上图所示，任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。 简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。 捕获和冒泡了解了什么是事件流之后，我们来看事件流是如何影响事件执行的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;); const inner = document.querySelector(&#x27;.inner&#x27;); const child = document.querySelector(&#x27;.child&#x27;); // html 元素添加事件 document.documentElement.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;html...&#x27;) &#125;) // body 元素添加事件 document.body.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;body...&#x27;) &#125;) // 外层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;) // 内层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;child...&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？ 结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。 再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。 如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。 如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。 12345678910111213141516171819202122&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;, true) // true 表示在捕获阶段执行事件 // 中间的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;, true) &lt;/script&gt;&lt;/body&gt; 结论： addEventListener 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发 addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false 事件流只会在父子元素具有相同事件类型时才会产生影响 绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获） 如果使用onclick方法，则只有冒泡阶段，没有捕获。 阻止冒泡1、阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;h3&gt;阻止冒泡&lt;/h3&gt; &lt;p&gt;阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) const child = document.querySelector(&#x27;.child&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子 inner.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;inner...&#x27;) // 阻止事件冒泡 ev.stopPropagation() &#125;) // 内层的盒子 child.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;child...&#x27;) // 借助事件对象，阻止事件向上冒泡 ev.stopPropagation() &#125;) &lt;/script&gt;&lt;/body&gt; 结论：事件对象中的 ev.stopPropagation 方法，专门用来阻止事件冒泡。 鼠标经过事件：mouseover 和 mouseout 会有冒泡效果mouseenter 和 mouseleave 没有冒泡效果 (推荐) 123456789101112131415&lt;body&gt; &lt;div class=&quot;dad&quot;&gt; &lt;div class=&quot;baby&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const dad = document.querySelector(&#x27;.dad&#x27;) const baby = document.querySelector(&#x27;.baby&#x27;) dad.addEventListener(&#x27;mouseover&#x27;, function () &#123; console.log(&#x27;鼠标经过&#x27;) &#125;) dad.addEventListener(&#x27;mouseout&#x27;, function () &#123; console.log(&#x27;鼠标离开&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 鼠标经过dad进入baby时，会打印三行 因为经过baby的时候，虽然baby没有绑定事件，但依然会冒泡至dad的mouseover方法。 2、我们某些情况下需要阻止元素的默认行为的发生，比如 阻止链接的跳转，表单域跳转。 e.preventDefault() 事件解绑onclick的解绑方法： 12345btn.onclick=function()&#123;alert(&#x27;点击了&#x27;)&#125;btn.onclick=null addeventlistener的解绑方法： 1234567function fn()&#123;alert(&#x27;点击了&#x27;)&#125;btn.addEventListener(&#x27;click&#x27;,fn)btn.removeEventListener(&#x27;click&#x27;,fn) 注：匿名函数无法被解绑 事件委托事件委托是利用事件流的特征解决一些现实开发需求的知识技巧，主要的作用是提升程序效率。 大量的事件监听是比较耗费性能的，如下代码所示 1234567891011&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;); for(let i = 0; i &lt;= buttons.length; i++) &#123; // 为 10000 个 button 元素添加了事件 buttons.addEventListener(&#x27;click&#x27;, function () &#123; // 省略具体执行逻辑... &#125;) &#125;&lt;/script&gt; 利用事件流的特征，可以对上述的代码进行优化，事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化，如下代码所示： 12345678910&lt;script&gt; // 假设页面中有 10000 个 button 元素 let buttons = document.querySelectorAll(&#x27;table button&#x27;); // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table let parents = document.querySelector(&#x27;table&#x27;); parents.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;点击任意子元素都会触发事件...&#x27;); &#125;)&lt;/script&gt; 我们的最终目的是保证只有点击 button 子元素才去执行事件的回调函数，如何判断用户点击是哪一个子元素呢？ 事件对象中的属性 target 或 srcElement属性表示真正触发事件的元素，它是一个元素类型的节点。 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul&gt; &lt;li&gt;第1个孩子&lt;/li&gt; &lt;li&gt;第2个孩子&lt;/li&gt; &lt;li&gt;第3个孩子&lt;/li&gt; &lt;li&gt;第4个孩子&lt;/li&gt; &lt;li&gt;第5个孩子&lt;/li&gt; &lt;p&gt;我不需要变色&lt;/p&gt; &lt;/ul&gt;&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;) // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table const parents = document.querySelector(&#x27;table&#x27;) parents.addEventListener(&#x27;click&#x27;, function (ev) &#123; // console.log(ev.target); // 只有 button 元素才会真正去执行逻辑 e.target.style.color=&#x27;red&#x27;//这么实现点击&lt;P&gt;标签时仍然会变色，无法实现只点击li才变色 if(ev.target.tagName === &#x27;BUTTON&#x27;) &#123; // 执行的逻辑 &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 优化过的代码只对祖先元素添加事件监听，相比对 10000 个元素添加事件监听执行效率要高许多！！！ tab切换的案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;tab栏切换&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .tab &#123; width: 590px; height: 340px; margin: 20px; border: 1px solid #e4e4e4; &#125; .tab-nav &#123; width: 100%; height: 60px; line-height: 60px; display: flex; justify-content: space-between; &#125; .tab-nav h3 &#123; font-size: 24px; font-weight: normal; margin-left: 20px; &#125; .tab-nav ul &#123; list-style: none; display: flex; justify-content: flex-end; &#125; .tab-nav ul li &#123; margin: 0 20px; font-size: 14px; &#125; .tab-nav ul li a &#123; text-decoration: none; border-bottom: 2px solid transparent; color: #333; &#125; .tab-nav ul li a.active &#123; border-color: #e1251b; color: #e1251b; &#125; .tab-content &#123; padding: 0 16px; &#125; .tab-content .item &#123; display: none; &#125; .tab-content .item.active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tab&quot;&gt; &lt;div class=&quot;tab-nav&quot;&gt; &lt;h3&gt;每日特价&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;javascript:;&quot; data-id=&quot;0&quot;&gt;精选&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;1&quot;&gt;美食&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;2&quot;&gt;百货&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;3&quot;&gt;个护&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;4&quot;&gt;预告&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;tab-content&quot;&gt; &lt;div class=&quot;item active&quot;&gt;&lt;img src=&quot;./assets/tab00.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab01.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab02.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab03.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab04.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //遍历 // const as=document.querySelectorAll(&#x27;.tab-nav a&#x27;) // for(let i=0;i&lt;as.length;i++)&#123; // as[i].addEventListener(&#x27;mouseenter&#x27;,function()&#123; // document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) // as[i].classList.add(&#x27;active&#x27;) // document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) // document.querySelector(`.tab-content .item:nth-child($&#123;i+1&#125;)`).classList.add(&#x27;active&#x27;) // &#125;) // &#125; //事件委托 const ul=document.querySelector(&#x27;.tab-nav ul&#x27;) ul.addEventListener(&#x27;click&#x27;,function(e)&#123; if(e.target.tagName===&#x27;A&#x27;)&#123; document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) e.target.classList.add(&#x27;active&#x27;) const id=+e.target.dataset.id document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) document.querySelector(`.tab-content .item:nth-child($&#123;id+1&#125;)`).classList.add(&#x27;active&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其他事件1. 页面加载事件加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 有些时候需要等页面资源全部处理完了做一些事情 事件名：load监听页面所有资源加载完毕： 123window.addEventListener(&#x27;load&#x27;, function() &#123; // xxxxx&#125;) 事件名：DOMContentLoaded监听页面DOM加载完毕， 无需等待样式表、图像等完全加载。 12document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;&#125;) 2. 元素滚动事件滚动条在滚动的时候持续触发的事件 123window.addEventListener(&#x27;scroll&#x27;, function() &#123; // xxxxx&#125;) 3. 获取位置开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素。 document.documentElement.scrollTop 12345window.addEventListener(&#x27;scroll&#x27;, function() &#123; // xxxxx const n=document.documentElement.scrollTop console.log(n)&#125;) 4. 页面尺寸事件会在窗口尺寸改变的时候触发事件： 123window.addEventListener(&#x27;resize&#x27;, function() &#123; // xxxxx&#125;) 5. 元素尺寸与位置获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 事件名：load 获取元素的可见部分宽高获取元素的可见部分宽高（不包含边框，margin，滚动条等）&#x20; clientWidth和clientHeight rem基准值 flexible.js的源码分析 获取元素的自身宽高获取宽高： 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 获取位置： 获取元素距离自己定位父级元素的左、上距离 offsetLeft和offsetTop 注意是只读属性 获取元素相对于当前视口的宽高element.getBoundingClientRect() 滚动导航栏123456789101112131415161718192021222324&lt;body&gt; &lt;div class=&quot;header&quot;&gt;我是顶部导航栏&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;sk&quot;&gt;秒杀模块&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;backtop&quot;&gt; &lt;img src=&quot;./images/close2.png&quot; alt=&quot;&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; window.addEventListener(&#x27;scroll&#x27;, function () &#123; const n = document.documentElement.scrollTop const sk = document.querySelector(&#x27;.sk&#x27;) const header=document.querySelector(&#x27;.header&#x27;) console.log(n) if (n &gt;= sk.offsetTop) &#123; header.style.top = 0 &#125; else &#123; header.style.top = &#x27;-80px&#x27;//这里一定要加单位 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM操作","path":"/2024/01/16/DOM操作/","content":"DOM（Document Object Model）是将整个 HTML 文档的每一个标签元素视为一个对象，这个对象下包含了许多的属性和方法，通过操作这些属性或者调用这些方法实现对 HTML 的动态更新，为实现网页特效以及用户交互提供技术支撑。 简言之 DOM 是用来动态修改 HTML 的，其目的是开发网页特效及用户交互。 概念DOM 树 DOM 节点节点是文档树的组成部分，每一个节点都是一个 DOM 对象，主要分为元素节点、属性节点、文本节点等。 【元素节点】其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点。 【属性节点】是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性。 【文本节点】是指 HTML 标签的文字内容，如 title 标签中的文字。 【根节点】特指 html 标签。 其它… documentdocument 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，document 是学习 DOM 的核心。 1234567891011&lt;script&gt; // document 是内置的对象 // console.log(typeof document); // 1. 通过 document 获取根节点 console.log(document.documentElement); // 对应 html 标签 // 2. 通过 document 节取 body 节点 console.log(document.body); // 对应 body 标签 // 3. 通过 document.write 方法向网页输出内容 document.write(&#x27;Hello World!&#x27;); &lt;/script&gt; 上述列举了 document 对象的部分属性和方法，我们先对 document 有一个整体的认识 获取dom对象 querySelector 满足条件的第一个元素 querySelectorAll 满足条件的元素集合 返回伪数组 了解其他方式 getElementById getElementsByTagName 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;DOM - 查找节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;查找元素类型节点&lt;/h3&gt; &lt;p&gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const p = document.querySelector(&#x27;p&#x27;) // 获取第一个p元素 const lis = document.querySelectorAll(&#x27;li&#x27;) // 获取第一个p元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结： document.getElementById 专门获取元素类型节点，根据标签的 id 属性查找 任意 DOM 对象都包含 nodeType 属性，用来检检测节点类型 操作元素内容操作元素内容通过修改 DOM 的文本内容，动态改变网页的内容。 innerText 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签不会被解析。1234567&lt;script&gt;// innerText 将文本内容添加/更新到任意标签位置const intro = document.querySelector(&#x27;.intro&#x27;)// intro.innerText = &#x27;嗨~ 我叫李雷！&#x27;// intro.innerText = &#x27;&lt;h4&gt;嗨~ 我叫李雷！&lt;/h4&gt;&#x27;&lt;/script&gt; innerHTML 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签会被解析。12345678&lt;script&gt;// innerHTML 将文本内容添加/更新到任意标签位置const intro = document.querySelector(&#x27;.intro&#x27;)intro.innerHTML = &#x27;嗨~ 我叫韩梅梅！&#x27;intro.innerHTML = &#x27;&lt;h4&gt;嗨~ 我叫韩梅梅！&lt;/h4&gt;&#x27;&lt;/script&gt; 总结：如果文本内容中包含 html 标签时推荐使用 innerHTML，否则建议使用 innerText 属性。 操作元素属性 有3种方式可以实现对属性的修改： 常用属性修改 直接能过属性名修改，最简洁的语法12345678910&lt;script&gt;// 1. 获取 img 对应的 DOM 元素const pic = document.querySelector(&#x27;.pic&#x27;)// 2. 修改属性pic.src = &#x27;./images/lion.webp&#x27;pic.width = 400;pic.alt = &#x27;图片不见了...&#x27;&lt;/script&gt; 控制样式属性 应用【修改样式】，通过修改行内样式 style 属性，实现对样式的动态修改。 通过元素节点获得的 style 属性本身的数据类型也是对象，如 box.style.color、box.style.width 分别用来获取元素节点 CSS 样式的 color 和 width 的值。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.style.color = &#x27;red&#x27; box.style.width = &#x27;300px&#x27; // css 属性的 - 连接符与 JavaScript 的 减运算符 // 冲突，所以要改成驼峰法 box.style.backgroundColor = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 css 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，如 background-color 要写成 box.style.backgroundColor 操作类名(className) 操作CSS 如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt; &lt;style&gt; .pink &#123; background: pink; color: hotpink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.className = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 1.由于class是关键字, 所以使用className去代替 2.className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名 通过 classList 操作类控制CSS 为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 200px; background-color: pink; &#125; .active &#123; width: 300px; height: 300px; background-color: hotpink; margin-left: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;script&gt; // 1.获取元素 // let box = document.querySelector(&#x27;css选择器 let box = document.querySelector(&#x27;div&#x27;) // add是个方法 添加 追加 // box.classList.add(&#x27;active&#x27;) // remove() 移除 类 // box.classList.remove(&#x27;one&#x27;) // 切换类，有就删掉，没有就加上 box.classList.toggle(&#x27;one&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作表单元素属性表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 正常的有属性有取值的跟其他的标签属性没有任何区别 获取:DOM对象.属性名 设置:DOM对象.属性名&#x3D; 新值 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;请输入&quot;&gt; &lt;button disabled&gt;按钮&lt;/button&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;agree&quot;&gt; &lt;script&gt; // 1. 获取元素 let input = document.querySelector(&#x27;input&#x27;) // 2. 取值或者设置值 得到input里面的值可以用 value // console.log(input.value) input.value = &#x27;小米手机&#x27; input.type = &#x27;password&#x27; // 2. 启用按钮 let btn = document.querySelector(&#x27;button&#x27;) // disabled 不可用 = false 这样可以让按钮启用 btn.disabled = false // 3. 勾选复选框 let checkbox = document.querySelector(&#x27;.agree&#x27;) checkbox.checked = false &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 自定义属性标准属性: 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作比如： disabled、checked、selected 自定义属性： 在html5中推出来了专门的data-自定义属性 &#x20; 在标签上一律以data-开头 在DOM对象上一律以dataset对象方式获取 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div data-id=&quot;1&quot;&gt; 自定义属性 &lt;/div&gt; &lt;script&gt; // 1. 获取元素 let div = document.querySelector(&#x27;div&#x27;) // 2. 获取自定义属性值 console.log([div.dataset.id](http://div.dataset.id)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定时器间歇函数知道间歇函数的作用，利用间歇函数创建定时任务。 setInterval 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数。 12345678910&lt;script&gt; // 1. 定义一个普通函数 function repeat() &#123; console.log(&#x27;不知疲倦的执行下去....&#x27;) &#125; // 2. 使用 setInterval 调用 repeat 函数 // 间隔 1000 毫秒，重复调用 repeat setInterval(repeat, 1000) clearInterval(repeat)//关闭定时器&lt;/script&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript对象","path":"/2024/01/16/对象/","content":"遍历对象for 遍历对象的问题： 对象没有像数组一样的length属性,所以无法确定长度 对象里面是无序的键值对, 没有规律. 不像数组里面有规律的下标 forin: 123456789101112131415// 1. 遍历对象 for in let obj = &#123; uname: &#x27;pink老师&#x27;, age: 18, gender: &#x27;男&#x27; &#125; // 2. 遍历对象 for (let k in obj) &#123; console.log(k) // 属性名 &#x27;uname&#x27; &#x27;age&#x27; // console.log(obj.uname) // console.log(obj.k) // console.log(obj.&#x27;uname&#x27;) // console.log(obj[&#x27;uname&#x27;]) &#x27;uname&#x27; === k console.log(obj[k]) // 输出属性值 obj[k] &#125; 内置对象回想一下我们曾经使用过的 console.log，console其实就是 JavaScript 中内置的对象，该对象中存在一个方法叫 log，然后调用 log 这个方法，即 console.log()。 除了 console 对象外，JavaScritp 还有其它的内置的对象 MathMath 是 JavaScript 中内置的对象，称为数学对象，这个对象下即包含了属性，也包含了许多的方法。 属性 Math.PI，获取圆周率 &#x2F;&#x2F; 圆周率 &#x20; console.log(Math.PI); 方法 Math.random，生成 0 到 1 间的随机数 &#x2F;&#x2F; 0 ~ 1 之间的随机数, 包含 0 不包含 1 &#x20; Math.random() Math.ceil，数字向上取整 &#x2F;&#x2F; 舍弃小数部分，整数部分加1 &#x20; Math.ceil(3.4) Math.floor，数字向下取整 &#x2F;&#x2F; 舍弃小数部分，整数部分不变 &#x20; Math.floor(4.68) Math.round，四舍五入取整 &#x2F;&#x2F; 取整，四舍五入原则 &#x20; Math.round(5.46539) &#x20; Math.round(4.849) Math.round(-1.5) -1 Math.max，在一组数中找出最大的 &#x2F;&#x2F; 找出最大值 &#x20; Math.max(10, 21, 7, 24, 13) Math.min，在一组数中找出最小的 &#x2F;&#x2F; 找出最小值 &#x20; Math.min(24, 18, 6, 19, 21) Math.pow，幂方法 &#x2F;&#x2F; 求某个数的多少次方 &#x20; Math.pow(4, 2) &#x2F;&#x2F; 求 4 的 2 次方 &#x20; Math.pow(2, 3) &#x2F;&#x2F; 求 2 的 3 次方 Math.sqrt，平方根 &#x2F;&#x2F; 求某数的平方根 &#x20; Math.sqrt(16) DateECMAScript 中内置了获取系统时间的对象 Date，使用 Date 时与之前学习的内置对象 console 和 Math 不同，它需要借助 new 关键字才能使用。 实例化123456// 1. 实例化// const date = new Date(); // 系统默认时间const date = new Date(&#x27;2020-05-01&#x27;) // 指定时间// date 变量即所谓的时间对象console.log(typeof date) 方法123456// 1. 实例化 const date = new Date(); // 2. 调用时间对象方法 // 通过方法分别获取年、月、日，时、分、秒 const year = date.getFullYear(); // 四位年份 const month = date.getMonth(); // 0 ~ 11 getFullYear 获取四位年份 getMonth 获取月份，取值为 0 ~ 11 getDate 获取月份中的每一天，不同月份取值也不相同 getDay 获取星期，取值为 0 ~ 6 getHours 获取小时，取值为 0 ~ 23 getMinutes 获取分钟，取值为 0 ~ 59 getSeconds 获取秒，取值为 0 ~ 59 时间戳时间戳是指1970年01月01日00时00分00秒起至现在的总秒数或毫秒数，它是一种特殊的计量时间的方式。 注：ECMAScript 中时间戳是以毫秒计的。 12345678 // 1. 实例化 const date = new Date() // 2. 获取时间戳 console.log(date.getTime())// 还有一种获取时间戳的方法 console.log(+new Date()) // 还有一种获取时间戳的方法,这个方法只能获得当前的时间戳 console.log(Date.now()) 获取时间戳的方法，分别为 getTime 和 Date.now 和 +new Date()","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript函数","path":"/2024/01/16/函数/","content":"作用域作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件 处于全局作用域内的变量，称为全局变量 局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。 处于局部作用域内的变量称为局部变量 如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐 但是有一种情况，函数内部的形参可以看做是局部变量。 具名函数声明：function fn() {} 调用：fn() 匿名函数函数可以分为具名函数和匿名函数 匿名函数：没有名字的函数,无法直接使用。可以通过函数表达式和立即执行函数来使用。 函数表达式&#x2F;&#x2F; 声明 &#x20; let fn &#x3D; function() { &#x20; console.log(‘函数表达式’) &#x20; } &#x20; &#x2F;&#x2F; 调用 &#x20; fn() 立即执行函数用于避免全局变量之间的污染 (function(){ xxx })(); &#x20; (function(){xxxx}()); 无需调用，立即执行，其实本质已经调用了 多个立即执行函数之间用分号隔开 逻辑中断短路：只存在于 &amp;&amp; 和 || 中，当满足一定条件会让右边代码不执行 原因：通过左边能得到整个式子的结果，因此没必要再判断右边 运算结果：无论 &amp;&amp; 还是 || ，运算结果都是最后被执行的表达式值，一般用在变量赋值","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript数组","path":"/2024/01/16/数组/","content":"常用api增加元素arr.push push() 方法将指定的元素添加到数组的末尾，并返回新的数组长度。会修改原有数组。 arr.concat([v1,v2]) concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 arr.unshift（v1,v2） unshift() 方法将指定元素添加到数组的开头，并返回数组的新长度。 删除元素arr.splice(start, deleteCount, item1, item2, itemN) splice() 方法通过移除或者替换已存在的元素和&#x2F;或添加新元素就地改变一个数组的内容。 arr.toSpliced() Array 实例的 toSpliced() 方法是 splice() 方法的复制版本。它返回一个新数组，并在给定的索引处删除和&#x2F;或替换了一些元素。 arr.pop() pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。 arr.shift() shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 复制arr.copyWithin(target, start, end) copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。 123456789const array1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];// Copy to index 0 the element at index 3console.log(array1.copyWithin(0, 3, 4));// Expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]// Copy to index 1 all elements from index 3 to the endconsole.log(array1.copyWithin(1, 3));// Expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;] 填充arr.fill(value,start,end) fill() 方法用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组。 反转arr.reverse() reverse() 方法就地反转数组中的元素，并返回同一数组的引用。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。换句话说，数组中的元素顺序将被翻转，变为与之前相反的方向。 arr.toReversed() Array 实例的 toReversed() 方法是 reverse() 方法对应的复制版本。它返回一个元素顺序相反的新数组。 排序arr.sort() sort() 方法就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。 arr.toSorted() Array 实例的 toSorted() 方法是 sort() 方法的复制方法版本。它返回一个新数组，其元素按升序排列。 数组map 方法使用场景： map 可以遍历数组处理数据，并且返回新的数组 语法： 123456789101112&lt;body&gt; &lt;script&gt; const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) &#123; // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + &#x27;颜色&#x27; &#125;)console.log(newArr)&lt;/script&gt;&lt;/body&gt; map 也称为映射。映射是个术语，指两个元素的集之间元素相互“对应”的关系。 map重点在于有返回值，forEach没有返回值（undefined） 数组join方法作用： join() 方法用于把数组中的所有元素转换一个字符串 语法： 1234567891011121314151617181920&lt;body&gt; &lt;script&gt; const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) &#123; // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + &#x27;颜色&#x27; &#125;) console.log(newArr) // 2. 数组join方法 把数组转换为字符串 // 小括号为空则逗号分割 console.log(newArr.join()) // red颜色,blue颜色,pink颜色 // 小括号是空字符串，则元素之间没有分隔符 console.log(newArr.join(&#x27;&#x27;)) //red颜色blue颜色pink颜色 console.log(newArr.join(&#x27;|&#x27;)) //red颜色|blue颜色|pink颜色 &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript运算","path":"/2024/01/16/运算/","content":"模板字符串document.write(大家好，我叫$&#123;uname&#125;， 我今年贵庚$&#123;age&#125;岁了) 比较运算符如果相等操作符两边的操作数，不包含 null 或者 undefined，且两个操作数不全是对象，在执行相等比较之前，会先调用 Number() 将两个操作数强制转为 Number 类型，然后进行比较。 转换规则：在比较运算符时会优先转换操作数（强制转换），然后再进行比较。 &#x20;第一步：如果有一个操作数类型为布尔值，则在比较相等之前将其转换为数值类型，即 false &#x3D;&gt; 0, true &#x3D;&gt; 1; &#x20;第二步：如果一个操作数是字符串，另一个是数值，在比较前先将字符串转换成数值 &#x20;第三步：在双等号对比时，左右类型相等的情况下，采用三等号的方式进行比较，严格的运算符判定规则 基本数据类型： 如果有一个操作数是（number，string，Boolean），则在比较相等性之前，将其转换为数值; 在比较相等性之前，不能将 null 和 undefined 转成其他值，且null 和 undefined 是相等的。 如果有一个操作数是 NaN，则都返回 false；（NaN不与任何相等，包括NaN） 123456&#x27;55&#x27; == 55; //true （ Number(&#x27;55&#x27;) -&gt; 55 ）&#x27;1.232&#x27;==1.232; //truefalse == 0; //true （ Number(false ) -&gt; 0 ）&quot;wise&quot; == 3; //false （ Number(&quot;wise&quot;) -&gt; NaN ）[] == 0; //true （ Number([]) -&gt; 0 ） 复杂数据类型： 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；&#x20; 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true； 123456NaN == NaN; //false （参考第4条规则）[] == []; //false[] == ![]; //true&#123;&#125; == &#123;&#125;; //false&#123;&#125; == !&#123;&#125;; //false [] &#x3D;&#x3D; [] 和 {} &#x3D;&#x3D; {}在 JavaScript 中，Object、Array、Function、RegExp、Date 都是引用类型。声明引用类型的时候，变量名保存在 js 的栈内存里面，而对应的值保存在堆内存里面。而这个变量在栈内存中实际保存的是：这个值在堆内存中的地址，也就是指针。 12345678var a = &#123;&#125;;var b = &#123;&#125;;var c = b;a == b; //false（变量a,b保存的分别是a,b的指针，它们指向不同的对象）b == c; //true（变量c保存的是b的指针，它们指向同一个对象）注意：如果两个对象指向同一个对象，相等操作符返回 true，否则则为false [] &#x3D;&#x3D; ![] 和 {} &#x3D;&#x3D; !{}逻辑非 (!) 的优先级高于相等操作符 ( &#x3D;&#x3D; ) 1234567891011121314151617181920[] == ![] //![] == false -&gt;Number([]) == Number(false) -&gt; 0 == 0 -&gt; true&#123;&#125; == !&#123;&#125; //!&#123;&#125; == false -&gt; Number(&#123;&#125;) == Number(false) -&gt; NaN == 0 -&gt; false注意：转布尔值==》Boolean() 代表空、否定的值会被转换为 false ，如 &#x27;&#x27;、0、NaN、null、undefined转数字类型：Number(false) // 0;Number(true) // 1;Number(&#x27;&#x27;) // 0;Number(&#x27;12&#x27;) // 12;Number(&#x27;sda&#x27;) // NaN;Number([1,2]) // NaN;Number(&#123;&#125;) // NaN; 转换对象都是NaNNumber(NaN) // NaN;Number(!NaN) // 1;Number(null) // 0;Number(!null) // 1;Number(!undefined) // 1;Number(undefined) // NaN; 数组与数值数组会先通过调用toString()转换为字符串后再转换为数值，比如[true]转换为字符串后为”true”，然后再转换为数值是NaN，所以[true]&#x3D;&#x3D;1返回false。 12345678console.log([]==0); // trueconsole.log([1]==1); // trueconsole.log([&quot;1&quot;]==1); // trueconsole.log([1,2]==1); // falseconsole.log([true]==1); // falseNumber([&#x27;a&#x27;]) // NaN;[&#x27;1&#x27;] == 1 // true; null &#x3D;&#x3D; 0 、null &gt;&#x3D; 0 、null &gt; 01.关系运算符知 和 相等运算符 并不是一个类别的.2.关系运算符，在设计上总是需要运算元道尝试转为一个number，而相等运算符在设计上，则没有这方面的考虑. 12345678910null==0 //false//解释：null在设计上，对比等于的时候不尝试转型. null和0不转型的话，是不会相等的, 所以null == 0结果为false.（在JavaScript旧版源代码中，没有相匹配的项，最后返回末尾的false。）null &gt; 0 // false// 对比大于或小于的时候, null 会尝试转型为number , 转化之后null为0, 0&gt;0是错误的,所以结果为 false.null&gt;=0 // truenull&lt;=0 // true//对比 大于等于 或 小于等于 的时候, 会先判断大于或小于,转型为number,0&gt;0是错误的,但是0=0是正确的, 这是 “或” 的判断, 所以结果为 true 特殊情况： NAN&#x3D;&#x3D;&#x3D;NAN（false） 0.1+0.2&#x3D;&#x3D;&#x3D;0.3（false）js的小数加法存在精度问题 null&#x3D;&#x3D;undefined(true) null&#x3D;&#x3D;&#x3D;undefined(false) []&#x3D;&#x3D;[](false) []&#x3D;&#x3D;&#x3D;[] (false) undefined进行比较时，是作为对象，转化为NaN来处理。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"BFC","path":"/2024/01/16/9.BFC/","content":"9.1 BFC的定义W3C 上对 BFC 的定义： 译文：浮动、绝对定位元素、不是块盒子的块容器（如 inline-blocks 、 table-cells 和table-captions ），以及 overflow 属性的值除 visible 以外的块盒，将为其内容建立新的块格式化上下文。 MDN 上对 BFC 的描述： 块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 更加通俗的描述： BFC 是 Block Formatting Context （块级格式上下文），可以理解成元素的一个“特异功能”。 &#x20;该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活。 所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）。 9.2 开启了BFC能解决什么问题 元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题。 元素开启 BFC 后，自己不会被其他浮动元素所覆盖。 元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷。 9.3 如何开启BFC 根元素 浮动元素 绝对定位、固定定位的元素 行内块元素 表格单元格： table 、 thead 、 tbody 、 tfoot 、 th 、 td 、 tr 、 caption overflow 的值不为 visible 的块元素 伸缩项目 多列容器 column-span 为 all 的元素（即使该元素没有包裹在多列容器中） display 的值，设置为 flow-root 例子1：解决margin塌陷问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_BFC_演示1&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; /* display: flex; */ &#125; .outer &#123; width: 400px; background-color: #888; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ /* display: flow-root; */ &#125; .inner &#123; width: 100px; height: 100px; margin: 20px; &#125; .inner1 &#123; background-color: orange; &#125; .inner2 &#123; background-color: green; &#125; .inner3 &#123; background-color: deepskyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;hr style=&quot;height: 50px; background-color: red;&quot;&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 例子2：解决float元素遮挡问题 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_BFC_演示2&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; &#125; .box1 &#123; background-color: orange; float: left; &#125; .box2 &#123; background-color: green; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ /* display: flow-root; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 例子3：解决子元素浮动，父元素高度塌陷问题 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_BFC_演示3&lt;/title&gt; &lt;style&gt; .outer &#123; width: 400px; background-color: #888; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ display: flow-root; &#125; .inner &#123; width: 100px; height: 100px; float: left; &#125; .inner1 &#123; background-color: orange; &#125; .inner2 &#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"响应式布局","path":"/2024/01/16/8.响应式布局/","content":"8.1 媒体查询1.媒体类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_媒体查询_媒体类型&lt;/title&gt; &lt;style&gt; h1 &#123; width: 600px; height: 400px; line-height: 400px; background-image: linear-gradient(30deg,red,yellow,green); margin: 0 auto; text-align: center; font-size: 100px; color: white; text-shadow: 0 0 10px black; &#125; /* 只有在打印机或打印预览才应用的样式 */ @media print &#123; h1 &#123; background: transparent; &#125; &#125; /* 只有在屏幕上才应用的样式 */ @media screen &#123; h1 &#123; font-family: &quot;翩翩体-简&quot;; &#125; &#125; /* 一直都应用的样式 */ @media all &#123; h1 &#123; color: red; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;新年快乐&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.媒体特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_媒体查询_媒体特性&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; h1 &#123; height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; &#125; /* 检测到视口的宽度为800px时，应用如下样式 */ @media (width:800px) &#123; h1 &#123; background-color: green; &#125; &#125; /* 检测到视口的宽度小于等于700px时，应用如下样式 */ @media (max-width:700px) &#123; h1 &#123; background-color: orange; &#125; &#125; /* 检测到视口的宽度大于等于900px时，应用如下样式 */ @media (min-width:900px) &#123; h1 &#123; background-color: deepskyblue; &#125; &#125; /* 检测到视口的高度等于800px时，应用如下样式 */ /* @media (height:800px)&#123; h1 &#123; background-color: yellow; &#125; &#125; */ /* 检测到屏幕的宽度等于1536px时，应用如下样式 */ /* @media (device-width:1536px) &#123; h1 &#123; color: white; &#125; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好啊&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3.运算符 only为了处理ie的兼容性问题。让ie直接不认识。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_媒体查询_运算符&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; h1 &#123; height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; &#125; /* 且运算符 */ /* @media (min-width:700px) and (max-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* @media screen and (min-width:700px) and (max-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 或运算符 */ /* @media screen and (max-width:700px) or (min-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 否定运算符 */ /* @media not screen &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 肯定运算符 */ @media only screen and (width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好啊&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 4.常用阈值 5.结合外部样式的写法用法一： 1&lt;link rel=&quot;stylesheet&quot; media=&quot;具体的媒体查询&quot; href=&quot;mystylesheet.css&quot;&gt; 用法二： 123@media screen and (max-width:768px) &#123;/CSS-Code;/&#125;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"伸缩盒模型","path":"/2024/01/16/7.伸缩盒模型/","content":"传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float属性。 flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上 1.伸缩容器、伸缩项目 伸缩容器： 开启了 flex 的元素，就是：伸缩容器。 给元素设置： display:flex 或 display:inline-flex ，该元素就变为了伸缩容器。 display:inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器。 一个元素可以同时是：伸缩容器、伸缩项目。 伸缩项目：伸缩容器所有子元素自动成为了：伸缩项目。 仅伸缩容器的子元素成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目。 无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”。 2.主轴与侧轴主轴： 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）。 侧轴： 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）。 3.主轴方向属性名： flex-direction 常用值如下： row ：主轴方向水平从左到右 —— 默认值 row-reverse ：主轴方向水平从右到左。 column ：主轴方向垂直从上到下。 column-reverse ：主轴方向垂直从下到上 注意：改变了主轴的方向，侧轴方向也随之改变。 4.主轴换行方式属性名： flex-wrap 常用值如下： nowrap ：默认值，不换行。 wrap ：自动换行，伸缩容器不够自动换行。 wrap-reverse ：反向换行。 5.flex-flowflex-flow 是一个复合属性，复合了 flex-direction 和 flex-wrap 两个属性。 值没有顺序要求。 flex-flow: row wrap; 6.主轴对齐方式属性名： justify-content 常用值如下： flex-start ：主轴起点对齐。—— 默认值 flex-end ：主轴终点对齐。 center ：居中对齐 space-between ：均匀分布，两端对齐（最常用）。 space-around ：均匀分布，两端距离是中间距离的一半。 space-evenly ：均匀分布，两端距离与中间距离一致。 7.侧轴对齐方式7.1 一行的情况所需属性： align-items 常用值如下： flex-start ：侧轴的起点对齐。 flex-end ：侧轴的终点对齐。 center ：侧轴的中点对齐。 baseline : 伸缩项目的第一行文字的基线对齐。 stretch ：如果伸缩项目未设置高度，将占满整个容器的高度。—— （默认值） 7.2 多行的情况所需属性： align-content 常用值如下： flex-start ：与侧轴的起点对齐。 flex-end ：与侧轴的终点对齐。 center ：与侧轴的中点对齐。 space-between ：与侧轴两端对齐，中间平均分布。 space-around ：伸缩项目间的距离相等，比距边缘大一倍。 space-evenly : 在侧轴上完全平分。 stretch ：占满整个侧轴。—— 默认值 flex-start 8.伸缩性8.1 flex-basis 概念： flex-basis 设置的是主轴方向的基准长度，会让宽度或高度失效。 备注：主轴横向：宽度失效；主轴纵向：高度失效 作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值 auto ，即：伸缩项目的宽或高。 8.2 flex-grow（伸） 概念： flex-grow 定义伸缩项目的放大比例，默认为 0 ，即：纵使主轴存在剩余空间，也不拉伸（放大）。 规则： 若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）。 若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1&#x2F;6 、 2&#x2F;6 、3&#x2F;6 的空间。 8.3 flex-shrink（缩） 概念： flex-shrink 定义了项目的压缩比例，默认为 1 ，即：如果空间不足，该项目将会缩小。 收缩项目的计算，略微复杂一点，我们拿一个场景举例： 例如： 三个收缩项目，宽度分别为： 200px 、 300px 、 200px ，它们的 flex-shrink 值分别 为： 1 、 2 、 3 若想刚好容纳下三个项目，需要总宽度为 700px ，但目前容器只有 400px ，还差300px 所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算： 计算分母： (200×1) + (300×2) + (200×3) &#x3D; 1400 计算比例： 项目一： (200×1) &#x2F; 1400 &#x3D; 比例值1 项目二： (300×2) &#x2F; 1400 &#x3D; 比例值2 计算最终收缩大小： 项目一需要收缩： 比例值1 × 300 项目二需要收缩： 比例值2 × 300 项目三需要收缩： 比例值3 × 300 9. flex复合属性flex 是复合属性，复合了： flex-grow 、 flex-shrink 、 flex-basis 三个属性，默认值为 0 1 auto 。 如果写 flex:1 1 auto ，则可简写为： flex:auto 如果写 flex:1 1 0 ，则可简写为： flex:1 如果写 flex:0 0 auto ，则可简写为： flex:none 如果写 flex:0 1 auto ，则可简写为： flex:0 auto —— 即 flex 初始值。 10. 项目排序order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 。 11. 单独对齐通过 align-self 属性，可以单独调整某个伸缩项目的对齐方式 默认值为 auto ，表示继承父元素的 align-items 属性。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"多列布局","path":"/2024/01/16/6.多列布局/","content":"作用：专门用于实现类似于报纸的布局。 常用属性如下： column-count ：指定列数，值是数字。 column-width ：指定列宽，值是长度。 columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求。 column-gap ：设置列边距，值是长度。 column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致。 column-rule-width ：设置列与列之间边框的宽度，值是长度。 column-rule-color ：设置列与列之间边框的颜色。 coumn-rule ：设置列边框，复合属性。 column-span 指定是否跨列；值: none 、 all 。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"动画","path":"/2024/01/16/5.动画/","content":"5.1 基本使用第一步：定义关键帧（定义动画） 简单方式定义： 12345678910/*写法一*/@keyframes 动画名 &#123;from &#123;/*property1:value1*//*property2:value2*/&#125;to &#123;/*property1:value1*/&#125;&#125; 完整方式定义： 1234567891011121314151617181920@keyframes 动画名 &#123;0% &#123;/*property1:value1*/&#125;20% &#123;/*property1:value1*/&#125;40% &#123;/*property1:value1*/&#125;60% &#123;/*property1:value1*/&#125;80% &#123;/*property1:value1*/&#125;100% &#123;/*property1:value1*/&#125;&#125; 第二步：给元素应用动画，用到的属性如下： animation-name ：给元素指定具体的动画（具体的关键帧） animation-duration ：设置动画所需时间 animation-delay ：设置动画延迟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_基本使用&lt;/title&gt; &lt;style&gt; .outer &#123; width: 1000px; height: 100px; border: 1px solid black; &#125; /* 定义一个动画（定义一组关键帧）—— 第一种方式 */ @keyframes wangyoudong &#123; /* 第一帧 */ from &#123; &#125; /* 最后一帧 */ to &#123; transform: translate(900px); background-color: red; &#125; &#125; /* 定义一个动画（定义一组关键帧）—— 第二种方式 */ @keyframes wangyoudong2 &#123; /* 第一帧 */ 0% &#123; &#125; /* 29% &#123; background-color: red; &#125; */ /* 48% &#123; background-color: orange; &#125; */ /* 88% &#123; background-color: yellow; &#125; */ /* 最后一帧 */ 100% &#123; transform: translate(900px) rotate(360deg); background-color: purple; border-radius: 50%; &#125; &#125; .inner &#123; width: 100px; height: 100px; background-color: deepskyblue; /* 应用动画到元素 */ animation-name: wangyoudong2; /* 动画持续的时间 */ animation-duration: 3s; /* 动画延迟时间 */ animation-delay: 0.2s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.2 动画的其他属性 animation-timing-function ，设置动画的类型，常用值如下： ease ： 平滑动画 —— 默认值 linear ： 线性过渡 ease-in ： 慢 → 快 ease-out ： 快 → 慢 ease-in-out ： 慢 → 快 → 慢 step-start ： 等同于 steps(1, start) step-end ： 等同于 steps(1, end) steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。 cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。 animation-iteration-count ，指定动画的播放次数，常用值如下： number ：动画循环次数 infinite ： 无限循环 animation-direction ，指定动画方向，常用值如下： normal ： 正常方向 (默认) reverse ： 反方向运行 alternate ： 动画先正常运行再反方向运行，并持续交替运行 alternate-reverse ： 动画先反运行再正方向运行，并持续交替运行 animation-fill-mode ，设置动画之外的状态 forwards ： 设置对象状态为动画结束时的状态 backwards ： 设置对象状态为动画开始时的状态 animation-play-state ，设置动画的播放状态，常用值如下： running ： 运动 (默认) paused ： 暂停 5.3动画复合属性只设置一个时间表示 duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求。 备注： animation-play-state 一般单独使用。 123.inner &#123;animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards;&#125;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"过渡","path":"/2024/01/16/4.过渡/","content":"4.1. transition-property作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会以有过渡 效果。 常用值： none ：不过渡任何属性。 all ：过渡所有能过渡的属性。 具体某个属性名 ，例如： width 、 heigth ，若有多个以逗号分隔。 不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。 常见的支持过渡的属性有：颜色、长度值、百分比、 z-index 、 opacity 、 2D 变换属性、 3D 变换属性、阴影。 4.2. transition-duration作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久。 常用值： 0 ：没有任何过渡时间 —— 默认值。 s 或 ms ：秒或毫秒。 列表 ： 如果想让所有属性都持续一个时间，那就写一个值。 如果想让每个属性持续不同的时间那就写一个时间的列表。 4.3. transition-delay作用：指定开始过渡的延迟时间，单位： s 或 ms 4.4. transition-timing-function作用：设置过渡的类型 常用值： ease ： 平滑过渡 —— 默认值 linear ： 线性过渡 ease-in ： 慢 → 快 ease-out ： 快 → 慢 ease-in-out ： 慢 → 快 → 慢 step-start ： 等同于 steps(1, start) step-end ： 等同于 steps(1, end) steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。 cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。 在线制作贝赛尔曲线：https://cubic-bezier.com 4.5. transition 复合属性如果设置了一个时间，表示 duration ；如果设置了两个时间，第一是 duration ，第二个是delay ；其他值没有顺序要求。 1transition:1s 1s linear all; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_过渡案例&lt;/title&gt; &lt;style&gt; .outer &#123; width: 400px; height: 224px; position: relative; overflow: hidden; &#125; .mask &#123; width: 400px; height: 224px; background-color: black; color: white; position: absolute; top: 0; left: 0; text-align: center; line-height: 224px; font-size: 100px; opacity: 0; transition: 1s linear; cursor: pointer; &#125; img &#123; transition: 0.5s linear; &#125; .outer:hover .mask &#123; opacity: 0.5; &#125; .outer:hover img &#123; transform: scale(1.6) rotate(20deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;img src=&quot;../images/shanghai.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mask&quot;&gt;上海&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot;&gt; &lt;img src=&quot;../images/shanghai.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mask&quot;&gt;上海&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"变换","path":"/2024/01/16/3.变换/","content":"3.1 2D变换3.1.1 2D位移2D 位移可以改变元素的位置，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注意点： 位移与相对定位很相似，都不脱离文档流，不会影响到其它元素。 与相对定位的区别：相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是其自身。 浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高。 transform 可以链式编写，如：transform: translateX(30px) translateY(40px); 位移对行内元素无效。 位移配合定位，可实现元素水平垂直居中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_位移&lt;/title&gt; &lt;style&gt; .outer &#123; width: 200px; height: 200px; border: 2px solid black; margin: 0 auto; margin-top: 100px; position: relative; &#125; .inner &#123; width: 200px; height: 200px; background-color: deepskyblue; /* 水平位移 */ /* transform: translateX(50px); */ /* 垂直位移 */ /* transform: translateY(50px); */ /* 水平+垂直位移 */ /* transform: translate(50px,50px); */ &#125; .inner2 &#123; width: 60px; height: 60px; background-color: orange; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;你好啊&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner2&quot;&gt;你好啊&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.1.2 2D缩放2D 缩放是指：让元素放大或缩小，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注：借助缩放，可实现小于 12px 的文字。 3.1.3 2D旋转2D 旋转是指：让元素在二维平面内，顺时针旋转或逆时针旋转，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注意： rotateZ(20deg) 相当于 rotate(20deg) ， 在平面上实现旋转应用rotateZ 3.1.4 2D扭曲2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 3.1.5 多重变换多个变换，可以同时使用一个 transform 来编写。 transform: translate(-50%, -50%) rotate(45deg); 一般都要把旋转放在最后来写，因为旋转后轴的方向会发生变化。 3.1.5 变换原点 元素变换时，默认的原点是元素的中心，使用 transform-origin 可以设置变换的原点。 修改变换原点对位移没有影响， 对旋转和缩放会产生影响。 如果提供两个值，第一个用于横坐标，第二个用于纵坐标。 如果只提供一个，若是像素值，表示横坐标，纵坐标取 50% ；若是关键词，则另一个坐标取 50% 注： transform-origin: 50% 50% ， 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值 transform-origin: left top ，变换原点在元素的左上角 。 transform-origin: 50px 50px ， 变换原点距离元素左上角 50px 50px 的位置。 transform-origin: 0 ，只写一个值的时候，第二个值默认为 50% 。 3.2 3D变换3.2.1 开启3D空间重要原则：元素进行 3D 变换的首要操作：父元素必须开启 3D 空间！ 使用 transform-style 开启 3D 空间，可选值如下： flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值 preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间） 3.2.2 设置景深何为景深？—— 指定观察者与 z&#x3D;0 平面的距离，能让发生 3D 变换的元素，产生透视效果，看来更加立体。 使用 perspective 设置景深，可选值如下： none ： 不指定透视 ——（默认值） 长度值 ： 指定观察者距离 z&#x3D;0 平面的距离，不允许负值。 注意： perspective 设置给发生 3D 变换元素的父元素！ 3.2.3 透视点位置实质上是camera位置。 所谓透视点位置，就是观察者位置；默认的透视点在元素的中心。 使用 perspective-origin 设置观察者位置（透视点的位置），例如： 注意：通常情况下，我们不需要调整透视点位置。 3.2.4 3D 位移3D 位移是在 2D 位移的基础上，可以让元素沿 z 轴位移，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.5 3D 旋转3D 旋转是在 2D 旋转的基础上，可以让元素沿 x 轴和 y 轴旋转，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.6 3D缩放3D 缩放是在 2D 缩放的基础上，可以让元素沿 z 轴缩放，但html元素没有厚度，所以会在景深上做调整，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.7 多重变换多个变换，可以同时使用一个 transform 来编写。 transform: translateZ(100px) scaleZ(3) rotateY(40deg); 注意点：多重变换时，建议最后旋转。 3.2.8 背部可见性使用 backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下： visible ： 指定元素背面可见，允许显示正面的镜像。—— 默认值 hidden ： 指定元素背面不可见 注意： backface-visibility 需要加在发生 3D 变换元素的自身上。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"CSS3新增内容","path":"/2024/01/16/新增内容/","content":"2.1 新增长度单位 rem 根元素字体大小的倍数，只与根元素字体大小有关。 vw 视口宽度的百分之多少 10vw 就是视口宽度的 10% 。 vh 视口高度的百分之多少 10vh 就是视口高度的 10% 。 vmax 视口宽高中大的那个的百分之多少。（了解即可） vmin 视口宽高中小的那个的百分之多少。（了解即可） 2.2 新增选择器CSS3 新增的选择器有：动态伪类、目标伪类、语言伪类、 UI 伪类、结构伪类、否定伪类、伪元素 2.3 新增盒模型相关属性2.3.1 BOX-SIZING怪异盒模型 2.3.2 resize调整盒子大小使用时要加上overflow，值任意。 2.4.2 box-shadow盒子阴影使用 box-shadow 属性为盒子添加阴影。 语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 2.4.3 opacityopacity 属性能为整个元素添加透明效果， 值是 0 到 1 之间的小数， 0 是完全透明， 1 表示完 全不透明。 opacity 与 rgba 的区别在于 opacity 是一个属性，设置的是整个元素（包括元素里的内容）的不透明度。 rgba 是颜色的设置方式，用于设置颜色，它的透明度，仅仅是调整颜色的透明度 3.新增背景属性3.1 background-origin作用：设置背景图的原点。 语法 padding-box ：从 padding 区域开始显示背景图像。—— 默认值 border-box ： 从 border 区域开始显示背景图像。 content-box ： 从 content 区域开始显示背景图像。 3.2 background-clip作用：设置背景图的向外裁剪的区域。 语法 border-box ： 从 border 区域开始向外裁剪背景。 —— 默认值 padding-box ： 从 padding 区域开始向外裁剪背景。 content-box ： 从 content 区域开始向外裁剪背景。 text ：背景图只呈现在文字上。 注意：若值为 text ，那么 backgroun-clip 要加上 -webkit- 前缀。 3.3 background-size作用：设置背景图的尺寸。 语法： 用长度值指定背景图片大小，不允许负值。 用百分比指定背景图片大小，不允许负值。 auto ： 背景图片的真实大小。 —— 默认值 contain ： 将背景图片等比缩放，使背景图片的宽或高，与容器的宽或高相等，再将完整 背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片。 cover ：将背景图片等比缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要 注意：背景图片有可能显示不完整。—— 相对比较好的选择 3.4. backgorund 复合属性语法： 注意： origin 和 clip 的值如果一样，如果只写一个值，则 origin 和 clip 都设置；如 果设置了两个值，前面的是 origin ，后面的 clip 。 size 的值必须写在 position 值的后面，并且用 &#x2F; 分开。 3.5 多背景图CSS3 允许元素设置多个背景图片 12345/* 添加多个背景图 */background: url(../images/bg-lt.png) no-repeat,url(../images/bg-rt.png) no-repeat right top,url(../images/bg-lb.png) no-repeat left bottom,url(../images/bg-rb.png) no-repeat right bottom; 4. 新增边框属性4.1 边框圆角在 CSS3 中，使用 border-radius 属性可以将盒子变为圆角。 border-radius:10px; border-raidus: 左上角x 右上角x 右下角x 左下角x &#x2F; 左上y 右上y 右下y 左下y 4.2 边框外轮廓outline-width ：外轮廓的宽度。 outline-color ：外轮廓的颜色。 outline-style ：外轮廓的风格。 none ： 无轮廓 dotted ： 点状轮廓 dashed ： 虚线轮廓 solid ： 实线轮廓 double ： 双线轮廓 outline-offset 设置外轮廓与边框的距离，正负值都可以设置。 注意： outline-offset 不是 outline 的子属性，是一个独立的属性。 outline 复合属性 1outline:50px solid blue; 5.新增文本属性5.1文本阴影语法： 默认值： text-shadow:none 表示没有阴影。 5.2 文本换行在 CSS3 中，我们可以使用 white-space 属性设置文本换行方式。 5.3 文本溢出在 CSS3 中，我们可以使用 text-overflow 属性设置文本内容溢出时的呈现模式。 注意：要使得 text-overflow 属性生效，块容器必须显式定义 overflow 为非 visible 值， white-space 为 nowrap 值。 5.4 文本修饰CSS3 升级了 text-decoration 属性，让其变成了复合属性。 子属性及其含义： text-decoration-line 设置文本装饰线的位置 none ： 指定文字无装饰 （默认值） underline ： 指定文字的装饰是下划线 overline ： 指定文字的装饰是上划线 line-through ： 指定文字的装饰是贯穿线 text-decoration-style 文本装饰线条的形状 solid ： 实线 （默认） double ： 双线 dotted ： 点状线条 dashed ： 虚线 wavy ： 波浪线 text-decoration-color 文本装饰线条的颜色 5.5 文本描边注意：文字描边功能仅 webkit 内核浏览器支持。 -webkit-text-stroke-width ：设置文字描边的宽度，写长度值。 -webkit-text-stroke-color ：设置文字描边的颜色，写颜色值。 -webkit-text-stroke ：复合属性，设置文字描边宽度和颜色。 6.新增渐变6.1 线性渐变多个颜色之间的渐变， 默认从上到下渐变。 使用关键词设置线性渐变的方向。 使用角度设置线性渐变的方向。 调整开始渐变的位置 12345background-image: linear-gradient(to top,red,yellow,green);background-image: linear-gradient(to right top,red,yellow,green);background-image: linear-gradient(30deg,red,yellow,green);background-image: linear-gradient(red 50px,yellow 100px ,green 150px); 6.2 径向渐变多个颜色之间的渐变， 默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比） 使用关键词调整渐变圆的圆心位置 使用像素值调整渐变圆的圆心位置。 调整渐变形状为正圆 调整形状的半径 。 调整开始渐变的位置。 1234567background-image: radial-gradient(at right top,red,yellow,green);/*使用关键词调整渐变圆的圆心位置*/background-image: radial-gradient(at 100px 50px,red,yellow,green); /*使用像素值调整渐变圆的圆心位置*/background-image: radial-gradient(circle,red,yellow,green);/*调整渐变形状为正圆*/background-image: radial-gradient(100px,red,yellow,green);/*调整形状的半径*/background-image: radial-gradient(50px 100px,red,yellow,green);background-image: radial-gradient(red 50px,yellow 100px,green 150px)；/*调整开始渐变的位置*/ 6.3 重复渐变无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变。 使用 repeating-linear-gradient 进行重复线性渐变，具体参数同 linear-gradient 。 使用 repeating-radial-gradient 进行重复径向渐变，具体参数同 radial-gradient 。 7.web字体7.1基本用法12345678910111213141516@font-face &#123; font-family: &quot;atguigu&quot;; font-display: swap; src: url(&#x27;webfont.eot&#x27;); /* IE9 */ src: url(&#x27;webfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;webfont.woff2&#x27;) format(&#x27;woff2&#x27;), url(&#x27;webfont.woff&#x27;) format(&#x27;woff&#x27;), /* chrome、firefox */ url(&#x27;webfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* chrome、firefox、opera、Safari, Android*/ url(&#x27;webfont.svg#webfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */&#125;@font-face &#123; font-family: &quot;情书字体&quot;; src: url(&#x27;./方正手迹.ttf&#x27;);&#125; 7.2 字体图标相比图片更加清晰。 灵活性高，更方便改变大小、颜色、风格等。 兼容性好， IE 也能支持。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"CSS3概述","path":"/2024/01/16/1.简介/","content":"1.1 CSS3 的新特性新增了更加实用的选择器，例如：动态伪类选择器、目标伪类选择器、伪元素选择器等等。 新增了更好的视觉效果，例如：圆角、阴影、渐变等。 新增了丰富的背景效果，例如：支持多个背景图片，同时新增了若干个背景相关的属性。 新增了全新的布局方案 —— 弹性盒子。 新增了 Web 字体，可以显示用户电脑上没有安装的字体。 增强了颜色，例如： HSL 、 HSLA 、 RGBA 几种新的颜色模式，新增 opacity 属性来控制 透明度。 增加了 2D 和 3D 变换，例如：旋转、扭曲、缩放、位移等。 增加动画与过渡效果，让效果的变换更具流线性、平滑性。 1.2 CSS3的私有前缀1.2.1 什么是私有前缀如下代码中的 -webkit- 就是私有前缀 12345div &#123; width:400px; height:400px; -webkit-border-radius: 20px;&#125; 1.2.2 为什么要有私有前缀W3C 标准所提出的某个 CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核， 使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了。 举个例子： 12345-webkit-border-radius: 20px;-moz-border-radius: 20px;-ms-border-radius: 20px;-o-border-radius: 20px;border-radius: 20px; 查询 CSS3 兼容性的网站：https://caniuse.com/ 1.2.3 常见浏览器私有前缀Chrome 浏览器： -webkit- Safari 浏览器： -webkit- Firefox 浏览器： -moz- Edge 浏览器： -webkit- 旧 Opera 浏览器： -o- 旧 IE 浏览器： -ms- 注意： 我们在编码时，不用过于关注浏览器私有前缀，不用绞尽脑汁的去记忆，也不用每个都去查询，因 为常用的 CSS3 新特性，主流浏览器都是支持的，即便是为了老浏览器而加前缀，我们也可以借助 现代的构建工具，去帮我们添加私有前缀。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"浮动","path":"/2024/01/16/浮动/","content":"1.浮动在最初，浮动是用来实现文字环绕图片效果的，现在浮动是主流的页面布局方式之一。 浮动后的特点： 🤢脱离文档流。 😊不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高。 😊不会独占一行，可以与其他元素共用一行。 😊不会 margin 合并，也不会 margin 塌陷，能够完美的设置四个方向的 margin和padding。 😊不会像行内块一样被当做文本处理（没有行内块的空白问题）。 2.浮动产生的影响2.1 元素浮动后会有哪些影响对兄弟元素的影响：如果父元素没有高度，会产生高度塌陷， 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。 对父元素的影响： 不能撑起父元素的高度，导致 父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。 2.2 解决浮动产生的影响（清除浮动）解决方案： 方案一： 给父元素指定高度。 方案二： 给父元素也设置浮动，带来其他影响。 方案三： 给父元素设置 overflow:hidden 。 前三种可以解决父元素高度塌陷的问题，但不能解决兄弟元素被覆盖的问题。 4.方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both 。 意思是清除前面所有兄弟的浮动产生的影响，前提是这个元素不浮动并且不是行内元素。 5.方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推荐使用 但是使用时前面的兄弟元素必须全为浮动元素。 12345.parent::after &#123; content: &quot;&quot;; display: block; clear:both;&#125; 布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"定位","path":"/2024/01/16/定位/","content":"1.相对定位1、 如何设置相对定位？给元素设置 position:relative 即可实现相对定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、 相对定位的参考点在哪里？相对自己原来的位置 3、相对定位的特点： 不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 默认规则是： 定位的元素会盖在普通元素之上。都发生定位的两个元素，后写的元素会盖在先写的元素之上。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 相对定位的元素，也能继续浮动，但不推荐这样做。 相对行为的元素，也能通过 margin 调整位置，但不推荐这样做。 注意：绝大多数情况下，相对定位，会与绝对定位配合使用。 4.使用场景 1.对位置微调 2.配合绝对定位适用 2.绝对定位1、 如何设置绝对定位？给元素设置 position: absolute 即可实现绝对定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、绝对定位的参考点在哪里？参考它的包含块。 什么是包含块？ 对于没有脱离文档流的元素：包含块就是父元素； 对于脱离文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都没定位，那包含块就是整个页面）。 3、 绝对定位元素的特点： 脱离文档流，会对后面的兄弟元素、父元素有影响。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 绝对定位、浮动不能同时设置，如果同时设置，浮动失效，以定位为主。 绝对定位的元素，也能通过 margin 调整位置，但不推荐这样做。 无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了定位元素。 何为定位元素？ —— 默认宽、高都被内容所撑开，且能自由设置宽高。 3.固定定位1、 如何设置为固定定位？给元素设置 position: fixed 即可实现固定定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、定定位的参考点在哪里？参考它的视口 什么是视口？—— 对于 PC 浏览器来说，视口就是我们看网页的那扇“窗户”。 3、 固定定位元素的特点 脱离文档流，会对后面的兄弟元素、父元素有影响。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 固定定位和浮动不能同时设置，如果同时设置，浮动失效，以固定定位为主。 固定定位的元素，也能通过 margin 调整位置，但不推荐这样做。 无论是什么元素（行内、行内块、块级）设置为固定定位之后，都变成了定位元素 4.粘性定位1、如何设置为粘性定位？给元素设置 position:sticky 即可实现粘性定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置，不过最常用的是 top 值。 2、粘性定位的参考点在哪里？离它最近的一个拥有“滚动机制”的祖先元素，即便这个祖先不是最近的真实可滚动祖先。 3、粘性定位元素的特点不会脱离文档流，它是一种专门用于窗口滚动时的新的定位方式。 最常用的值是 top 值。 粘性定位和浮动可以同时设置，但不推荐这样做。 粘性定位的元素，也能通过 margin 调整位置，但不推荐这样做。 粘性定位和相对定位的特点基本一致，不同的是：粘性定位可以在元素到达某个位置时将其固定。 5.定位层级 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 如果位置发生重叠，默认情况是：后面的元素，会显示在前面元素之上。 可以通过 css 属性 z-index 调整元素的显示层级。 z-index 的属性值是数字，没有单位，值越大显示层级越高。 只有定位的元素设置 z-index 才有效。 如果 z-index 值大的元素，依然没有覆盖掉 z-index 值小的元素，那么请检查其包含块的层级。 6.定位的特殊应用定位可以越过父元素的padding注意： 发生固定定位、绝对定位后，元素都变成了定位元素，默认宽高被内容撑开，且依然可以设置宽高。 发生相对定位后，元素依然是之前的显示模式。 以下所说的特殊应用，只针对 绝对定位 和 固定定位 的元素，不包括相对定位的元素 1、让定位元素的宽充满包含块定位元素可以没有宽高。 块宽想与包含块一致，可以给定位元素同时设置 left 和 right 为 0 。 高度想与包含块一致， top 和 bottom 设置为 0 。 2、让定位元素在包含块中居中这种情况需要子元素有宽和高。 12345left:0;right:0;top:0;bottom:0;margin:auto; 或者 1234left: 50%;top: 50%;margin-left: 负的宽度一半;margin-top: 负的高度一半;","tags":["CSS","前端"],"categories":["CSS"]},{"title":"重置默认样式","path":"/2024/01/16/布局/","content":"重置默认样式 很多元素都有默认样式，比如： p 元素有默认的上下 margin 。 h1~h6 标题也有上下 margin ，且字体加粗。 body 元素有默认的 8px 外边距。 超链接有默认的文字颜色和下划线。 ul 元素有默认的左 pading 。 方案一：使用全局选择器此种方法，在简单案例中可以用一下，但实际开发中不会使用，因为 * 选择的是所有元素，而并 不是所有的元素都有默认样式；而且我们重置时，有时候是需要做特定处理的，比如：想让 a 元 素的文字是灰色，其他元素文字是蓝色。 方案二：reset.css选择到具有默认样式的元素，清空其默认的样式。 经过 reset 后的网页，好似“一张白纸”，开发人员可根据设计稿，精细的去添加具体的样式。 { margin: 0; padding: 0; …… } 方案三：Normalize.cssNormalize.css 是一种最新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式。 官网地址：http://necolas.github.io/normalize.css/ 相对于 reset.css ， Normalize.css 有如下优点： 保护了有价值的默认样式，而不是完全去掉它们。 为大部分HTML元素提供一般化的样式。 新增对 HTML5 元素的设置。 对并集选择器的使用比较谨慎，有效避免调试工具杂乱。 备注： Normalize.css 的重置，和 reset.css 相比，更加的温和，开发时可根据实际情况进行 选择。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"盒子模型","path":"/2024/01/16/盒子模型/","content":"1.长度单位 px ：像素。 em ：相对元素 font-size 的倍数。如果子元素没有，就往父元素上找。 rem ：相对根字体大小，html标签就是根。 % ：相对父元素计算。 2.元素的显示模式2.1块元素（block）&lt;div&gt; 又称：块级元素 特点： 在页面中独占一行，不会与任何元素共用一行，是从上到下排列的。 默认宽度：撑满父元素。 默认高度：由内容撑开。 可以通过 CSS 设置宽高。 2.2行内元素（inline）&lt;span&gt; 又称：内联元素 特点: 1.在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列 2.默认宽度：由内容撑开。 &#x2F;* 自定义鼠标光标 *&#x2F; cursor: url(“.&#x2F;arrow.png”),pointer; 3. 默认高度：由内容撑开。 4.无法通过 CSS 设置宽高。 2.3行内块元素（inline-block）&lt;img&gt; 又称：内联块元素 特点： 1.在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。 2.默认宽度：由内容撑开。 3.默认高度：由内容撑开。 4.可以通过 CSS 设置宽高。 注意：元素早期只分为：行内元素、块级元素，区分条件也只有一条：”是否独占一行”，如果按照这种分类方式，行内块元素应该算作行内元素。 3.总结块元素（block） 主体结构标签： &lt;html&gt; 、 &lt;body&gt; 排版标签： &lt;h1&gt; ~ &lt;h6&gt; 、 &lt;hr&gt; 、 &lt;p&gt; 、 &lt;pre&gt; 、 &lt;div&gt; 列表标签： &lt;ul&gt; 、 &lt;ol&gt; 、 &lt;li&gt; 、 &lt;dl&gt; 、 &lt;dt&gt; 、 &lt;dd&gt; 表格相关标签： &lt;table&gt; 、 &lt;tbody&gt; 、 &lt;thead&gt; 、 &lt;tfoot&gt; 、 &lt;tr&gt; 、 &lt;caption&gt; &#x20; 5.&lt;form&gt; 与 &lt;option&gt; 行内元素（inline） 文本标签： &lt;br&gt; 、 &lt;em&gt; 、 &lt;strong&gt; 、 &lt;sup&gt; 、 &lt;sub&gt; 、 &lt;del&gt; 、 &lt;ins&gt; &lt;a&gt; 与 &lt;label&gt; 行内块元素（inline-block） 图片： &lt;img&gt; 单元格： &lt;td&gt; 、 &lt;th&gt; 表单控件： &lt;input&gt; 、 &lt;textarea&gt; 、 &lt;select&gt; 、 &lt;button&gt; 框架标签： &lt;iframe&gt; 4.修改元素的显示模式通过 CSS 中的 display 属性可以修改元素的默认显示模式，常用值如下： none：元素会被隐藏。 block：元素将作为块级元素显示。 inline：元素将作为内联元素显示。 inline-block：元素将作为行内块元素显示 5.盒子模型组成 margin（外边距）： 盒子与外界的距离。 border（边框）： 盒子的边框。 padding（内边距）： 紧贴内容的补白区域。 content（内容）：元素中的文本或后代元素都是它的内容。 盒子的大小 &#x3D; content + 左右 padding + 左右 border 。 5.1 paddingpadding 复合属性的使用规则： padding: 10px; 四个方向内边距都是 10px 。 padding: 10px 20px; 上 10px ，左右 20px 。（上下、左右） padding: 10px 20px 30px; 上 10px ，左右 20px ，下 30px 。（上、左右、下） padding: 10px 20px 30px 40px; 上 10px ，右 20px ，下 30px ，左 40px 。（上、右、 下、左） 注意点： padding 的值不能为负数。 行内元素 的 左右内边距是没问题的，上下内边距不能完美的设置。 块级元素、行内块元素，四个方向内边距都可以完美设置。 5.2 margin注意事项 子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着子元素） 上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素的位置。 块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右margin 可以完美设置，上下 margin 设置无效。 margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级元素会在父元素中水平居中。 margin 的值可以是负值。 5.3 margin塌陷问题什么是 margin 塌陷？第一个子元素的上 margin 会作用在父元素上，最后一个子元素的下 margin 会作用在父元素上。如何解决 margin 塌陷？方案一： 给父元素设置不为 0 的 padding 。方案二： 给父元素设置宽度不为 0 的 border 。方案三：给父元素设置 css 样式 overflow:hidden 5.4 margin合并问题什么是 margin 合并？ 上面兄弟元素的下外边距和下面兄弟元素的上外边距会合并，取一个最大的值，而不是相加。 如何解决 margin 塌陷？ 无需解决，布局的时候上下的兄弟元素，只给一个设置上下外边距就可以了。 6.内容溢出 7.隐藏元素方式一：visibility 属性 visibility 属性默认值是 show ，如果设置为 hidden ，元素会隐藏。 元素看不见了，还占有原来的位置（元素的大小依然保持）。 方式二： display 属性 设置 display:none ，就可以让元素隐藏。 彻底地隐藏，不但看不见，也不占用任何位置，没有大小宽高。 8.样式的继承有些样式会继承，元素如果本身设置了某个样式，就使用本身设置的样式；但如果本身没有设置某个样式，会从父元素开始一级一级继承（优先继承离得近的祖先元素）。 会继承的 css 属性： 字体属性、文本属性、文字颜色等 不会继承的 css 属性： 边框、背景、内边距、外边距、宽高、溢出方式等 一个规律：能继承的属性，都是不影响布局的，简单说：都是和盒子模型没关系的。 9.默认样式元素一般都有默认的样式，例如： &lt;a&gt; 元素：下划线、字体颜色、鼠标小手。 &lt;h1&gt; ~ &lt;h6&gt; 元素： 文字加粗、文字大小、上下外边距。 &lt;p&gt; 元素：上下外边距 &lt;ul&gt; 、 ol 元素：左内边距 body 元素： 8px 外边距（4个方向） 优先级：元素的默认样式 &gt; 继承的样式，所以如果要重置元素的默认样式，选择器一定要直接选择器到该元素。 10.布局效果1.行内元素、行内块元素，可以被父元素当做文本处理 即：可以像处理文本对齐一样，去处理：行内、行内块在父元素中的对齐。 例如： text-align 、 line-height 、 text-indent 等。 2.如何让子元素，在父亲中 水平居中： 若子元素为块元素，给父元素加上： margin:0 auto; 。 若子元素为行内元素、行内块元素，给父元素加上： text-align:center 。 📌3.如何让子元素，在父亲中 垂直居中： 若子元素为块元素，给子元素加上： margin-top ，值为：(父元素 content －子元素盒子 总高) &#x2F; 2。 若子元素为行内元素、行内块元素： 让父元素的 height &#x3D; line-height ，每个子元素都加上： vertical-align:middle; 。 补充：若想绝对垂直居中，父元素 font-size 设置为 0 。 11.元素之间的空白问题产生的原因： 行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符。 解决方案： 方案一： 去掉换行和空格（不推荐）。 方案二： 给父元素设置 font-size:0 ，再给需要显示文字的元素，单独设置字体大小（推 荐）。 12.行内块的幽灵空白问题产生原因： 行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的。 解决方案： &#x20;方案一： 给行行内块设置 vertical ，值不为 baseline 即可，设置为 middel 、 bottom 、top 均可。 方案二： 若父元素中只有一张图片，没有文字，设置图片为 display:block 。 方案三： 给父元素设置 font-size: 0 。如果该行内块内部还有文本，则需单独设置 font-size 。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"常用属性","path":"/2024/01/16/常用属性/","content":"1.字体font-size：字体的大小font-family：控制字体类型。可以设置多个字体，按照从左到右的顺序逐个查找，找到就用，没有找到就使用后面 的，且通常在最后写上 serif （衬线字体）或 sans-serif （非衬线字体）。 font-style：字体是否为斜体常用值： normal ：正常（默认值） italic ：斜体（使用字体自带的斜体效果） oblique ：斜体（强制倾斜产生的斜体效果） 实现斜体时，更推荐使用 italic 。 font-weight：控制字体的粗细。 lighter ：细 normal ： 正常 bold ：粗 bolder ：很粗 （多数字体不支持） 字体复合写法属性名： font ，可以把上述字体样式合并成一个属性。 作用：将上述所有字体相关的属性复合在一起编写。 编写规则： 字体大小、字体族必须都写上。 字体族必须是最后一位、字体大小必须是倒数第二位。 各个属性间用空格隔开。 实际开发中更推荐复合写法，但这也不是绝对的，比如只想设置字体大小，那就直接用 font- size 属性 2.文本color： 颜色名 rgb 或 rgba HEX 或 HEXA （十六进制） HSL 或 HSLA 开发中常用的是： rgb&#x2F;rgba 或 HEX&#x2F;HEXA （十六进制）。 间距：字母间距： letter-spacing 单词间距： word-spacing （通过空格识别词，每个中文算一个letter） 属性值为像素（ px ），正值让间距增大，负值让间距缩小。 text-decoration:控制文本的各种装饰线。可选值： none ： 无装饰线（常用） underline ：下划线（常用） overline ： 上划线 line-through ： 删除线 可搭配如下值使用： dotted ：虚线 wavy ：波浪线 也可以指定颜色 text-indent：文本缩进作用：控制文本首字母的缩进。 属性值： css 中的长度单位，例如： px text-align：控制文本的水平对齐方式。常用值： left ：左对齐（默认值） right ：右对齐 center ：居中对齐 line-height：制一行文字的高度。可选值： normal ：由浏览器根据文字大小决定的一个默认值。 像素( px )。 数字：参考自身 font-size 的倍数（很常用）。 百分比：参考自身 font-size 的百分比。 注 ： line-height 过小会怎样？—— 文字产生重叠，且最小值是 0 ，不能为负数。 line-height 是可以继承的，且为了能更好的呈现文字，最好写数值。 line-height 和 height 是什么关系？ 设置了 height ，那么高度就是 height 的值。 不设置 height 的时候，会根据 line-height 计算高度 文本对齐_垂直 顶部：无需任何属性，在垂直方向上，默认就是顶部对齐。 居中：对于单行文字，让 height &#x3D; line-height 即可。 问题：多行文字垂直居中怎么办？—— 后面我们用定位去做。 3底部：对于单行文字，目前一个临时的方式： 让 line-height &#x3D; ( height × 2 ) - font-size - x 。 备注： x 是根据字体族，动态决定的一个值。 问题：垂直方向上的底部对齐，更好的解决办法是什么？—— 后面我们用定位去做。 vertical-align :垂直对齐方式用于指定同一行元素之间，或 表格单元格内文字的垂直对齐方式。 常用值： baseline （默认值）：使元素的基线与父元素的基线对齐。 top ：使元素的顶部与其所在行的顶部对齐。 middle ：使元素的中部与父元素的基线加上父元素字母 x 的一半对齐。 bottom ：使元素的底部与其所在行的底部对齐。 特别注意： vertical-align 不能控制块元素，只能控制父级元素里的子元素 3.列表属性 4.表格属性4.1边框属性 注意： 以上 4 个边框相关的属性，其他元素也可以用，这是我们第一次遇见它们。 4.2表格属性 5.背景属性 6.鼠标属性","tags":["CSS","前端"],"categories":["CSS"]},{"title":"三大特性","path":"/2024/01/16/三大特性/","content":"1.层叠性概念：如果发生了样式冲突，那就会根据一定的规则（选择器优先级），进行样式的层叠（覆 盖）。 2.继承性概念：元素会自动拥有其父元素、或其祖先元素上所设置的某些样式。 规则：优先继承离得近的。 常见的可继承属性： 3.优先级!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; * &gt; 继承的样 式。 见选择器","tags":["CSS","前端"],"categories":["CSS"]},{"title":"选择器","path":"/2024/01/16/选择器/","content":"1.基本选择器1.1 通配选择器作用：可以选中所有的 HTML 元素。 语法： 123* &#123; color：orange&#125; 备注：清除样式时，会对我们有很大帮助 1.2元素选择器作用：为页面中某种元素统一设置样式。 语法： 1234h1 &#123; color: red; font-size: 40px;&#125; 1.3 类选择器作用：根据元素的 class 值，来选中某些元素。 123.button_choose&#123; color:red;&#125; 注： 一个元素的 class 属性，能写多个值，要用空格隔开，例如： 1&lt;h1 class=&quot;speak big&quot;&gt;你好&lt;/h1&gt; 1.4 ID选择器作用：根据元素的 id 值，来选中某个元素。 123#button_choose&#123; color:red;&#125; 注： 一个元素的 class 属性，能写多个值，要用空格隔开，例如： 1&lt;h1 class=&quot;speak big&quot;&gt;你好&lt;/h1&gt; 注： 1、id 属性值：尽量由字母、数字、下划线( _ )、短杠( - )组成，最好以字母开头、不要包含空 格、区分大小写。 2、一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同。 3、一个元素可以同时拥有 id 和 class 属性。 2.复合选择器2.1交集选择器交集选择器中不可能出现两个元素选择器，因为一个元素，不可能即是 p 元素又是 span 元 素 用的最多的交集选择器是：元素选择器配合类名选择器，例如： p.beauty 。 12345678/* 选中：类名为beauty的p元素，为此种写法用的非常多！！！！ */p.beauty &#123; color: blue;&#125;/* 选中：类名包含rich和beauty的元素 */.rich.beauty &#123; color: green;&#125; 2.2 并集选择器12345678/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */#peiqi,.rich,.beauty &#123; font-size: 40px; background-color: skyblue; width: 200px;&#125; 2.3 后代选择器&#x20;&#x20;子、孙子、重孙子、重重孙子 …… 统称后代 12345678910111213141516/* 选中ul中的所有li */ul li &#123; color: red;&#125;/* 选中ul中所有li中的a */ul li a &#123; color: orange;&#125;/* 选中类名为subject元素中的所有li */.subject li &#123; color: blue;&#125;/* 选中类名为subject元素中的所有类名为front-end的li */.subject li.front-end &#123; color: blue;&#125; 2.4 子代选择器选择器之间，用 &gt; 隔开， &gt; 可以理解为：” xxx 的子代”，其实就是儿子的意思。 只选儿子 12345678/* div中的子代a元素 */div&gt;a &#123; color: red;&#125;/* 类名为persons的元素中的子代a元素 */.persons&gt;a&#123; color: red;&#125; 2.5 兄弟选择器2.5.1相邻兄弟选择器作用：选中指定元素后，符合条件的相邻兄弟元素。 所谓相邻，就是紧挨着他的下一个，简记：睡在我下铺的兄弟。 123456789101112131415161718&lt;html&gt; &lt;style&gt; /* 选中div后相邻的兄弟p元素 */ div+p &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 使用场景： 想让23都变为红色 1234567891011121314&lt;html&gt; &lt;style&gt; li+li &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 2.5.2通用兄弟选择器作用：选中指定元素后，符合条件的所有兄弟元素。（简记：睡在我下铺的所有兄弟） 123456789101112131415&lt;html&gt; &lt;style&gt; /* 选中div后的所有的兄弟p元素 */ div~p &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 注意：两种兄弟选择器，选择的是下面的兄弟。 2.6 属性选择器作用：选中属性值符合一定要求的元素。 语法： [属性名] 选中具有某个属性的元素。 [属性名&#x3D;”值”] 选中包含某个属性，且属性值等于指定值的元素。 [属性名^&#x3D;”值”] 选中包含某个属性，且属性值以指定的值开头的元素。 [属性名$&#x3D;”值”] 选中包含某个属性，且属性值以指定的值结尾的元素。 [属性名 *&#x3D;“值”] 选择包含某个属性，属性值包含指定值的元素 1234567891011/* 选中具有title属性的元素 */div[title]&#123;color:red;&#125;/* 选中title属性值为atguigu的元素 */div[title=&quot;atguigu&quot;]&#123;color:red;&#125;/* 选中title属性值以a开头的元素 */div[title^=&quot;a&quot;]&#123;color:red;&#125;/* 选中title属性值以u结尾的元素 */div[title$=&quot;u&quot;]&#123;color:red;&#125;/* 选中title属性值包含g的元素 */div[title*=&quot;g&quot;]&#123;color:red;&#125; 2.7 伪类选择器作用：选中特殊状态的元素。 2.7.1动态伪类1. :link 超链接未被访问的状态。 2. :visited 超链接访问过的状态。 3.:hover 鼠标悬停在元素上的状态。 4.:active 元素激活的状态。 激活：按下鼠标不松开。 注意点：遵循 LVHA 的顺序，即： link 、 visited 、 hover 、 active 。 5.:focus 获取焦点的元素。 表单类元素才能使用 :focus 伪类。 当用户点击元素、触摸元素、或通过键盘的 “ tab ” 键等方式，选择元素时，就是获得焦点。 2.7.2 结构伪类1.常用的 :first-child 所有兄弟元素中的第一个。 :last-child 所有兄弟元素中的最后一个。 :nth-child(n) 所有兄弟元素中的第 n 个。 :first-of-type 所有同类型兄弟元素中的第一个。 :last-of-type 所有同类型兄弟元素中的最后一个。 :nth-of-type(n) 所有同类型兄弟元素中的 第n个 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;09_伪类选择器_结构伪类_1&lt;/title&gt; &lt;style&gt; /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的） —— 看结构1 */ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的） —— 看结构2 选不到 因为span是第一个儿子*/ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的后代p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子（按照所有兄弟计算的） 所以测试三和测试二会变红—— 看结构3 */ /* div p:first-child &#123; color: red; &#125; */ /* 选中的是p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子（按照所有兄弟计算的） —— 看结构3 测试一测试二测试三都变红 */ p:first-child &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 结构1 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构2 --&gt; &lt;!-- &lt;div&gt; &lt;span&gt;张三：98分&lt;/span&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构3 --&gt; &lt;p&gt;测试1&lt;/p&gt; &lt;div&gt; &lt;p&gt;测试2&lt;/p&gt; &lt;marquee&gt; &lt;p&gt;测试3&lt;/p&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;/marquee&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：关于 n 的值： 0 或 不写 ：什么都选不中 —— 几乎不用。 n ：选中所有子元素 —— 几乎不用。 1~正无穷的整数 ：选中对应序号的子元素。 2n 或 even ：选中序号为偶数的子元素。 2n+1 或 odd ：选中序号为奇数的子元素。 -n+3 ：选中的是前 3 个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;10_伪类选择器_结构伪类_2&lt;/title&gt; &lt;style&gt; /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的）—— 结构1*/ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的最后一个儿子p元素（按照所有兄弟计算的）—— 结构1*/ /* div&gt;p:last-child &#123; color: red; &#125; */ /* 选中的是div的第n个儿子p元素（按照所有兄弟计算的）—— 结构1 */ /* div&gt;p:nth-child(3) &#123; color: red; &#125; */ /* 选中的是div的偶数个儿子p元素（按照所有兄弟计算的）—— 结构2 */ /* 关于n的值 —— 结构2： 1. 0或不写：什么都选不中 —— 几乎不用。 2. n ：选中所有子元素 —— 几乎不用。 3. 1 ~ 正无穷的整数，选中对应序号的子元素。 4. 2n 或 even ：选中序号为偶数的子元素。 5. 2n+1 或 odd ：选中序号为奇数的子元素。 6. -n+3 : 选中前三个。 */ /* div&gt;p:nth-child(2n) &#123; color: red; &#125; */ /* 选中的是div的第一个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:first-of-type&#123; color: red; &#125; */ /* 选中的是div的最后一个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:last-of-type&#123; color: red; &#125; */ /* 选中的是div的第n个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:nth-of-type(5) &#123; color: red; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 结构1 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;p&gt;孙七：58分&lt;/p&gt; &lt;p&gt;老八：48分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构2 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;第1个&lt;/p&gt; &lt;p&gt;第2个&lt;/p&gt; &lt;p&gt;第3个&lt;/p&gt; &lt;p&gt;第4个&lt;/p&gt; &lt;p&gt;第5个&lt;/p&gt; &lt;p&gt;第6个&lt;/p&gt; &lt;p&gt;第7个&lt;/p&gt; &lt;p&gt;第8个&lt;/p&gt; &lt;p&gt;第9个&lt;/p&gt; &lt;p&gt;第10个&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构3 --&gt; &lt;!-- &lt;div&gt; &lt;span&gt;测试1&lt;/span&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;span&gt;测试2&lt;/span&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;span&gt;测试3&lt;/span&gt; &lt;p&gt;孙七：58分&lt;/p&gt; &lt;span&gt;测试4&lt;/span&gt; &lt;p&gt;老八：48分&lt;/p&gt; &lt;span&gt;测试5&lt;/span&gt; &lt;/div&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 了解： :nth-last-child(n) 所有兄弟元素中的倒数第 n 个。 :nth-last-of-type(n) 所有同类型兄弟元素中的 倒数第n个 。 :only-child 选择没有兄弟的元素（独生子女）。 :only-of-type 选择没有同类型兄弟的元素。 :root 根元素。 :empty 内容为空元素（空格也算内容）。 2.7.3 否定伪类:not(选择器) 排除满足括号中条件的元素。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12_伪类选择器_否定伪类&lt;/title&gt; &lt;style&gt; /* 选中的是div的儿子p元素，但是排除类名为fail的元素 */ /* div&gt;p:not(.fail) &#123; color: red; &#125; */ /* 选中的是div的儿子p元素，但是排除title属性值以“你要加油”开头的 */ /* div&gt;p:not([title^=&quot;你要加油&quot;]) &#123; color: red; &#125; */ /* 选中的是div的儿子p元素，但排除第一个儿子p元素 */ div&gt;p:not(:first-child) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;p class=&quot;fail&quot; title=&quot;你要加油啊！孙七&quot;&gt;孙七：58分&lt;/p&gt; &lt;p class=&quot;fail&quot; title=&quot;你要加油啊！老八&quot;&gt;老八：48分&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.7.4 UI伪类:checked 被选中的复选框或单选按钮。 :enable 可用的表单元素（没有 disabled 属性） :disabled 不可用的表单元素（有 disabled 属性）。 2.7.3 目标伪类:target 选中锚点指向的元素 2.7.4 语言伪类:lang() 根据指定的语言选择元素（本质是看 lang 属性的值）。 2.8 伪元素选择器作用：选中元素中的一些特殊位置。 常用伪元素： ::first-letter 选中元素中的第一个文字。 ::first-line 选中元素中的第一行文字。 ::selection 选中被鼠标选中的内容。 ::placeholder 选中输入框的提示文字。 ::before 在元素最开始的位置，创建一个子元素（必须用 content 属性指定内容）。 ::after 在元素最后的位置，创建一个子元素（必须用 content 属性指定内容）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;16_伪元素选择器&lt;/title&gt; &lt;style&gt; /* 什么是伪元素？ —— 很像元素，但不是元素（element），是元素中的一些特殊位置 */ /* 选中的是div中的第一个文字 */ div::first-letter &#123; color: red; font-size: 40px; &#125; /* 选中的是div中的第一行文字 */ div::first-line &#123; background-color: yellow; &#125; /* 选中的是div中被鼠标选择的文字 */ div::selection &#123; background-color: green; color: orange; &#125; /* 选中的是input元素中的提示文字 */ input::placeholder &#123; color: skyblue; &#125; /* 选中的是p元素最开始的位置，随后创建一个子元素 */ p::before &#123; content:&quot;￥&quot;; &#125; /* 选中的是p元素最后的位置，随后创建一个子元素 */ p::after &#123; content:&quot;.00&quot; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt quibusdam amet eligendi velit dolore sequi, exercitationem consequatur, quis maiores tempore accusantium ipsum aspernatur iusto fugiat fuga natus est placeat. Accusamus maiores culpa et sunt dolorum incidunt. Ducimus in odio tempora minima provident deleniti, ex voluptatem facere, molestias unde exercitationem pariatur rem vero ut quidem quaerat aliquam, nam debitis perspiciatis. Facere?&lt;/div&gt; &lt;br&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的用户名&quot;&gt; &lt;p&gt;199&lt;/p&gt; &lt;p&gt;299&lt;/p&gt; &lt;p&gt;399&lt;/p&gt; &lt;p&gt;499&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.选择器优先级行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配选择器。 详细描述： 计算方式：每个选择器，都可计算出一组权重，格式为： (a,b,c) a : ID 选择器的个数。 b : 类、伪类、属性 选择器的个数。 c : 元素、伪元素 选择器的个数。 比较规则：按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比，例如： (1,0,0) &gt; (0,2,2) (1,1,0) &gt; (1,0,3) (1,1,3) &gt; (1,1,2) 特殊规则： 行内样式权重大于所有选择器。 !important 的权重，大于行内样式，大于所有选择器，权重最高！","tags":["CSS","前端"],"categories":["CSS"]},{"title":"Javascript变量与常量","path":"/2024/01/16/变量与常量/","content":"typeof 结果 {} object [] object null object undefined undefined NaN number 0 number true boolean ‘’ string let与var与constvar的特点1、var的作用域 var 声明的作用域是全局的或函数&#x2F;局部的。 当 var 变量在函数外部声明时，作用域是全局的。这意味着在函数体外用 var 声明的任何变量都可以在整个窗口中使用。 var 在函数中声明时，它的作用域是在函数体内。这意味着它只能在该函数中被访问。 2、var 变量可以重新声明和更新 3、var的提升 提升（hoisting）是一种 JavaScript 机制，其中变量和函数声明在代码执行之前被移动到其作用域的顶部。 let的特点1、let是块级作用域 块是由 &#123;&#125; 界定的代码块。一个块存在于花括号中。花括号内的任何内容都是一个块。 因此，在带有 let 的块中声明的变量只能在该块中使用。 2、let可以更新但不能重新声明 就像 var 一样，使用 let 声明的变量可以在其作用域内更新。与 var 不同，let 变量不能在其作用域内重新声明。 3、let的提升 就像 var 一样，let 声明被提升到顶部。与初始化为 undefined 的 var 不同，let 关键字未初始化。所以如果你在声明之前尝试使用 let 变量，你会得到一个 Reference Error。 const的特点1、const 声明是块作用域 与 let 声明一样，const 声明只能在它们声明的块内访问。 2、const 不能更新或重新声明 这意味着用 const 声明的变量的值在其作用域内保持不变。它不能被更新或重新声明。 3、const 的提升 就像 let 一样，const 声明被提升到顶部但没有被初始化。 区别 var 声明是全局作用域或函数作用域，而 let 和 const 是块作用域。 var 变量可以在其作用域内更新和重新声明；let 变量可以更新但不能重新声明；const 变量既不能更新也不能重新声明。 它们都被提升到了作用域的顶部。但是，var 变量是用 undefined 初始化的，而 let 和 const 变量不会被初始化。 var 和 let 可以在不初始化的情况下声明，而 const 必须在声明时初始化。 类型转换 理解弱类型语言的特征，掌握显式类型转换的方法 在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。 隐式转换某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 +号两边只要有一个是字符串，都会把另外一个转成字符串 除了+以外的算术运算符，比如 - * &#x2F; 等都会把数据转成数字类型。 +号作为正号解析可以转换成数字型 任何数据和字符串相加结果都是字符串 有字符串的加法“”+1，结果是“1” 减法-（像大多数数学运算一样）只能用于数字，它会使空字符串””转换为0 null经过数字转换之后会变为0 undefined经过数字转换之后会变为NaN 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript 基础 - 隐式转换&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let num = 13 // 数值 let num2 = &#x27;2&#x27; // 字符串 // 结果为 132 // 原因是将数值 num 转换成了字符串，相当于 &#x27;13&#x27; // 然后 + 将两个字符串拼接到了一起 console.log(num + num2) // 结果为 11 // 原因是将字符串 num2 转换成了数值，相当于 2 // 然后数值 13 减去 数值 2 console.log(num - num2) let a = prompt(&#x27;请输入一个数字&#x27;) let b = prompt(&#x27;请再输入一个数字&#x27;) alert(a + b); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换。 补充介绍模板字符串的拼接的使用 显式转换编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 转为Number1、通过 Number 显示转换成数值类型，当转换失败时结果为 NaN（Not a Number）即不是一个数字。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript 基础 - 隐式转换&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let t = &#x27;12&#x27; let f = 8 // 显式将字符串 12 转换成数值 12 t = Number(t) // 检测转换后的类型 // console.log(typeof t); console.log(t + f) // 结果为 20 // 并不是所有的值都可以被转成数值类型 let str = &#x27;hello&#x27; // 将 hello 转成数值是不现实的，当无法转换成 // 数值时，得到的结果为 NaN （Not a Number） console.log(Number(str)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果字符串内容里有非数字，转换失败时结果为 NaN（Not a Number）即不是一个数字 NaN也是number类型的数据，代表非数字 特殊转换： Number转换 结果 Number({}) NaN Number([]) 0 Number(‘’) 0 Number(null) 0 Number(undefined) undefined Number(NaN) NAN Number(false) 0 Number(true) 1 2、parseInt(数据) 只保留整数。 3、parseFloat(数据) 可以保留小数。 转换为字符型1String(数据) 1变量.toString(进制) 转换为Boolean值‘’、0、undefined、null、false、NaN转换为布尔值后都是false,其余则为true Null和Undefined123456789101112131415161718&lt;body&gt; &lt;script&gt; // 1. true false 是布尔型字面量 // console.log(3 &gt; 4) // let isCool = false // console.log(isCool) // 2. 未定义类型 弱数据类型 声明一个变量未赋值就是 undefined // let num // console.log(num) // 3. null 空的 // let obj = null // console.log(obj) // 计算有区别 console.log(undefined + 1) // NaN console.log(null + 1) // 1 &lt;/script&gt;&lt;/body&gt; null 和 undefined 区别：undefined 表示没有赋值null 表示赋值了，但是内容为空 null 开发中的使用场景：官方解释：把 null 作为尚未创建的对象大白话： 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"样式表优先级","path":"/2024/01/15/样式表优先级/","content":"优先级规则：行内样式 &gt; 内部样式 &#x3D; 外部样式 遵循后来者居上原则。CSS写在后面的起作用。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"H5新增内容","path":"/2024/01/15/H5/","content":"1、语义化标签1.1 布局标签 关于 article 和 section ： artical 里面可以有多个 section 。 section 强调的是分段或分块，如果你想将一块内容分成几段的时候，可使用 section 元素。 article 比 section 更强调独立性，一块内容如果比较独立、比较完整，应该使用article 元素。 1.2 状态标签1、meter标签 语义：定义已知范围内的标量测量。也被称为 gauge （尺度），双标签，例如：电量、磁盘用量 等。 常用属性： 2、progeress标签 语义：显示某个任务完成的进度的指示器，一般用于表示进度条，双标签，例如：工作完成进度 等。 1.3列表标签 1.4新增文本标签1、文本注音 1234&lt;ruby&gt;&lt;span&gt;魑魅魍魉&lt;/span&gt;&lt;rt&gt;chī mèi wǎng liǎng &lt;/rt&gt;&lt;/ruby&gt; 2、文本标记 2、新增表单功能2.1表单控件新增属性 2.2 input新增属性值 2.3 form新增属性 3 多媒体标签3.1 视频标签&lt;video&gt; 标签用来定义视频，它是双标签。 3.2 音频标签 4.新增全局属性 5. 兼容性处理添加元信息，让浏览器处于最优渲染模式。 1234&lt;!--设置IE总是使用最新的文档模式进行渲染--&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;!--优先使用 webkit ( Chromium ) 内核进行渲染, 针对360等壳浏览器--&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 使用 html5shiv 让低版本浏览器认识 的语义化标签。 123&lt;!--[if lt ie 9]&gt;&lt;script src=&quot;../sources/js/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 扩展 lt 小于 lte 小于等于 gt 大于 gte 大于等于 ! 逻辑非 示例： 123456&lt;!--[if IE 8]&gt;仅IE8可见&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;仅IE8以上可见&lt;![endif]—&gt;&lt;!--[if lt IE 8]&gt;仅IE8以下可见&lt;![endif]—&gt;&lt;!--[if gte IE 8]&gt;IE8及以上可见&lt;![endif]—&gt;&lt;!--[if lte IE 8]&gt;IE8及以下可见&lt;![endif]—&gt;&lt;!--[if !IE 8]&gt;非IE8的IE可见&lt;![endif]--&gt;","tags":["前端","html"],"categories":["html"]},{"title":"补充标签","path":"/2024/01/15/补充标签/","content":"&lt; br&gt;换行 &lt; pre&gt;按原文显示 &lt; hr&gt;分割 隐藏域： &lt;input type&#x3D;”hidden” name&#x3D;”tag” value&#x3D;”100” &gt; 用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据。 name 属性：指定数据的名称。 value 属性：指定的是真正提交的数据。 &lt;label&gt;: label 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点。 两种与 label 关联方式如下： 让 label 标签的 for 属性的值等于表单控件的 id 。 把表单控件套在 label 标签的里面。 &lt;iframe&gt;嵌入内容","tags":["前端","html"],"categories":["html"]},{"title":"字符实体","path":"/2024/01/15/字符实体/","content":"空格的字符实体&amp;nbsp; &amp;#160 标签&lt;&gt;的字符实体&amp;lt; h1 &amp;gt; &amp;的字符实体&amp;amp;&#x20; 人民币的字符实体&amp;yen; 版权的字符实体&amp;copy; 乘号的字符实体&amp;times; 除号的字符实体&amp;divide;","tags":["前端","html"],"categories":["html"]},{"title":"表格","path":"/2024/01/15/表格/","content":"结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;table border=&quot;1&quot;&gt;&lt;!-- 表格标题 --&gt;&lt;caption&gt;学生信息&lt;/caption&gt;&lt;!-- 表格头部 --&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;民族&lt;/th&gt;&lt;th&gt;政治面貌&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;2. 常用属性&lt;!-- 表格主体 --&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;汉族&lt;/td&gt;&lt;td&gt;团员&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;满族&lt;/td&gt;&lt;td&gt;群众&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;王五&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;回族&lt;/td&gt;&lt;td&gt;党员&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;赵六&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;td&gt;壮族&lt;/td&gt;&lt;td&gt;团员&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;!-- 表格脚注 --&gt;&lt;tfoot&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;共计：4人&lt;/td&gt;&lt;/tr&gt;&lt;/tfoot&gt;&lt;/table&gt; 属性 一般table的属性height意义为最小高度。table会通过自动调整tbody来让整个table高度达到最小高度。","tags":["前端","html"],"categories":["html"]},{"title":"块级元素、行内元素、行内块元素","path":"/2024/01/15/块级元素、行内元素、行内块元素/","content":"块级元素blockquote、address 独占一行。 行内元素文本标签（&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;a&gt;等） 不独占一行 规则1：块级元素中能写行内元素、块级元素。 规则2：行内元素中能写行内元素，不能写块级元素 特殊规则: H1-H6不能嵌套 特殊规则：p标签中不能写块元素 特殊规则：a标签内可以包含除自身之外的任何元素 行内块元素IMG","tags":["前端","html"],"categories":["html"]},{"title":"函数式组件","path":"/2023/06/28/函数式组件/","content":"12345678910111213141516171819&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;test&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../react.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../react-dom.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../babel.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;function demo()&#123;console.log(this);//此处的this是undefined，因为babel编译后开启了严格模式return &lt;h2&gt;我是用函数定义的组件&lt;/h2&gt;&#125; &lt;/script&gt;&lt;/html&gt;","tags":["前端","react","组件"],"categories":["react"]},{"title":"jsx基础知识","path":"/2023/06/18/jsx/","content":"jsx语法JSX是类似于XML的js扩展语法，其本质是React.createElement(component,props,…children)方法的语法糖 注：XML早期用于存储和传输数据。 XML格式如下： 1234&lt;student&gt;&lt;name&gt;Tom&lt;/name&gt;&lt;age&gt;19&lt;/age&gt;&lt;/student&gt; JSON格式如下： 1&quot;&#123;&quot;name&quot;：&quot;Tom&quot;,&quot;age&quot;:19&#125;&quot; jsx语法规则1、定义虚拟DOM时，不要写引号。 12345const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&quot;test&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 2、标签里如果要用JS的表达式，要用{}。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&#123;myID.toLowerCase()&#125;&gt; &lt;span&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 3、写样式时指定类名不用class，用className。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 className=&quot;title&quot; id=&#123;myID.toLowerCase()&#125;&gt; &lt;span&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 12345&lt;style&gt;.title&#123;background:red;&#125;&lt;/style&gt; 4、写内联样式时用style&#x3D;\"{{kay:value}}\"的样式。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 className=&quot;title&quot; id=&#123;myID.toLowerCase()&#125;&gt; &lt;span style=&#123;&#123;color:&#x27;white&#x27;,fontSize:&#x27;29px&#x27;&#125;&#125;&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 5、虚拟DOM必须只有一个根标签。 6、标签必须闭合。 7、标签首字母 1）若小写字母开头，则将标签转为html中同名元素，若html中不存在同名元素，则报错。 2）若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。 注：区分js语句和js表达式 1、表达式：会产生一个值，可以放在任何一个需要值的地方。如a、a+b、demo(1)、arr.map()、function test（）{} 2、语句（代码）： 比如if(){}、for(){}、switch（）{case: ….}","tags":["前端","react","jsx"],"categories":["react"]},{"title":"虚拟DOM创建","path":"/2023/06/18/虚拟DOM创建/","content":"1.用jsx创建虚拟DOM1234const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&quot;title&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;)ReactDOM.render(VDOM,document.querySelector(&#x27;.test&#x27;)) 2.用js创建虚拟DOM1234//1.创建虚拟DOM,创建嵌套格式的domconst VDOM=React.createElement(&#x27;h1&#x27;,&#123;id:&#x27;title&#x27;&#125;,React.createElement(&#x27;span&#x27;,&#123;&#125;,&#x27;hello,React&#x27;))//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.querySelector(&#x27;.test&#x27;)). 3.虚拟DOM与真实DOM的区别1、虚拟DOM本质上就是Object类型的对象 2、虚拟DOM较为轻量级，真实DOM较为重量级，因为虚拟DOM运用于React内部，无需真实DOM上的过多属性。 3、虚拟DOM最终会被React转化为真实DOM。","tags":["前端","react"],"categories":["react"]},{"title":"类式组件","path":"/2023/06/18/类式组件/","content":"类123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt;class Person&#123;constructor(name,age)&#123;//构造器方法//构造器中的this是类的实例对象this.name=namethis.age=age&#125;//一般方法speak()&#123;//speak方法放在了类的原型对象上，供实例使用console.log(`我叫$(this.name),我的年龄是$(this.age)`)&#125;&#125;class Student extends Person&#123; constructor(name,age,grade)&#123; super(name,age) this.grade=grade; &#125; speak()&#123; console.log(`我叫$&#123;this.name&#125;,我的年龄是$&#123;this.age&#125;,我的年纪是$&#123;this.grade&#125;`) &#125;&#125;const p1=new Person(&#x27;tom&#x27;,18)const p2=new Person(&#x27;jerry&#x27;,19)const s1=new Student(&#x27;zhang&#x27;,15,&#x27;高一&#x27;)p1.speak()p2.speak()s1.speak()&lt;/script&gt; 注： 1、类的构造器不是一定要写的 2、如果a类继承于b类，且a类中写了构造器，则a类构造器中super必须要调用。 3、类定义的方法，都放在类的原型对象上，共实例使用 创建类组件12345678910111213&lt;script type=&quot;text/babel&quot;&gt;class MyComponent extends React.Component&#123;//这里Component的c要大写//render是放在MyComponent原型对象上，供实例使用的render()&#123;return&#123;//render中的this是MyComponent的实例对象&lt;h2&gt;我是类定义的组件&lt;/h2&gt;&#125;&#125;&#125;ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))&lt;/script&gt; 执行ReactDOM.render（&lt;MyComponent&#x2F;&gt;）之后。发生了什么？ 1、react解析组件标签，找到MyComponent组件 2、发现组件是使用类定义的，随后new出该类的实例，并通过该实例调用到原型上的render方法 3、将render返回的虚拟dom转为真实dom，随后呈现在页面中。","tags":["前端","react","组件"],"categories":["react"]},{"title":"Hello","path":"/2023/04/15/testlx/","content":"Do not go gentle into that good night.","tags":["随笔"],"categories":["随笔"]}]