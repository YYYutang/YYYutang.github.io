[{"title":"宏任务与微任务","path":"/2024/03/08/宏任务与微任务/","content":"JS执行机制同步任务同步任务都在主线程上执行，形成一个执行栈。 异步任务JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型: 1、普通事件，如 click、resize 等 2、资源加载，如 load、error 等 3、定时器，包括 setInterval、setTimeout 等 异步任务相关添加到任务队列中（任务队列也称为消息队列）。 事件循环 先执行执行栈中的同步任务。 异步任务放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 宏任务与微任务异步任务划分为了 宏任务：由浏览器环境执行的异步代码 微任务：由 JS 引擎环境执行的异步代码 宏任务和微任务具体划分： 事件循环模型 1234567891011121314/** * 阅读并回答打印的执行顺序*/console.log(1)setTimeout(() =&gt; &#123; console.log(2)&#125;, 0)const p = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)p.then(res =&gt; &#123; console.log(res)&#125;)console.log(4) 注意：宏任务每次在执行同步代码时，产生微任务队列，清空微任务队列任务后，微任务队列空间释放！ 下一次宏任务执行时，遇到微任务代码，才会再次申请微任务队列空间放入回调函数消息排队 总结：一个宏任务包含微任务队列，他们之间是包含关系，不是并列关系 经典题目 1234567891011121314151617// 目标：回答代码执行顺序console.log(1)setTimeout(() =&gt; &#123; console.log(2) const p = new Promise(resolve =&gt; resolve(3)) p.then(result =&gt; console.log(result))&#125;, 0)const p = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(4) &#125;, 0) resolve(5)&#125;)p.then(result =&gt; console.log(result))const p2 = new Promise(resolve =&gt; resolve(6))p2.then(result =&gt; console.log(result))console.log(7) 结果：1 7 5 6 2 3 4 执行顺序： console.log(1) setTimeout()作为宏任务推入到宏任务队列中排队 const p &#x3D; new Promise放到调用栈执行，遇到里面的setTimeout（）放入宏任务队列中排队 p.then（）当promise为成功状态时作为微任务推入到微任务中排队 const p2 &#x3D; new Promise 成功 p2.then立刻作为微任务推入到微任务中排队 console.log(7) 从微任务队列中调度p.then(result &#x3D;&gt; console.log(result))，打印5&#x20; 从微任务队列中调度p2.then(result &#x3D;&gt; console.log(result))，打印6 从宏任务队列中调度setTimeout（），打印2，const p &#x3D; new Promise(resolve &#x3D;&gt;resolve(3))为成功状态，p.then(result &#x3D;&gt; console.log(result))立刻被推入到微任务队列中排队 从微任务队列中调度p.then(result &#x3D;&gt; console.log(result))，打印3 从宏任务队列中调度setTimeout(() &#x3D;&gt; {&#x20; console.log(4)&#x20; }, 0)，打印4","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"回调地狱及其解决方法","path":"/2024/03/07/回调地狱及其解决方法/","content":"同步与异步的概念 同步代码：逐行执行，需原地等待结果后，才继续向下执行 异步代码：调用后耗时，不阻塞代码继续执行（不必原地等待），在将来完成后触发回调函数传递结果 回答代码打印顺序：发现异步代码接收结果，使用的都是回调函数 12345678910const result = 0 + 1console.log(result)setTimeout(() =&gt; &#123; console.log(2)&#125;, 2000)document.querySelector(&#x27;.btn&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(3)&#125;)document.body.style.backgroundColor = &#x27;pink&#x27;console.log(4) 结果：1， 4， 2 按钮点击一次打印一次 3 回调地狱概念 需求：展示默认第一个省，第一个城市，第一个地区在下拉菜单中 概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调函数地狱 缺点：可读性差，异常无法捕获，耦合性严重，牵一发动全身 12345678910111213axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27; &#125;).then(result =&gt; &#123; const pname = result.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname // 获取第一个省份默认下属的第一个城市名字 axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125; &#125;).then(result =&gt; &#123; const cname = result.data.list[0] document.querySelector(&#x27;.city&#x27;).innerHTML = cname // 获取第一个城市默认下属第一个地区名字 axios(&#123; url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125; &#125;).then(result =&gt; &#123; document.querySelector(&#x27;.area&#x27;).innerHTML = result.data.list[0] &#125;) &#125;)&#125;) Promise链式调用 概念：依靠 then() 方法会返回一个新生成的 Promise 对象特性，继续串联下一环任务，直到结束 细节：then() 回调函数中的返回值，会影响新生成的 Promise 对象最终状态和结果 好处：通过链式调用，解决回调函数嵌套问题 1234567891011121314151617181920212223242526272829/** * 需求：把省市的嵌套结构，改成链式调用的线性结构*/// 1. 创建Promise对象-模拟请求省份名字const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;北京市&#x27;) &#125;, 2000)&#125;)// 2. 获取省份名字const p2 = p.then(result =&gt; &#123; console.log(result) // 3. 创建Promise对象-模拟请求城市名字 // return Promise对象最终状态和结果，影响到新的Promise对象 return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(result + &#x27;--- 北京&#x27;) &#125;, 2000) &#125;)&#125;)// 4. 获取城市名字p2.then(result =&gt; &#123; console.log(result)&#125;)// then()原地的结果是一个新的Promise对象console.log(p2 === p)//false 使用promise解决回调地狱 目标：使用 Promise 链式调用，解决回调函数地狱问题 做法：每个 Promise 对象中管理一个异步任务，用 then 返回 Promise 对象，串联起来 123456789101112131415161718192021/** * 目标：把回调函数嵌套代码，改成Promise链式调用结构 * 需求：获取默认第一个省，第一个市，第一个地区并展示在下拉菜单中*/let pname = &#x27;&#x27;// 1. 得到-获取省份Promise对象axios(&#123;url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(result =&gt; &#123; pname = result.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname // 2. 得到-获取城市Promise对象 return axios(&#123;url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;)&#125;).then(result =&gt; &#123; const cname = result.data.list[0] document.querySelector(&#x27;.city&#x27;).innerHTML = cname // 3. 得到-获取地区Promise对象 return axios(&#123;url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125;&#125;)&#125;).then(result =&gt; &#123; console.log(result) const areaName = result.data.list[0] document.querySelector(&#x27;.area&#x27;).innerHTML = areaName&#125;) 事实上，promise是callback风格的一个语法糖，它通过实现链式调用的方式来将回调函数的嵌套扁平化来达到解决回调地狱的目的。 往回调函数里按照成功和失败的类别分别传入两个回调函数，就可以分别处理成功和失败的结果。 12345678910111213function foo(handleSucceed, handleFailed) &#123; if(isMistake) &#123; return handleFailed(new Error(&#x27;It`s a mistake&#x27;)); &#125; else &#123; return handleSucceed(&#x27;You got it!&#x27;); &#125;&#125;foo(function (result) &#123; console.log(result);&#125;, function (error) &#123; console.error(error);&#125;); 与promise实现的版本进行对比： 1234567891011121314const pms = new Promise((resolve, reject) =&gt; &#123; // do sth. if(isMistake) &#123; return reject(new Error(&#x27;It`s a mistake&#x27;)); &#125; else &#123; return resolve(&#x27;You got it!&#x27;); &#125;&#125;);pms.then(result =&gt; &#123; console.log(result);&#125;).catch(error =&gt; &#123; console.error(error);&#125;); 会发现实质上，这里的resolve和reject正是两个回调函数，就如同前面一个例子里面的handleSucceed和handleFailed一样。而这两个回调函数的传入方式，从上一个例子的直接两个参数传入，变成了通过then方法和catch方法来进行传入。 相比而言，Promise的方式更加语义化，更容易理解——给主流程留下一个承诺，在之后可以通过该承诺获得子流程的执行结果。 async和await函数解决回调地狱 概念：在 async 函数内，使用 await 关键字取代 then 函数，等待获取 Promise 对象成功状态的结果值。 async关键字作为一个关键字放到申明函数前面，表示该函数为要给异步任务，不会阻塞后面函数的执行。async函数其实是一个返回值为Promise对象的函数。或者更准确地说：async关键字声明的函数被调用时，实质上是创建了一个Promise对象。 await则表示：执行后面的表达式——不论是异步还是同步的表达式——并获取到resolve的结果，如果执行出错，则抛出到外层async函数的catch回调中。await同时作为Promise中的resolve和reject工作了。 做法：使用 async 和 await 解决回调地狱问题 12345678910111213141516171819202122/** * 目标：掌握async和await语法，解决回调函数地狱 * 概念：在async函数内，使用await关键字，获取Promise对象&quot;成功状态&quot;结果值 * 注意：await必须用在async修饰的函数内（await会阻止&quot;异步函数内&quot;代码继续执行，原地等待结果）*/// 1. 定义async修饰函数async function getData() &#123; // 2. await等待Promise对象成功的结果 const pObj = await axios(&#123;url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;) const pname = pObj.data.list[0] const cObj = await axios(&#123;url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;) const cname = cObj.data.list[0] const aObj = await axios(&#123;url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125;&#125;) const areaName = aObj.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname document.querySelector(&#x27;.city&#x27;).innerHTML = cname document.querySelector(&#x27;.area&#x27;).innerHTML = areaName&#125;getData() async 函数和 await 捕获错误try 和 catch 的作用：语句标记要尝试的语句块，并指定一个出现异常时抛出的响应 1234567try &#123; // 要执行的代码&#125; catch (error) &#123; // error 接收的是，错误消息 // try 里代码，如果有错误，直接进入这里执行&#125; 尝试把代码中 url 地址写错，观察 try catch 的捕获错误信息能力 123456789101112131415161718192021222324/** * 目标：async和await_错误捕获*/async function getData() &#123; // 1. try包裹可能产生错误的代码 try &#123; const pObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27; &#125;) const pname = pObj.data.list[0] const cObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125; &#125;) const cname = cObj.data.list[0] const aObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125; &#125;) const areaName = aObj.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname document.querySelector(&#x27;.city&#x27;).innerHTML = cname document.querySelector(&#x27;.area&#x27;).innerHTML = areaName &#125; catch (error) &#123; // 2. 接着调用catch块，接收错误信息 // 如果try里某行代码报错后，try中剩余的代码不会执行了 console.dir(error) &#125;&#125;getData() async函数其实是Promise的语法糖。并且它通过形似同步编程的形式，达成了前述Promise的链式调用，并以此解决回调地狱的问题。","tags":["前端","Ajax"],"categories":["Ajax"]},{"title":"XMLHttpRequest","path":"/2024/03/07/XMLHttpRequest/","content":"基本使用1234567const xhr = new XMLHttpRequest()xhr.open(&#x27;请求方法&#x27;, &#x27;请求url网址&#x27;)xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; // 响应结果 console.log(xhr.response)&#125;)xhr.send() 以一个需求来体验下原生 XHR 语法，需求为获取所有省份列表并展示到页面上 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;XMLHttpRequest_基础使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;my-p&quot;&gt;&lt;/p&gt; &lt;script&gt; /** * 目标：使用XMLHttpRequest对象与服务器通信 * 1. 创建 XMLHttpRequest 对象 * 2. 配置请求方法和请求 url 地址 * 3. 监听 loadend 事件，接收响应结果 * 4. 发起请求 */ // 1. 创建 XMLHttpRequest 对象 const xhr = new XMLHttpRequest() // 2. 配置请求方法和请求 url 地址 xhr.open(&#x27;GET&#x27;, &#x27;http://hmajax.itheima.net/api/province&#x27;) // 3. 监听 loadend 事件，接收响应结果 xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; console.log(xhr.response) const data = JSON.parse(xhr.response) console.log(data.list.join(&#x27;&lt;br&gt;&#x27;)) document.querySelector(&#x27;.my-p&#x27;).innerHTML = data.list.join(&#x27;&lt;br&gt;&#x27;) &#125;) // 4. 发起请求 xhr.send() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 查询参数原生 XHR 需要自己在 url 后面携带查询参数字符串，没有 axios 帮助我们把 params 参数拼接到 url 字符串后面， 123456789101112/** * 目标：使用XHR携带查询参数，展示某个省下属的城市列表*/const xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;http://hmajax.itheima.net/api/city?pname=辽宁省&#x27;)xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; console.log(xhr.response) const data = JSON.parse(xhr.response) console.log(data) document.querySelector(&#x27;.city-p&#x27;).innerHTML = data.list.join(&#x27;&lt;br&gt;&#x27;)&#125;)xhr.send() 多个查询参数，如果自己拼接很麻烦，这里用 URLSearchParams 把参数对象转成“参数名&#x3D;值&amp;参数名&#x3D;值“格式的字符串，语法如下： 123456789// 1. 创建 URLSearchParams 对象const paramsObj = new URLSearchParams(&#123; 参数名1: 值1, 参数名2: 值2&#125;)// 2. 生成指定格式查询参数字符串const queryString = paramsObj.toString()// 结果：参数名1=值1&amp;参数名2=值2 提交数据1、需要自己设置请求头 Content-Type：application&#x2F;json，来告诉服务器端，我们发过去的内容类型是 JSON 字符串，让他转成对应数据结构取值使用 2、前端要传递的请求体数据，需要我们自己把 JS 对象转成 JSON 字符串。 3、原生 XHR 需要在 send 方法调用时，传入请求体携带 12345678910111213const xhr = new XMLHttpRequest()xhr.open(&#x27;请求方法&#x27;, &#x27;请求url网址&#x27;)xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; console.log(xhr.response)&#125;)// 1. 告诉服务器，我传递的内容类型，是 JSON 字符串xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)// 2. 准备数据并转成 JSON 字符串const user = &#123; username: &#x27;itheima007&#x27;, password: &#x27;7654321&#x27; &#125;const userStr = JSON.stringify(user)// 3. 发送请求体数据xhr.send(userStr)","tags":["前端","Ajax"],"categories":["Ajax"]},{"title":"模拟封装Axios","path":"/2024/03/07/模拟封装axios/","content":"简易版 需求：基于 Promise 和 XHR 封装 myAxios 函数，获取省份列表展示到页面 核心语法： 1234567891011121314function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; // XHR 请求 // 调用成功/失败的处理程序 &#125;)&#125;myAxios(&#123; url: &#x27;目标资源地址&#x27;&#125;).then(result =&gt; &#123; &#125;).catch(error =&gt; &#123; &#125;) 步骤： 定义 myAxios 函数，接收配置对象，返回 Promise 对象 发起 XHR 请求，默认请求方法为 GET 调用成功&#x2F;失败的处理程序 使用 myAxios 函数，获取省份列表展示 核心代码 1234567891011121314151617181920212223242526272829303132333435/** * 目标：封装_简易axios函数_获取省份列表 * 1. 定义myAxios函数，接收配置对象，返回Promise对象 * 2. 发起XHR请求，默认请求方法为GET * 3. 调用成功/失败的处理程序 * 4. 使用myAxios函数，获取省份列表展示*/// 1. 定义myAxios函数，接收配置对象，返回Promise对象function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; // 2. 发起XHR请求，默认请求方法为GET const xhr = new XMLHttpRequest() xhr.open(config.method || &#x27;GET&#x27;, config.url) xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; // 3. 调用成功/失败的处理程序 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(JSON.parse(xhr.response)) &#125; else &#123; reject(new Error(xhr.response)) &#125; &#125;) xhr.send() &#125;)&#125;// 4. 使用myAxios函数，获取省份列表展示myAxios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(result =&gt; &#123; console.log(result) document.querySelector(&#x27;.my-p&#x27;).innerHTML = result.list.join(&#x27;&lt;br&gt;&#x27;)&#125;).catch(error =&gt; &#123; console.log(error) document.querySelector(&#x27;.my-p&#x27;).innerHTML = error.message&#125;) 携带参数版修改步骤： myAxios 函数调用后，判断 params 选项 基于 URLSearchParams 转换查询参数字符串 使用自己封装的 myAxios 函数显示地区列表 1234567891011121314151617181920212223242526272829303132333435function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() // 1. 判断有params选项，携带查询参数 if (config.params) &#123; // 2. 使用URLSearchParams转换，并携带到url上 const paramsObj = new URLSearchParams(config.params) const queryString = paramsObj.toString() // 把查询参数字符串，拼接在url？后面 config.url += `?$&#123;queryString&#125;` &#125; xhr.open(config.method || &#x27;GET&#x27;, config.url) xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(JSON.parse(xhr.response)) &#125; else &#123; reject(new Error(xhr.response)) &#125; &#125;) xhr.send() &#125;)&#125;// 3. 使用myAxios函数，获取地区列表myAxios(&#123; url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname: &#x27;辽宁省&#x27;, cname: &#x27;大连市&#x27; &#125;&#125;).then(result =&gt; &#123; console.log(result) document.querySelector(&#x27;.my-p&#x27;).innerHTML = result.list.join(&#x27;&lt;br&gt;&#x27;)&#125;) 请求体携带数据版修改步骤： myAxios 函数调用后，判断 data 选项 转换数据类型，在 send 方法中发送 使用自己封装的 myAxios 函数完成注册用户功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() if (config.params) &#123; const paramsObj = new URLSearchParams(config.params) const queryString = paramsObj.toString() config.url += `?$&#123;queryString&#125;` &#125; xhr.open(config.method || &#x27;GET&#x27;, config.url) xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(JSON.parse(xhr.response)) &#125; else &#123; reject(new Error(xhr.response)) &#125; &#125;) // 1. 判断有data选项，携带请求体 if (config.data) &#123; // 2. 转换数据类型，在send中发送 const jsonStr = JSON.stringify(config.data) xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;) xhr.send(jsonStr) &#125; else &#123; // 如果没有请求体数据，正常的发起请求 xhr.send() &#125; &#125;)&#125;document.querySelector(&#x27;.reg-btn&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 3. 使用myAxios函数，完成注册用户 myAxios(&#123; url: &#x27;http://hmajax.itheima.net/api/register&#x27;, method: &#x27;POST&#x27;, data: &#123; username: &#x27;itheima999&#x27;, password: &#x27;666666&#x27; &#125; &#125;).then(result =&gt; &#123; console.log(result) &#125;).catch(error =&gt; &#123; console.dir(error) &#125;)&#125;)","tags":["前端","Ajax","Axios"],"categories":["Axios"]},{"title":"防抖与节流","path":"/2024/03/05/防抖与节流/防抖与节流/","content":"防抖（debounce）所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 使用场景 搜索框搜索输入，需要等到用户最后一次输入完再发送请求 手机号、邮箱验证输入检测 实现底层简单的实现： 需求：当鼠标在box里滑动时，box里的数字就加一。但如果鼠标每移动1px就加1，数字变化会非常频繁，非常浪费性能。 123456const box=doucment.querySelector(&#x27;.box&#x27;)let i=1function mouseMove()&#123; box.innerHTML=i++&#125;box.addEventListener(&#x27;mousemove&#x27;,mouseMove) lodash库1_.debounce(func, [wait=0], [options=&#123;&#125;]) 使用说明： 创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。&#x20; debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。&#x20; 后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果。 1234567891011121314151617&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; // box.addEventListener(&#x27;mousemove&#x27;, mouseMove) // lodash 节流写法 // box.addEventListener(&#x27;mousemove&#x27;, _.throttle(mouseMove, 500)) // lodash 防抖的写法 box.addEventListener(&#x27;mousemove&#x27;, _.debounce(mouseMove, 500)) &lt;/script&gt; 手动实现核心思想是使用定时器（setTimeout）来实现。 1．声明定时器变量 2．每次鼠标移动(事件触发）的时候都要先判断是否有定时器，如果有先清除以前的定时器 3．如果没有定时器，则开启定时器，存入到定时器变量里面 4．定时器里面写函数调用 1234567891011121314151617181920212223242526&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; // 防抖函数 function debounce(fn, t) &#123; let timeId return function () &#123; // 如果有定时器就清除 let context = this; // 保存this指向 let args = arguments; // 拿到event对象 if (timeId) clearTimeout(timeId) // 开启定时器 200 timeId = setTimeout(function () &#123; func.apply(context, args) &#125;, t) &#125; &#125; // box.addEventListener(&#x27;mousemove&#x27;, mouseMove) box.addEventListener(&#x27;mousemove&#x27;, debounce(mouseMove, 200))&lt;/script&gt; 节流（throttle）所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 使用场景鼠标移动mousemove、页面尺寸缩放resize、滚动条滚动scroll等等 实现底层简单的实现： 需求：当鼠标在box里滑动时，不管移动多少次，box里的数字每隔500ms才加一。 lodash库1_.throttle(func, [wait=0], [options=]) 创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。&#x20; 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。&#x20; 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。&#x20; func 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 func 调用的结果。 12345678910&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; box.addEventListener(&#x27;mousemove&#x27;, _.throttle(mouseMove, 500)) &lt;/script&gt; 手动实现 声明一个定时器变量 当鼠标每次滑动，都先判断是否有定时器了，如果有定时器则不开启新定时器 如果没有定时器则开启定时器，记得存到变量里面-定时器里面调用执行的函数-定时器里面要把定时器清空 12345678910111213141516171819202122232425&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; // 防抖函数 function throttle(fn, t) &#123; let timeId return function () &#123; // 如果有定时器就清除 if (!timeId) // 开启定时器 200 timeId = setTimeout(function () &#123; fn() timeId=null; &#125;, t) &#125; &#125; // box.addEventListener(&#x27;mousemove&#x27;, mouseMove) box.addEventListener(&#x27;mousemove&#x27;, throttle(mouseMove, 500))&lt;/script&gt; 注意：这里清空定时器不能使用clearTimeout，而是将timeId设置为null。因为在setTimeoput中是无法清楚定时器的。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"this指向问题","path":"/2024/03/05/this指向/","content":"this 是 JavaScript 最容易迷糊的知识点，不同的应用场合 this 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 this 默认的取值】情况进行归纳和总结。 普通函数普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】，如下代码所示： 12345678910111213141516171819202122232425262728&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this) &#125; // 函数表达式 const sayHello = function () &#123; console.log(this) &#125; // 函数的调用方式决定了 this 的值 sayHi() // window window.sayHi() // 普通对象 const user = &#123; name: &#x27;小明&#x27;, walk: function () &#123; console.log(this) &#125; &#125; // 动态为 user 添加方法 user.sayHi = sayHi uesr.sayHello = sayHello // 函数调用方式，决定了 this 的值 user.sayHi() user.sayHello()&lt;/script&gt; 注： 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined。 箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！箭头函数中访问的 this 不过是箭头函数所在作用域的 this 变量。 12345678910111213141516171819202122232425262728293031&lt;script&gt; console.log(this) // 此处为 window // 箭头函数 const sayHi = function() &#123; console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致 &#125; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, // 该箭头函数中的 this 为函数声明环境中 this 一致 walk: () =&gt; &#123; console.log(this) &#125;, sleep: function () &#123; let str = &#x27;hello&#x27; console.log(this) let fn = () =&gt; &#123; console.log(str) console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致 &#125; // 调用箭头函数 fn(); &#125; &#125; // 动态添加方法 user.sayHi = sayHi // 函数调用 user.sayHi() user.sleep() user.walk()&lt;/script&gt; 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示： 123456789101112&lt;script&gt; // DOM 节点 const btn = document.querySelector(&#x27;.btn&#x27;) // 箭头函数 此时 this 指向了 window btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(this) &#125;) // 普通函数 此时 this 指向了 DOM 对象 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(this) &#125;)&lt;/script&gt; 同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数，如下代码所示： 1234567891011&lt;script&gt; function Person() &#123; &#125; // 原型对像上添加了箭头函数 Person.prototype.walk = () =&gt; &#123; console.log(&#x27;人都要走路...&#x27;) console.log(this); // window &#125; const p1 = new Person() p1.walk()&lt;/script&gt; 改变this指向以上归纳了普通函数和箭头函数中关于 this 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向： call使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 12345678910111213141516171819202122232425&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this); &#125; let user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; let student = &#123; name: &#x27;小红&#x27;, age: 16 &#125; // 调用函数并指定 this 的值 sayHi.call(user); // this 值为 user sayHi.call(student); // this 值为 student // 求和函数 function counter(x, y) &#123; return x + y; &#125; // 调用 counter 函数，并传入参数 let result = counter.call(null, 5, 10); console.log(result);&lt;/script&gt; apply使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 12345678910111213141516171819202122232425262728&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this) &#125; let user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; let student = &#123; name: &#x27;小红&#x27;, age: 16 &#125; // 调用函数并指定 this 的值 sayHi.apply(user) // this 值为 user sayHi.apply(student) // this 值为 student // 求和函数 function counter(x, y) &#123; return x + y &#125; // 调用 counter 函数，并传入参数 let result = counter.apply(null, [5, 10]) console.log(result)&lt;/script&gt; 总结： apply 方法能够在调用函数的同时指定 this 的值 使用 apply 方法调用函数时，第1个参数为 this 指定的值 apply 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数 bindbind 方法并不会调用函数，而是创建一个指定了 this 值的新函数，使用方法如下代码所示： 1234567891011121314&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this) &#125; let user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; // 调用 bind 指定 this 的值 let sayHello = sayHi.bind(user); // 调用使用 bind 创建的新函数 sayHello()&lt;/script&gt; 注：bind 方法创建新的函数，与原函数的唯一的变化是改变了 this 的值，使用场景是修改定时器内this的指向。 比如，点击一个按钮这个按钮就禁用，2s后重新开启。 123456789const fun =fn.bind(obj)fun()const btn = document.querySelector(&#x27;button&#x27;)btn.addEventListener(&#x27;click&#x27;,function()&#123; this.disabled=true; window.setTimeout(function()&#123; this.disabled=false //如果不改变，this指向的是window，可以改完箭头函数或者使用bind函数 &#125;.bind(btn),2000)&#125;)","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Promise","path":"/2024/03/03/Promise/","content":"概述 什么是 Promise ？ Promise 对象用于表示一个异步操作的最终完成（或失败）及其结构值 Promise 的好处是什么？ 逻辑更清晰（成功或失败会关联后续的处理函数） 了解 axios 函数内部运作的机制 解决回调函数地狱问题 123456789101112131415161718/** * 目标：使用Promise管理异步任务*/// 1. 创建Promise对象const p = new Promise((resolve, reject) =&gt; &#123; // 2. 执行异步代码 setTimeout(() =&gt; &#123; // resolve(&#x27;模拟AJAX请求-成功结果&#x27;) reject(new Error(&#x27;模拟AJAX请求-失败结果&#x27;)) &#125;, 2000)&#125;)// 3. 获取结果p.then(result =&gt; &#123; console.log(result)&#125;).catch(error =&gt; &#123; console.log(error)&#125;) promise的状态Promise 有哪三种状态？ 每个 Promise 对象必定处于以下三种状态之一 待定（pending）：初始状态，既没有被兑现，也没有被拒绝 已兑现（fulfilled）：操作成功完成 已拒绝（rejected）：操作失败 Promise 的状态改变有什么用？ 调用对应函数，改变 Promise 对象状态后，内部触发对应回调函数传参并执行 注意：每个 Promise 对象一旦被兑现&#x2F;拒绝，那就是已敲定了，状态无法再被改变 创建promise实例一般情况下都会使用new Promise()来创建promise对象，但是也可以使用promise.resolve和promise.reject这两个方法： Promise.resolve Promise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下： 1234Promise.resolve(11).then(function(value)&#123; console.log(value); // 打印出11&#125;); Promise.reject Promise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下 12Promise.reject(new Error(“我错了！！”)); Promise的实例方法和静态方法实例方法then then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。 then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 catch 该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。 finally finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 123456server.listen(port) .then(function () &#123; // ... &#125;) .finally(server.stop); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 静态方法all all方法可以完成并发任务， 它接收一个数组，数组的每一项都是一个promise对象，返回一个Promise实例。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。 race race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。 any 它接收一个数组，数组的每一项都是一个promise对象，该方法会返回一个新的 promise，数组内的任意一个 promise 变成了resolved状态，那么由该方法所返回的 promise 就会变成resolved状态。如果数组内的 promise 状态都是rejected，那么该方法所返回的 promise 就会变成rejected状态， resolve、reject 用来生成对应状态的Promise实例 Promise.all、Promise.race、Promise.any的区别all： 成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。 race： 哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 any： 返回最快的成功结果，如果全部失败就返回失败结果","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"异常处理","path":"/2024/03/01/异常处理/","content":"throw异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行 总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 1234567891011121314&lt;script&gt; function counter(x, y) &#123; if(!x || !y) &#123; // throw &#x27;参数不能为空!&#x27;; throw new Error(&#x27;参数不能为空!&#x27;) &#125; return x + y &#125; counter()&lt;/script&gt; 总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 try … catch123456789101112131415161718192021&lt;script&gt; function foo() &#123; try &#123; // 查找 DOM 节点 const p = document.querySelector(&#x27;.p&#x27;) p.style.color = &#x27;red&#x27; &#125; catch (error) &#123; // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息 console.log(error.message) // 终止代码继续执行 return &#125; finally &#123; alert(&#x27;执行&#x27;) &#125; console.log(&#x27;如果出现错误，我的语句不会执行&#x27;) &#125; foo()&lt;/script&gt; 总结： try...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 debugger相当于断点调试","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"深浅拷贝及其实现方式","path":"/2024/02/29/深浅拷贝/","content":"浅拷贝首先浅拷贝和深拷贝只针对引用类型 浅拷贝：拷贝的是地址 常见方法： 拷贝对象1.Object.assgin()object.assign 是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并。我们可以使用它来实现浅拷贝。 该方法的参数 target 指的是目标对象，sources指的是源对象。使用形式如下： 1Object.assign(target, ...sources) 注： 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性； 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回； 因为null 和 undefined 不能转化为对象，所以第一个参数不能为null或 undefined，否则会报错； 它不会拷贝对象的继承属性，不会拷贝对象的不可枚举的属性，可以拷贝 Symbol 类型的属性。 实际上，Object.assign 会循环遍历原对象的可枚举属性，通过复制的方式将其赋值给目标对象的相应属性。 2. 扩展运算符使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。使用形式如下： 1let cloneObj = &#123; ...obj &#125;; 拷贝数组（1）Array.prototype.slice()slice()方法是JavaScript数组方法，该方法可以从已有数组中返回选定的元素，不会改变原始数组。使用方式如下： 1array.slice(start, end) slice 方法不会修改原数组，只会返回一个浅拷贝了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说，slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。 （2）Array.prototype.concat()concat() 方法用于合并两个或多个数组，此方法不会更改原始数组，而是返回一个新数组。使用方式如下： 1arrayObject.concat(arrayX,arrayX,......,arrayX) concat方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（参数是数组）或参数本身（参数不是数组）。它不会递归到嵌套数组参数中。&#x20; concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中，如下所示： 对象引用（而不是实际对象）：concat将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。 数据类型如字符串，数字和布尔值：concat将字符串和数字的值复制到新数组中。 手动实现浅拷贝根据以上对浅拷贝的理解，实现浅拷贝的思路： 对基础类型做最基本的拷贝； 对引用类型开辟新的存储，并且拷贝一层对象属性。 1234567891011121314// 浅拷贝的实现;function shallowCopy(object) &#123; // 只拷贝对象 if (!object || typeof object !== &quot;object&quot;) return; // 根据 object 的类型判断是新建一个数组还是对象 let newObject = Array.isArray(object) ? [] : &#123;&#125;; // 遍历 object，并且判断是 object 的属性才拷贝 for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = object[key]; &#125; &#125; return newObject;&#125; 这里用到了 hasOwnProperty() 方法，该方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。所有继承了 Object 的对象都会继承到 hasOwnProperty() 方法。这个方法可以用来检测一个对象是否是自身属性。 可以看到，所有的浅拷贝都只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝就无能为力了。深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。 深拷贝首先浅拷贝和深拷贝只针对引用类型 深拷贝：拷贝的是对象，不是地址 常见方法： 通过递归实现深拷贝 lodash&#x2F;cloneDeep 通过JSON.stringify()实现 1.递归实现函数递归： 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 简单理解: 函数内部自己调用自己, 这个函数就是递归函数 递归函数的作用和循环效果类似 由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt; &lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小宝&#x27; &#125; &#125; const o = &#123;&#125; // 拷贝函数 function deepCopy(newObj, oldObj) &#123; debugger for (let k in oldObj) &#123; // 处理数组的问题 一定先写数组 在写 对象 不能颠倒 if (oldObj[k] instanceof Array) &#123; newObj[k] = [] // newObj[k] 接收 [] hobby // oldObj[k] [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] deepCopy(newObj[k], oldObj[k]) &#125; else if (oldObj[k] instanceof Object) &#123; newObj[k] = &#123;&#125; deepCopy(newObj[k], oldObj[k]) &#125; else &#123; // k 属性名 uname age oldObj[k] 属性值 18 // newObj[k] === o.uname 给新对象添加属性 newObj[k] = oldObj[k] &#125; &#125; &#125; deepCopy(o, obj) // 函数调用 两个参数 o 新对象 obj 旧对象 console.log(o) o.age = 20 o.hobby[0] = &#x27;篮球&#x27; o.family.baby = &#x27;老宝&#x27; console.log(obj) console.log([1, 23] instanceof Object) // 复习 // const obj = &#123; // uname: &#x27;pink&#x27;, // age: 18, // hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] // &#125; // function deepCopy(&#123; &#125;, oldObj) &#123; // // k 属性名 oldObj[k] 属性值 // for (let k in oldObj) &#123; // // 处理数组的问题 k 变量 // newObj[k] = oldObj[k] // // o.uname = &#x27;pink&#x27; // // newObj.k = &#x27;pink&#x27; // &#125; // &#125; &lt;/script&gt;&lt;/body&gt; 这样虽然实现了深拷贝，但也存在一些问题： 不能复制不可枚举属性以及 Symbol 类型； 只能对普通引用类型的值做递归复制，对于 Date、RegExp、Function 等引用类型不能正确拷贝； 可能存在循环引用问题。 优化递归实现上面只是实现了一个基础版的深拷贝，对于上面存在的几个问题，可以尝试去解决一下： 使用 Reflect.ownKeys() 方法来解决不能复制不可枚举属性以及 Symbol 类型的问题。 Reflect.ownKeys() 方法会返回一个由目标对象自身的属性键组成的数组。它的返回值等同于: Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)); 当参数值为 Date、RegExp 类型时，直接生成一个新的实例并返回； 利用 Object.getOwnPropertyDescriptors() 方以获得对象的所有属性以及对应的特性。简单来说，这个方法返回给定对象的所有属性的信息，包括有关getter和setter的信息。它允许创建对象的副本并在复制所有属性（包括getter和setter）时克隆它。 使用 Object.create() 方法创建一个新对象，并继承传入原对象的原型链。Object.create()方法会创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 使用 WeakMap 类型作为 Hash 表，WeakMap 是弱引用类型，可以防止内存泄漏，所以可以用来检测循环引用，如果存在循环，则引用直接返回 WeakMap 存储的值。WeakMap的特性就是，保存在其中的对象不会影响垃圾回收，如果WeakMap保存的节点，在其他地方都没有被引用了，那么即使它还在WeakMap中也会被垃圾回收回收掉了。在深拷贝的过程当中，里面所有的引用对象都是被引用的，为了解决循环引用的问题，在深拷贝的过程中，希望有个数据结构能够记录每个引用对象有没有被使用过，但是深拷贝结束之后这个数据能自动被垃圾回收，避免内存泄漏。 12345678910111213141516171819202122232425262728function deepClone (obj, hash = new WeakMap()) &#123; // 日期对象直接返回一个新的日期对象 if (obj instanceof Date)&#123; return new Date(obj); &#125; //正则对象直接返回一个新的正则对象 if (obj instanceof RegExp)&#123; return new RegExp(obj); &#125; //如果循环引用,就用 weakMap 来解决 if (hash.has(obj))&#123; return hash.get(obj); &#125; // 获取对象所有自身属性的描述 let allDesc = Object.getOwnPropertyDescriptors(obj); // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc) hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; if(typeof obj[key] === &#x27;object&#x27; &amp;&amp; obj[key] !== null)&#123; cloneObj[key] = deepClone(obj[key], hash); &#125; else &#123; cloneObj[key] = obj[key]; &#125; &#125; return cloneObj&#125; 测试数据： 12345678910111213141516171819202122let obj = &#123; num: 1, str: &#x27;str&#x27;, boolean: true, und: undefined, nul: null, obj: &#123; name: &#x27;对象&#x27;, id: 1 &#125;, arr: [0, 1, 2], func: function () &#123; console.log(&#x27;函数&#x27;) &#125;, date: new Date(1), reg: new RegExp(&#x27;/正则/ig&#x27;), [Symbol(&#x27;1&#x27;)]: 1,&#125;;Object.defineProperty(obj, &#x27;innumerable&#x27;, &#123; enumerable: false, value: &#x27;不可枚举属性&#x27; &#125;);obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))obj.loop = obj // 将loop设置成循环引用的属性let cloneObj = deepClone(obj)console.log(&#x27;obj&#x27;, obj)console.log(&#x27;cloneObj&#x27;, cloneObj) 这样基本就实现了多数数据类型的深拷贝，不过也还存在一些缺陷，比如Map和Set结构在这个方法中无法进行拷贝。 2.lodash库cloneDeep123456789101112131415161718&lt;body&gt; &lt;!-- 先引用 --&gt; &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小宝&#x27; &#125; &#125; const o = _.cloneDeep(obj) console.log(o) o.family.baby = &#x27;老宝&#x27; console.log(obj) &lt;/script&gt;&lt;/body&gt; lodash中深拷贝的源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*** value：需要拷贝的对象* bitmask：位掩码，其中 1 是深拷贝，2 拷贝原型链上的属性，4 是拷贝 Symbols 属性* customizer：定制的 clone 函数* key：传入 value 值的 key* object：传入 value 值的父对象* stack：Stack 栈，用来处理循环引用*/function baseClone(value, bitmask, customizer, key, object, stack) &#123; let result // 标志位 const isDeep = bitmask &amp; CLONE_DEEP_FLAG // 深拷贝，true const isFlat = bitmask &amp; CLONE_FLAT_FLAG // 拷贝原型链，false const isFull = bitmask &amp; CLONE_SYMBOLS_FLAG // 拷贝 Symbol，true // 自定义 clone 函数 if (customizer) &#123; result = object ? customizer(value, key, object, stack) : customizer(value) &#125; if (result !== undefined) &#123; return result &#125; // 非对象 if (!isObject(value)) &#123; return value &#125; const isArr = Array.isArray(value) const tag = getTag(value) if (isArr) &#123; // 数组 result = initCloneArray(value) if (!isDeep) &#123; return copyArray(value, result) &#125; &#125; else &#123; // 对象 const isFunc = typeof value == &#x27;function&#x27; if (isBuffer(value)) &#123; return cloneBuffer(value, isDeep) &#125; if (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123; result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value) if (!isDeep) &#123; return isFlat ? copySymbolsIn(value, copyObject(value, keysIn(value), result)) : copySymbols(value, Object.assign(result, value)) &#125; &#125; else &#123; if (isFunc || !cloneableTags[tag]) &#123; return object ? value : &#123;&#125; &#125; result = initCloneByTag(value, tag, isDeep) &#125; &#125; // 循环引用 stack || (stack = new Stack) const stacked = stack.get(value) if (stacked) &#123; return stacked &#125; stack.set(value, result) // Map if (tag == mapTag) &#123; value.forEach((subValue, key) =&gt; &#123; result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack)) &#125;) return result &#125; // Set if (tag == setTag) &#123; value.forEach((subValue) =&gt; &#123; result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack)) &#125;) return result &#125; // TypedArray if (isTypedArray(value)) &#123; return result &#125; // Symbol &amp; 原型链 const keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys) const props = isArr ? undefined : keysFunc(value) // 遍历赋值 arrayEach(props || value, (subValue, key) =&gt; &#123; if (props) &#123; key = subValue subValue = value[key] &#125; assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack)) &#125;) // 返回结果 return result&#125; 3.JSON序列化JSON.parse(JSON.stringify(obj))是比较常用的深拷贝方法之一，它的原理就是利用JSON.stringify 将JavaScript对象序列化成为JSON字符串），并将对象里面的内容转换成字符串，再使用JSON.parse来反序列化，将字符串生成一个新的JavaScript对象。&#x20; 123456789101112131415161718&lt;body&gt; &lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小宝&#x27; &#125; &#125; // 把对象转换为 JSON 字符串 // console.log(JSON.stringify(obj)) const o = JSON.parse(JSON.stringify(obj)) console.log(o) o.family.baby = &#x27;123&#x27; console.log(obj) &lt;/script&gt;&lt;/body&gt; 这个方法虽然简单粗暴，但也存在一些问题，在使用该方法时需要注意： 拷贝的对象中如果有函数，undefined，symbol，当使用过JSON.stringify()进行处理之后，都会消失。 无法拷贝不可枚举的属性； 无法拷贝对象的原型链； 拷贝 Date 引用类型会变成字符串； 拷贝 RegExp 引用类型会变成空对象； 对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null； 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 面向对象","path":"/2024/02/22/面向对象的思想/","content":"原型对象构造函数通过原型分配的函数是所有对象所 共享的。 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 构造函数和原型对象中的this 都指向 实例化的对象 1234567891011121314&lt;script&gt; function Person() &#123; // 此处未定义任何方法 &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; // 实例化 let p1 = new Person(); p1.sayHi(); // 输出结果为 Hi~&lt;/script&gt; 构造函数 Person 中未定义任何方法，这时实例对象调用了原型对象中的方法 sayHi，接下来改动一下代码： 12345678910111213141516&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27;); &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; let p1 = new Person(); p1.sayHi(); // 输出结果为 嗨!&lt;/script&gt; 构造函数 Person 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 sayHi。 通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。 123456789101112131415161718192021&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27; + this.name) &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27; + this.name) &#125; // 在构造函数的原型对象上添加属性 Person.prototype.name = &#x27;小明&#x27; let p1 = new Person() p1.sayHi(); // 输出结果为 嗨! let p2 = new Person() p2.sayHi()&lt;/script&gt; 总结：结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。 constructor 属性每个原型对象里面都有个constructor 属性（constructor 构造函数） 作用：该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子 使用场景： 如果有多个对象的方法，我们可以给原型对象采取对象形式赋值. 但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了 此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 对象原型对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。 注意： &#x20;__proto__ 是JS非标准属性 [[prototype]]和 __proto__意义相同 用来表明当前实例对象指向哪个原型对象 __proto__ &#x20;__proto__对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数 原型继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;script&gt; // 继续抽取 公共的部分放到原型上 // const Person1 = &#123; // eyes: 2, // head: 1 // &#125; // const Person2 = &#123; // eyes: 2, // head: 1 // &#125; // 构造函数 new 出来的对象 结构一样，但是对象不一样 function Person() &#123; this.eyes = 2 this.head = 1 &#125; // console.log(new Person) // 女人 构造函数 继承 想要 继承 Person function Woman() &#123; &#125; // Woman 通过原型来继承 Person // 父构造函数（父类） 子构造函数（子类） // 子类的原型 = new 父类 Woman.prototype = new Person() // &#123;eyes: 2, head: 1&#125; // 指回原来的构造函数 Woman.prototype.constructor = Woman // 给女人添加一个方法 生孩子 Woman.prototype.baby = function () &#123; console.log(&#x27;宝贝&#x27;) &#125; const red = new Woman() console.log(red) // console.log(Woman.prototype) // 男人 构造函数 继承 想要 继承 Person function Man() &#123; &#125; // 通过 原型继承 Person Man.prototype = new Person() Man.prototype.constructor = Man const pink = new Man() console.log(pink) &lt;/script&gt;&lt;/body&gt; 原型链基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链 12345678910111213141516171819&lt;body&gt; &lt;script&gt; // function Objetc() &#123;&#125; console.log(Object.prototype) console.log(Object.prototype.__proto__) function Person() &#123; &#125; const ldh = new Person() // console.log(ldh.__proto__ === Person.prototype) // console.log(Person.prototype.__proto__ === Object.prototype) console.log(ldh instanceof Person) console.log(ldh instanceof Object) console.log(ldh instanceof Array) console.log([1, 2, 3] instanceof Array) console.log(Array instanceof Object) &lt;/script&gt;&lt;/body&gt; ① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 ② 如果没有就查找它的原型（也就是 proto指向的 prototype 原型对象） ③ 如果还没有就查找原型对象的原型（Object的原型对象） ④ 依此类推一直找到 Object 为止（null） ⑤ proto对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 ⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 构造函数","path":"/2024/02/13/深入对象/","content":"构造函数构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。 12345678&lt;script&gt; // 定义函数 function foo() &#123; console.log(&#x27;通过 new 也能调用函数...&#x27;); &#125; // 调用函数 new foo;&lt;/script&gt; 总结： 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 () 构造函数的返回值即为新创建的对象 构造函数内部的 return 返回的值无效！ 注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。 实例成员通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 总结： 构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 注：构造函数创建的实例对象彼此独立互不影响 静态成员在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 总结： 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数 掌握各引用类型和包装类型对象属性和方法的使用。 在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。 在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。 包装类型在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例： 1234567891011&lt;script&gt; // 字符串类型 const str = &#x27;hello world!&#x27; // 统计字符的长度（字符数量） console.log(str.length) // 数值类型 const price = 12.345 // 保留两位小数 price.toFixed(2) // 12.34&lt;/script&gt; 之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。 ObjectObject 是内置的构造函数，用于创建普通对象。 12345678910111213141516171819202122&lt;script&gt; // 通过构造函数创建普通对象 const user = new Object(&#123;name: &#x27;小明&#x27;, age: 15&#125;) // 这种方式声明的变量称为【字面量】 let student = &#123;name: &#x27;杜子腾&#x27;, age: 21&#125; // 对象语法简写 let name = &#x27;小红&#x27;; let people = &#123; // 相当于 name: name name, // 相当于 walk: function () &#123;&#125; walk () &#123; console.log(&#x27;人都要走路...&#x27;); &#125; &#125; console.log(student.constructor); console.log(user.constructor); console.log(student instanceof Object);&lt;/script&gt; 总结： 推荐使用字面量方式声明对象，而不是 Object 构造函数 Object.assign 静态方法创建新的对象 Object.keys 静态方法获取对象中所有属性 Object.values 表态方法获取对象中所有属性值 ArrayArray 是内置的构造函数，用于创建数组。 12345678&lt;script&gt; // 构造函数创建数组 let arr = new Array(5, 7, 8); // 字面量方式创建数组 let list = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]&lt;/script&gt; 数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 实例方法 reduce 返回函数累计处理的结果 StringString 是内置的构造函数，用于创建字符串。 1234567891011&lt;script&gt; // 使用构造函数创建字符串 let str = new String(&#x27;hello world!&#x27;); // 字面量创建字符串 let str2 = &#x27;你好，世界！&#x27;; // 检测是否属于同一个构造函数 console.log(str.constructor === str2.constructor); // true console.log(str instanceof String); // false&lt;/script&gt; 总结： 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 NumberNumber 是内置的构造函数，用于创建数值。 123456789&lt;script&gt; // 使用构造函数创建数值 let x = new Number(&#x27;10&#x27;) let y = new Number(5) // 字面量创建数值 let z = 20&lt;/script&gt; 总结： 推荐使用字面量方式声明数值，而不是 Number 构造函数 实例方法 toFixed 用于设置保留小数位的长度","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 解构赋值","path":"/2024/01/31/解构赋值/","content":"解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。 1. 数组解构数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示： 12345678910111213&lt;script&gt; // 普通的数组 let arr = [1, 2, 3] // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 let a=1 let b=2;//此处必须加分号 [b,a]=[a,b]&lt;/script&gt; 总结： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析。 需要加分号的两种情况： （1）立即执行函数需要加 （2）数组解构需要加 2. 对象解构对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示： 12345678910111213&lt;script&gt; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125;; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const &#123;name, age&#125; = user console.log(name) // 小明 console.log(age) // 18&lt;/script&gt; 总结： 赋值运算符 = 左侧的 &#123;&#125; 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 注：支持多维解构赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;script&gt; // 1. 这是后台传递过来的数据 const msg = &#123; &quot;code&quot;: 200, &quot;msg&quot;: &quot;获取新闻列表成功&quot;, &quot;data&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;5G商用自己，三大运用商收入下降&quot;, &quot;count&quot;: 58 &#125;, &#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;国际媒体头条速览&quot;, &quot;count&quot;: 56 &#125;, &#123; &quot;id&quot;: 3, &quot;title&quot;: &quot;乌克兰和俄罗斯持续冲突&quot;, &quot;count&quot;: 1669 &#125;, ] &#125; // 需求1： 请将以上msg对象 采用对象解构的方式 只选出 data 方面后面使用渲染页面 // const &#123; data &#125; = msg // console.log(data) // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数 // const &#123; data &#125; = msg // msg 虽然很多属性，但是我们利用解构只要 data值 function render(&#123; data &#125;) &#123; // const &#123; data &#125; = arr // 我们只要 data 数据 // 内部处理 console.log(data) &#125; render(msg) // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData function render(&#123; data: myData &#125;) &#123; // 要求将 获取过来的 data数据 更名为 myData // 内部处理 console.log(myData) &#125; render(msg) &lt;/script&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 函数提升与参数、箭头函数","path":"/2024/01/24/函数进阶/","content":"1. 函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 1234567891011121314&lt;script&gt; // 调用函数 foo() // 声明函数 function foo() &#123; console.log(&#x27;声明之前即被调用...&#x27;) &#125; // 不存在提升现象 bar() // 错误 var bar = function () &#123; console.log(&#x27;函数表达式不存在提升现象...&#x27;) &#125;&lt;/script&gt; 总结： 函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域当中 2. 函数参数函数参数的使用细节，能够提升函数应用的灵活度。 2.1 默认值12345678910&lt;script&gt; // 设置参数默认值 function sayHi(name=&quot;小明&quot;, age=18) &#123; document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`); &#125; // 调用函数 sayHi(); sayHi(&#x27;小红&#x27;); sayHi(&#x27;小刚&#x27;, 21);&lt;/script&gt; 总结： 声明函数时为形参赋值即为参数的默认值 如果参数未自定义默认值时，参数的默认值为 undefined 调用函数时没有传入对应实参时，参数的默认值被当做实参传入 2.2 动态参数arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。 1234567891011121314&lt;script&gt; // 求生函数，计算所有参数的和 function sum() &#123; // console.log(arguments) let s = 0 for(let i = 0; i &lt; arguments.length; i++) &#123; s += arguments[i] &#125; console.log(s) &#125; // 调用求和函数 sum(5, 10)// 两个参数 sum(1, 2, 4) // 两个参数&lt;/script&gt; 总结： arguments 是一个伪数组 arguments 的作用是动态获取函数的实参 2.3剩余参数12345678&lt;script&gt; function config(baseURL, ...other) &#123; console.log(baseURL) // 得到 &#x27;http://baidu.com&#x27; console.log(other) // other 得到 [&#x27;get&#x27;, &#x27;json&#x27;] &#125; // 调用函数 config(&#x27;http://baidu.com&#x27;, &#x27;get&#x27;, &#x27;json&#x27;);&lt;/script&gt; 总结： ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 2.4 展开运算符 与剩余参数相比剩余参数：函数参数使用，得到真数组 展开运算符：数组中使用，数组展开 3. 箭头函数目的：引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁使用场景:箭头函数更适用于那些本来需要匿名函数的地方 箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;script&gt; // const fn = function () &#123; // console.log(123) // &#125; // 1. 箭头函数 基本语法 // const fn = () =&gt; &#123; // console.log(123) // &#125; // fn() // const fn = (x) =&gt; &#123; // console.log(x) // &#125; // fn(1) // 2. 只有一个形参的时候，可以省略小括号 // const fn = x =&gt; &#123; // console.log(x) // &#125; // fn(1) // // 3. 只有一行代码的时候，我们可以省略大括号 // const fn = x =&gt; console.log(x) // fn(1) // 4. 只有一行代码的时候，可以省略return // const fn = x =&gt; x + x // console.log(fn(1)) // 5. 箭头函数可以直接返回一个对象 // const fn = (uname) =&gt; (&#123; uname: uname &#125;) // console.log(fn(&#x27;刘德华&#x27;)) &lt;/script&gt;&lt;/body&gt; 总结： 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 &#123;&#125;，并自动做为返回值被返回 3.1 箭头函数参数箭头函数中没有 arguments，只能使用 ... 动态获取实参 12345678910111213&lt;body&gt; &lt;script&gt; // 1. 利用箭头函数来求和 const getSum = (...arr) =&gt; &#123; let sum = 0 for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum &#125; const result = getSum(2, 3, 4) console.log(result) // 9 &lt;/script&gt; 3.2 箭头函数 this箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; // 以前this的指向： 谁调用的这个函数，this 就指向谁 // console.log(this) // window // // 普通函数 // function fn() &#123; // console.log(this) // window // &#125; // window.fn() // // 对象方法里面的this // const obj = &#123; // name: &#x27;andy&#x27;, // sayHi: function () &#123; // console.log(this) // obj // &#125; // &#125; // obj.sayHi() // 2. 箭头函数的this 是上一层作用域的this 指向 // const fn = () =&gt; &#123; // console.log(this) // window // &#125; // fn() // 对象方法箭头函数 this // const obj = &#123; // uname: &#x27;pink老师&#x27;, // sayHi: () =&gt; &#123; // console.log(this) // this 指向谁？ window // &#125; // &#125; // obj.sayHi() const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: function () &#123; console.log(this) // obj let i = 10 const count = () =&gt; &#123; console.log(this) // obj &#125; count() &#125; &#125; obj.sayHi() &lt;/script&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 作用域和作用域链","path":"/2024/01/24/作用域和作用域链/","content":"作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。 1. 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。 123456789101112&lt;script&gt; // 声明 counter 函数 function counter(x, y) &#123; // 函数内部声明的变量 const s = x + y console.log(s) // 18 &#125; // 设用 counter 函数 counter(10, 8) // 访问变量 s console.log(s)// 报错&lt;/script&gt; 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部变量 不同函数内部声明的变量无法互相访问 函数执行完毕后，函数内部的变量实际被清空了 块作用域在 JavaScript 中使用 &#123;&#125; 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。 12345678910111213141516171819202122232425262728&lt;script&gt; &#123; // age 只能在该代码块中被访问 let age = 18; console.log(age); // 正常 &#125; // 超出了 age 的作用域 console.log(age) // 报错 let flag = true; if(flag) &#123; // str 只能在该代码块中被访问 let str = &#x27;hello world!&#x27; console.log(str); // 正常 &#125; // 超出了 age 的作用域 console.log(str); // 报错 for(let t = 1; t &lt;= 6; t++) &#123; // t 只能在该代码块中被访问 console.log(t); // 正常 &#125; // 超出了 t 的作用域 console.log(t); // 报错&lt;/script&gt; JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。 1234567891011121314151617181920&lt;script&gt; // 必须要有值 const version = &#x27;1.0.0&#x27;; // 不能重新赋值 // version = &#x27;1.0.1&#x27;; // 常量值为对象类型 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; // 不能重新赋值 user = &#123;&#125;; // 属性和方法允许被修改 user.name = &#x27;小小明&#x27;; user.gender = &#x27;男&#x27;;&lt;/script&gt; 总结： let 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 推荐使用 let 或 const 注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。 2. 全局作用域&lt;script&gt; 标签和 .js 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。 123456789&lt;script&gt; // 此处是全局 function sayHi() &#123; // 此处为局部 &#125; // 此处为全局&lt;/script&gt; 全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示： 1234567891011121314151617181920&lt;script&gt; // 全局变量 name const name = &#x27;小明&#x27; // 函数作用域中访问全局 function sayHi() &#123; // 此处为局部 console.log(&#x27;你好&#x27; + name) &#125; // 全局变量 flag 和 x const flag = true let x = 10 // 块作用域中访问全局 if(flag) &#123; let y = 5 console.log(x + y) // x 是全局的 &#125;&lt;/script&gt; 总结： 为 window 对象动态添加的属性默认也是全局的，不推荐！ 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ 尽可能少的声明全局变量，防止全局变量被污染 JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。 3. 作用域链在解释什么是作用域链前先来看一段代码： 12345678910111213&lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; &#125; &#125;&lt;/script&gt; 函数内部允许创建新的函数，f 函数内部创建的新函数 g，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。 如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。 作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示： 12345678910111213141516171819202122232425262728&lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // let a = 10; console.log(a) // 1 或 10 console.log(d) // 报错 // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; // let b = 20; console.log(b) // 2 或 20 &#125; // 调用 g 函数 g() &#125; console.log(c) // 报错 console.log(d) // 报错 f();&lt;/script&gt; 总结： 嵌套关系的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父作用域，父级作用域无法访问子级作用域 4. 垃圾回收机制概念垃圾回收机制(Garbage Collection) 简称 GCJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况不再用到的内存，没有及时释放，就叫做内存泄漏 内存的生命周期JS环境中分配的内存, 一般有如下生命周期： 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 说明： &#x20;全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 堆栈空间分配区别1、栈(操作系统)︰由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。2．堆(操作系统)︰一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。下面介绍两种常见的浏览器垃圾回收算法：引用计数法和标记清除法。 引用计数法引用计数 IE采用的引用计数算法，定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象算法: 跟踪记录被引用的次数 如果被引用了一次，那么就记录次数1，多次引用会累加 如果减少一个引用就减1 如果引用次数是0，则释放内存 但它却存在一个致命的问题:嵌套引用（循环引用)。 如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 123456789function fn() &#123; let o1 = &#123;&#125; let o2 = &#123;&#125; o1.a = o2 o2.a = o1 return &#x27;引用计数无法回收&#x27;&#125;fn() 标记清除法现代的浏览器已经不再使用引用计数算法了。 现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心: 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 5. 闭包闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数，如下代码所示： 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;script&gt; // 1. 闭包 : 内层函数 + 外层函数变量 // function outer() &#123; // const a = 1 // function f() &#123; // console.log(a) // &#125; // f() // &#125; // outer() // 2. 闭包的应用： 实现数据的私有。统计函数的调用次数 // let count = 1 // function fn() &#123; // count++ // console.log(`函数被调用$&#123;count&#125;次`) // &#125; // 3. 闭包的写法 统计函数的调用次数 function outer() &#123; let count = 1 function fn() &#123; count++ console.log(`函数被调用$&#123;count&#125;次`) &#125; return fn &#125; const re = outer() // const re = function fn() &#123; // count++ // console.log(`函数被调用$&#123;count&#125;次`) // &#125; re() re() // const fn = function() &#123; &#125; 函数表达式 // 4. 闭包存在的问题： 可能会造成内存泄漏 &lt;/script&gt;&lt;/body&gt; 总结： 1.怎么理解闭包？ 闭包 &#x3D; 内层函数 + 外层函数的变量 2.闭包的作用？ 封闭数据，实现数据私有，外部也可以访问函数内部的变量 闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来 3.闭包可能引起的问题？ 内存泄漏 6. 变量提升变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问， 1234567&lt;script&gt; // 访问变量 str console.log(str + &#x27;world!&#x27;); // 声明变量 str var str = &#x27;hello &#x27;;&lt;/script&gt; 总结： 变量在未声明即被访问时会报语法错误 变量在声明之前即被访问，变量的值为 undefined let 声明的变量不存在变量提升，推荐使用 let 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 let 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可查阅资料。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"hexo使用笔记","path":"/2024/01/23/hexo使用记录/","content":"1、文章内加图片（stellar主题）_config.yml里配置post_asset_folder。 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 在_posts文件夹下新建一个与markdown文件同名的文件夹，放置图片资源。 在markdown文件内，使用’&#x2F;test01.jpg’的路径引入。 2、配色方案https://www.colorhunt.co/ 提供赏心悦目的色彩搭配方案，可以直接复制十六进制。 3、文章的toc（stellar主题）默认从H2开始，分级要严格按照2→3→4→5这样降级，否则会显示错误。 4、配置文章的默认信息如果是手动把已经写好的markdown文件拖入post文件夹上传，需要在markdown文件开始的地方配置默认YAML信息，快捷键为三个➖加换行。本博客使用的配置信息格式为： 12345title: hexo使用笔记categories: blog搭建tags: [blog,踩坑记录]cover: /picture/blog.jpgdate: 2024-01-23 14:52","tags":["blog","踩坑记录"],"categories":["blog搭建"]},{"title":"Javascript 正则表达式","path":"/2024/01/22/正则表达式/","content":"概念定义正则表达式（Regular Expression）是一种字符串匹配的模式（规则）。 使用场景 例如验证表单：手机号表单要求用户只能输入11位的数字 (匹配) 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 正则基本使用 定义规则1const reg = /表达式/ 其中/ /是正则表达式字面量 正则表达式也是对象 使用正则 test()方法 用来查看正则表达式与指定的字符串是否匹配 如果正则表达式与指定的字符串匹配 ，返回true，否则false 123456789101112&lt;body&gt; &lt;script&gt; // 正则表达式的基本使用 const str = &#x27;web前端开发&#x27; // 1. 定义规则 const reg = /web/ // 2. 使用正则 test() console.log(reg.test(str)) // true 如果符合规则匹配上则返回true console.log(reg.test(&#x27;java开发&#x27;)) // false 如果不符合规则匹配上则返回 false &lt;/script&gt;&lt;/body&gt; 元字符普通字符: 大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。 普通字符只能够匹配字符串中与它们相同的字符。 &#x20; 比如，规定用户只能输入英文26个英文字母，普通字符的话 &#x2F;[abcdefghijklmnopqrstuvwxyz]&#x2F; 元字符(特殊字符） 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，换成元字符写法： &#x2F;[a-z]&#x2F; 1. 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 如果 ^ 和 $ 在一起，表示必须是精确匹配 123456789101112131415161718192021222324252627&lt;body&gt; &lt;script&gt; // 元字符之边界符 // 1. 匹配开头的位置 ^ const reg = /^web/ console.log(reg.test(&#x27;web前端&#x27;)) // true console.log(reg.test(&#x27;前端web&#x27;)) // false console.log(reg.test(&#x27;前端web学习&#x27;)) // false console.log(reg.test(&#x27;we&#x27;)) // false // 2. 匹配结束的位置 $ const reg1 = /web$/ console.log(reg1.test(&#x27;web前端&#x27;)) // false console.log(reg1.test(&#x27;前端web&#x27;)) // true console.log(reg1.test(&#x27;前端web学习&#x27;)) // false console.log(reg1.test(&#x27;we&#x27;)) // false // 3. 精确匹配 ^ $ const reg2 = /^web$/ console.log(reg2.test(&#x27;web前端&#x27;)) // false console.log(reg2.test(&#x27;前端web&#x27;)) // false console.log(reg2.test(&#x27;前端web学习&#x27;)) // false console.log(reg2.test(&#x27;we&#x27;)) // false console.log(reg2.test(&#x27;web&#x27;)) // true console.log(reg2.test(&#x27;webweb&#x27;)) // flase &lt;/script&gt;&lt;/body&gt; 2. 量词量词用来设定某个模式重复次数 📌注意： 逗号左右两侧千万不要出现空格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;script&gt; // 元字符之量词 // 1. * 重复次数 &gt;= 0 次 const reg1 = /^w*$/ console.log(reg1.test(&#x27;&#x27;)) // true console.log(reg1.test(&#x27;w&#x27;)) // true console.log(reg1.test(&#x27;ww&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 2. + 重复次数 &gt;= 1 次 const reg2 = /^w+$/ console.log(reg2.test(&#x27;&#x27;)) // false console.log(reg2.test(&#x27;w&#x27;)) // true console.log(reg2.test(&#x27;ww&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 3. ? 重复次数 0 || 1 const reg3 = /^w?$/ console.log(reg3.test(&#x27;&#x27;)) // true console.log(reg3.test(&#x27;w&#x27;)) // true console.log(reg3.test(&#x27;ww&#x27;)) // false console.log(&#x27;-----------------------&#x27;) // 4. &#123;n&#125; 重复 n 次 const reg4 = /^w&#123;3&#125;$/ console.log(reg4.test(&#x27;&#x27;)) // false console.log(reg4.test(&#x27;w&#x27;)) // flase console.log(reg4.test(&#x27;ww&#x27;)) // false console.log(reg4.test(&#x27;www&#x27;)) // true console.log(reg4.test(&#x27;wwww&#x27;)) // false console.log(&#x27;-----------------------&#x27;) // 5. &#123;n,&#125; 重复次数 &gt;= n const reg5 = /^w&#123;2,&#125;$/ console.log(reg5.test(&#x27;&#x27;)) // false console.log(reg5.test(&#x27;w&#x27;)) // false console.log(reg5.test(&#x27;ww&#x27;)) // true console.log(reg5.test(&#x27;www&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 6. &#123;n,m&#125; n =&lt; 重复次数 &lt;= m const reg6 = /^w&#123;2,4&#125;$/ console.log(reg6.test(&#x27;w&#x27;)) // false console.log(reg6.test(&#x27;ww&#x27;)) // true console.log(reg6.test(&#x27;www&#x27;)) // true console.log(reg6.test(&#x27;wwww&#x27;)) // true console.log(reg6.test(&#x27;wwwww&#x27;)) // false // 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败 &lt;/script&gt; 3. 范围表示字符的范围，定义的规则限定在某个范围，比如只能是英文字母，或者数字等等，用表示范围 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;script&gt; // 元字符之范围 [] // 1. [abc] 匹配包含的单个字符， 多选1 const reg1 = /^[abc]$/ console.log(reg1.test(&#x27;a&#x27;)) // true console.log(reg1.test(&#x27;b&#x27;)) // true console.log(reg1.test(&#x27;c&#x27;)) // true console.log(reg1.test(&#x27;d&#x27;)) // false console.log(reg1.test(&#x27;ab&#x27;)) // false // 2. [a-z] 连字符 单个 const reg2 = /^[a-z]$/ console.log(reg2.test(&#x27;a&#x27;)) // true console.log(reg2.test(&#x27;p&#x27;)) // true console.log(reg2.test(&#x27;0&#x27;)) // false console.log(reg2.test(&#x27;A&#x27;)) // false // 想要包含小写字母，大写字母 ，数字 const reg3 = /^[a-zA-Z0-9]$/ console.log(reg3.test(&#x27;B&#x27;)) // true console.log(reg3.test(&#x27;b&#x27;)) // true console.log(reg3.test(9)) // true console.log(reg3.test(&#x27;,&#x27;)) // flase // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位 const reg4 = /^[a-zA-Z0-9_]&#123;6,16&#125;$/ console.log(reg4.test(&#x27;abcd1&#x27;)) // false console.log(reg4.test(&#x27;abcd12&#x27;)) // true console.log(reg4.test(&#x27;ABcd12&#x27;)) // true console.log(reg4.test(&#x27;ABcd12_&#x27;)) // true // 3. [^a-z] 取反符 const reg5 = /^[^a-z]$/ console.log(reg5.test(&#x27;a&#x27;)) // false console.log(reg5.test(&#x27;A&#x27;)) // true console.log(reg5.test(8)) // true &lt;/script&gt;&lt;/body&gt; 4. 字符类某些常见模式的简写方式，区分字母和数字 替换和修饰符replace 替换方法，可以完成字符的替换 123456789&lt;body&gt; &lt;script&gt; // 替换和修饰符 const str = &#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个 &lt;/script&gt;&lt;/body&gt; 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 i 是单词 ignore 的缩写，正则匹配时字母不区分大小写 g 是单词 global 的缩写，匹配所有满足正则表达式的结果 12345678910111213&lt;body&gt; &lt;script&gt; // 替换和修饰符 const str = &#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个 // 2. 修饰符 g 全部替换 const strEnd = str.replace(/前端/g, &#x27;web&#x27;) console.log(strEnd) &lt;/script&gt;&lt;/body&gt; change 事件给input注册 change 事件，值被修改并且失去焦点后触发 判断是否有类 元素.classList.contains() 看看有没有包含某个类，如果有则返回true，么有则返回false","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 本地存储","path":"/2024/01/22/本地存储/","content":"本地存储：将数据存储在本地浏览器中 常见的使用场景： https://todomvc.com/examples/vanilla-es6/ 页面刷新数据不丢失 好处： 1、页面刷新或者关闭不丢失数据，实现数据持久化 2、容量较大，sessionStorage和 localStorage 约 5M 左右 localStorage（重点）作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失 特性：以键值对的形式存储，并且存储的是字符串， 省略了window 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;本地存储-localstorage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 本地存储 - localstorage 存储的是字符串 // 1. 存储 localStorage.setItem(&#x27;age&#x27;, 18) // 2. 获取 console.log(typeof localStorage.getItem(&#x27;age&#x27;)) // 3. 删除 localStorage.removeItem(&#x27;age&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; sessionStorage（了解）特性： 用法跟localStorage基本相同 区别是：当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除 存储：sessionStorage.setItem(key,value) 获取：sessionStorage.getItem(key) 删除：sessionStorage.removeItem(key) localStorage 存储复杂数据类型问题：本地只能存储字符串,无法存储复杂数据类型. 解决：需要将复杂数据类型转换成 JSON字符串,在存储到本地 语法：JSON.stringify(复杂数据类型) JSON字符串： 首先是1个字符串 属性名使用双引号引起来，不能单引号 属性值如果是字符串型也必须双引号 12345678910111213141516&lt;body&gt; &lt;script&gt; // 本地存储复杂数据类型 const goods = &#123; name: &#x27;小米&#x27;, price: 1999 &#125; // localStorage.setItem(&#x27;goods&#x27;, goods) // console.log(localStorage.getItem(&#x27;goods&#x27;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(&#x27;goods&#x27;)) &lt;/script&gt;&lt;/body&gt; 问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用 解决： 把取出来的字符串转换为对象 语法：JSON.parse(JSON字符串) 123456789&lt;body&gt; &lt;script&gt; // 本地存储复杂数据类型 const goods = &#123; name: &#x27;小米&#x27;, price: 1999 &#125; // localStorage.setItem(&#x27;goods&#x27;, goods) // console.log(localStorage.getItem(&#x27;goods&#x27;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(&#x27;goods&#x27;)) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem(&#x27;goods&#x27;))) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"hexo+stellar+github actions实现自动部署","path":"/2024/01/16/hexo+stellar+github actions实现自动部署/","content":"博客的持续部署抛开定义，直观上，持续部署，顾名思义，就是持续不断地去部署，部署自动紧跟代码改变：你的提交了源码修改，部署上就自动更新了。对于我们的博客系统，也就是新建&#x2F;修改&#x2F;删除了文章，博客站点就自动更新、修改对应内容。从效果上来说，就是我们不用再去手动 hexo g -d 生成、部署了。 用持续部署，首先提交源码，然后在云端就自动生成(编译)、部署，这个生成、部署的工作是不需要在本地完成的，由github提供的 CI&#x2F;CD 服务的服务器自动来完成。GitHub 免费提供的这项服务叫做 GitHub Actions。 1. 前提工作本教程在以下环境搭建。 12345hexo: 6.3.0hexo-cli: 4.3.0os: win32 10.0.19042node: 16.17.1hexo-deployer-git: 4.0.0 1.1创建所需仓库 创建 blog 仓库用来存放 Hexo 项目 创建 your.github.io 仓库用来存放静态博客页面 1.2生成部署密钥12$ ssh-keygen -f github-deploy-key 一路按回车直到生成成功 当前目录下会有 github-deploy-key 和 github-deploy-key.pub 两个文件。 1.3 配置部署密钥复制 github-deploy-key 文件内容，在 blog 仓库 Settings -&gt; Secrets and variables -&gt; Actions 页面上添加。 在 Name 输入框填写 HEXO_DEPLOY_PRI。 在 Value 输入框填写 github-deploy-key 文件内容。 复制 github-deploy-key.pub 文件内容，在 your.github.io 仓库 Settings -&gt; Deploy keys -&gt; Add deploy key 页面上添加。 在 Title 输入框填写 HEXO_DEPLOY_PUB。 在 Key 输入框填写 github-deploy-key.pub 文件内容。 勾选 Allow write access 选项。 2. 配置workflow在 blog 仓库根目录下创建 .github/workflows/deploy.yml 文件。 在 deploy.yml 文件中粘贴以下内容。 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667name: CIon: push: branches: - mainenv: GIT_USER: YYYutang GIT_EMAIL: email@email.com THEME_REPO: YYYutang/hexo-theme-stellar THEME_BRANCH: main DEPLOY_REPO: YYYutang/YYYutang.github.io DEPLOY_BRANCH: mainjobs: build: name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125; runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v2 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.THEME_REPO &#125;&#125; ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125; path: themes/stellar - name: Checkout deploy repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125; ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125; path: .deploy_git - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node_version &#125;&#125; - name: Configuration environment env: HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125; run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL cp _config.theme.yml themes/stellar/_config.yml - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 模版参数说明 name 为此 Action 的名字 on 触发条件，当满足条件时会触发此任务，这里的 on.push.branches.$.master 是指当 master 分支收到 push 后执行任务。 env 为环境变量对象 env.GIT_USER 为 Hexo 编译后使用此 git 用户部署到仓库。 env.GIT_EMAIL 为 Hexo 编译后使用此 git 邮箱部署到仓库。 env.THEME_REPO 为您的 Hexo 所使用的主题的仓库，这里为 sanonz/hexo-theme-concise。 env.THEME_BRANCH 为您的 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA。 env.DEPLOY_REPO 为 Hexo 编译后要部署的仓库，例如：sanonz/sanonz.github.io。 env.DEPLOY_BRANCH 为 Hexo 编译后要部署到的分支，例如：master。 jobs 为此 Action 下的任务列表 jobs.{job}.name 任务名称 jobs.{job}.runs-on 任务所需容器，可选值：ubuntu-latest、windows-latest、macos-latest。 jobs.{job}.strategy 策略下可以写 array 格式，此 job 会遍历此数组执行。 jobs.{job}.steps 一个步骤数组，可以把所要干的事分步骤放到这里。 jobs.{job}.steps.$.name 步骤名，编译时会会以 LOG 形式输出。 jobs.{job}.steps.$.uses 所要调用的 Action，可以到 https://github.com/actions 查看更多。 jobs.{job}.steps.$.with 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。 这里踩的坑有： 1、path: themes&#x2F;stellar的主题地址忘记换成自己的，导致部署上去之后，所有的html文件均为空文件，并且页面加载不出来。 2、部署成功，但在workflow里deploy那一步有大量报错，说找不到avatar属性，一开始以为是部署流程只识别了_config.theme.yml,所以没有识别_config.yml里设置的avatar，遂修改_config.theme.yml，但没有起作用。 仔细检查发现主题是通过THEME_REPO设置的github连接引入的，而我github上fork的是一个比较早的版本的stellar，本地使用的_config.theme.yml是最新版本的stellar里提供的配置文件。将github上的主题仓库更新至最新版，问题解决。 3、报大量的语法错误 是指定的node_version过低的问题，最新版的stellar不适配12.x的版本，修改为15.x以上即可。 4、报错ERROR Deployer not found: git，需要安装 hexo-deployer-git。 1npm install hexo-deployer-git --save 3. 修改_config.yml里的deploy配置1234567# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: &#x27;git&#x27; repo: git@github.com:yyyutang/YYYutang.github.io.git branch: main message: $&#123;&#123; github.event.head_commit.message &#125;&#125; 4. 配置theme的_config文件复制一份 使用的theme根目录下的_config.yml，放到 blog 根目录下，名为 _config.theme.yml，如果您已经配置过此文件，只需要把您的复制过来就行。 这里注意需要把网站的基础信息，如头像Avatar、标题Title等设置好。 5.执行任务写一篇文章，push 到 blog 仓库的 main 分支，在此仓库 Actions 页面查看当前 task。 当任务完成后查看您的博客 https://your.github.io，如果不出意外的话已经可以看到新添加的文章了。","tags":["blog","踩坑记录"],"categories":["blog搭建"]},{"title":"Javascript Windows对象","path":"/2024/01/16/Window对象/","content":"JavaScript的组成 ECMAScript: 规定了js基础语法核心知识。 比如：变量、分支语句、循环语句、对象等等 Web APIs : DOM 文档对象模型， 定义了一套操作HTML文档的API BOM 浏览器对象模型，定义了一套操作浏览器窗口的API JS执行机制同步任务同步任务都在主线程上执行，形成一个执行栈。 异步任务JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型: 1、普通事件，如 click、resize 等 2、资源加载，如 load、error 等 3、定时器，包括 setInterval、setTimeout 等 异步任务相关添加到任务队列中（任务队列也称为消息队列）。 事件循环 先执行执行栈中的同步任务。 异步任务放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 BOM对象BOM (Browser Object Model ) 是浏览器对象模型 window对象是一个全局对象，也可以说是JavaScript中的顶级对象 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window 定时器-延迟函数JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout 语法： 1setTimeout(回调函数, 延迟时间) setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window 间歇函数 setInterval : 每隔一段时间就执行一次, 平时省略window 清除延时函数： 1clearTimeout(timerId) 注意点1. 延时函数需要等待,所以后面的代码先执行2. 返回值是一个正整数，表示定时器的编号 12345678910111213141516171819&lt;body&gt; &lt;script&gt; // 定时器之延迟函数 // 1. 开启延迟函数 let timerId = setTimeout(function () &#123; console.log(&#x27;我只执行一次&#x27;) &#125;, 3000) // 1.1 延迟函数返回的还是一个正整数数字，表示延迟函数的编号 console.log(timerId) // 1.2 延迟函数需要等待时间，所以下面的代码优先执行 // 2. 关闭延迟函数 clearTimeout(timerId) &lt;/script&gt;&lt;/body&gt; location对象location (地址) 它拆分并保存了 URL 地址的各个组成部分， 它是一个对象 属性&#x2F;方法 说明 href 属性，获取完整的 URL 地址，赋值时用于地址的跳转 search 属性，获取地址中携带的参数，符号 ？后面部分 hash 属性，获取地址中的哈希值，符号 # 后面部分 reload() 方法，用来刷新当前页面，传入参数 true 时表示强制刷新 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;search&quot;&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;a href=&quot;#/music&quot;&gt;音乐&lt;/a&gt; &lt;a href=&quot;#/download&quot;&gt;下载&lt;/a&gt; &lt;button class=&quot;reload&quot;&gt;刷新页面&lt;/button&gt; &lt;script&gt; // location 对象 // 1. href属性 （重点） 得到完整地址，赋值则是跳转到新地址 console.log(location.href) // location.href = &#x27;http://www.itcast.cn&#x27; // 2. search属性 得到 ? 后面的地址 console.log(location.search) // ?search=笔记本 // 3. hash属性 得到 # 后面的地址 console.log(location.hash) // 4. reload 方法 刷新页面 const btn = document.querySelector(&#x27;.reload&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // location.reload() // 页面刷新 location.reload(true) // 强制页面刷新 ctrl+f5 &#125;) &lt;/script&gt;&lt;/body&gt; navigator对象navigator是对象，该对象下记录了浏览器自身的相关信息 常用属性和方法： 通过 userAgent 检测浏览器的版本及平台 12345678910// 检测 userAgent（浏览器信息）(function () &#123; const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) &#123; location.href = &#x27;http://m.itcast.cn&#x27; &#125;&#125;)(); histroy对象history (历史)是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退等 使用场景 history对象一般在实际开发中比较少用，但是会在一些OA 办公系统中见到。 常见方法： 123456789101112131415161718192021&lt;body&gt; &lt;button class=&quot;back&quot;&gt;←后退&lt;/button&gt; &lt;button class=&quot;forward&quot;&gt;前进→&lt;/button&gt; &lt;script&gt; // histroy对象 // 1.前进 const forward = document.querySelector(&#x27;.forward&#x27;) forward.addEventListener(&#x27;click&#x27;, function () &#123; // history.forward() history.go(1) &#125;) // 2.后退 const back = document.querySelector(&#x27;.back&#x27;) back.addEventListener(&#x27;click&#x27;, function () &#123; // history.back() history.go(-1) &#125;) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript M端事件","path":"/2024/01/16/M端事件/","content":"移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。 touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 常见的触屏事件如下：","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM节点","path":"/2024/01/16/DOM节点/","content":"回顾之前 DOM 的操作都是针对元素节点的属性或文本的，除此之外也有专门针对元素节点本身的操作，如插入、复制、删除、替换等。 插入节点在已有的 DOM 节点中插入新的 DOM 节点时，需要关注两个关键因素：首先要得到新的 DOM 节点，其次在哪个位置插入这个节点。 如下代码演示： 123456789101112131415161718192021222324252627&lt;body&gt; &lt;h3&gt;插入节点&lt;/h3&gt; &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt; &lt;hr&gt; &lt;!-- 普通盒子 --&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!-- 点击按钮向 box 盒子插入节点 --&gt; &lt;button class=&quot;btn&quot;&gt;插入节点&lt;/button&gt; &lt;script&gt; // 点击按钮，在网页中插入节点 const btn = document.querySelector(&#x27;.btn&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // 1. 获得一个 DOM 元素节点 const p = document.createElement(&#x27;p&#x27;) p.innerText = &#x27;创建的新的p标签&#x27; p.className = &#x27;info&#x27; // 复制原有的 DOM 节点 const p2 = document.querySelector(&#x27;p&#x27;).cloneNode(true) p2.style.color = &#x27;red&#x27; // 2. 插入盒子 box 盒子 document.querySelector(&#x27;.box&#x27;).appendChild(p) document.querySelector(&#x27;.box&#x27;).appendChild(p2) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： createElement 动态创建任意 DOM 节点 cloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点 appendChild 在末尾（结束标签前）插入节点 再来看另一种情形的代码演示： 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;h3&gt;插入节点&lt;/h3&gt; &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt; &lt;hr&gt; &lt;button class=&quot;btn1&quot;&gt;在任意节点前插入&lt;/button&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 点击按钮，在已有 DOM 中插入新节点 const btn1 = document.querySelector(&#x27;.btn1&#x27;) btn1.addEventListener(&#x27;click&#x27;, function () &#123; // 第 2 个 li 元素 const relative = document.querySelector(&#x27;li:nth-child(2)&#x27;) // 1. 动态创建新的节点 const li1 = document.createElement(&#x27;li&#x27;) li1.style.color = &#x27;red&#x27; li1.innerText = &#x27;Web APIs&#x27; // 复制现有的节点 const li2 = document.querySelector(&#x27;li:first-child&#x27;).cloneNode(true) li2.style.color = &#x27;blue&#x27; // 2. 在 relative 节点前插入 document.querySelector(&#x27;ul&#x27;).insertBefore(li1, relative) document.querySelector(&#x27;ul&#x27;).insertBefore(li2, relative) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： createElement 动态创建任意 DOM 节点 cloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点 insertBefore 在父节点中任意子节点之前插入新节点 删除节点删除现有的 DOM 节点，也需要关注两个因素：首先由父节点删除子节点，其次是要删除哪个子节点。 12345678910111213141516171819202122&lt;body&gt; &lt;!-- 点击按钮删除节点 --&gt; &lt;button&gt;删除节点&lt;/button&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const btn = document.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // 获取 ul 父节点 let ul = document.querySelector(&#x27;ul&#x27;) // 待删除的子节点 let lis = document.querySelectorAll(&#x27;li&#x27;) // 删除节点 ul.removeChild(lis[0]) &#125;) &lt;/script&gt;&lt;/body&gt; 结论：removeChild 删除节点时一定是由父子关系。 查找节点DOM 树中的任意节点都不是孤立存在的，它们要么是父子关系，要么是兄弟关系，不仅如此，我们可以依据节点之间的关系查找节点。 父子关系12345678910111213141516171819202122&lt;body&gt; &lt;button class=&quot;btn1&quot;&gt;所有的子节点&lt;/button&gt; &lt;!-- 获取 ul 的子节点 --&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript 基础&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const btn1 = document.querySelector(&#x27;.btn1&#x27;) btn1.addEventListener(&#x27;click&#x27;, function () &#123; // 父节点 const ul = document.querySelector(&#x27;ul&#x27;) // 所有的子节点 console.log(ul.childNodes) // 只包含元素子节点 console.log(ul.children) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： childNodes 获取全部的子节点，回车换行会被认为是空白文本节点 children 只获取元素类型节点 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td width=&quot;60&quot;&gt;序号&lt;/td&gt; &lt;td&gt;课程名&lt;/td&gt; &lt;td&gt;难度&lt;/td&gt; &lt;td width=&quot;80&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;/td&gt; &lt;td&gt;初级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;/td&gt; &lt;td&gt;初级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;&lt;span&gt;Web APIs&lt;/span&gt;&lt;/td&gt; &lt;td&gt;中级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script&gt; // 获取所有 button 节点，并添加事件监听 const buttons = document.querySelectorAll(&#x27;table button&#x27;) for(let i = 0; i &lt; buttons.length; i++) &#123; buttons[i].addEventListener(&#x27;click&#x27;, function () &#123; // console.log(this.parentNode); // 父节点 td // console.log(this.parentNode.parentNode); // 爷爷节点 tr this.parentNode.parentNode.style.color = &#x27;red&#x27; &#125;) &#125; &lt;/script&gt;&lt;/body&gt; 结论：parentNode 获取父节点，以相对位置查找节点，实际应用中非常灵活。 兄弟关系12345678910111213141516171819202122&lt;body&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript 基础&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 获取所有 li 节点 const lis = document.querySelectorAll(&#x27;ul li&#x27;) // 对所有的 li 节点添加事件监听 for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].addEventListener(&#x27;click&#x27;, function () &#123; // 前一个节点 console.log(this.previousSibling) // 下一下节点 console.log(this.nextSibling) &#125;) &#125; &lt;/script&gt;&lt;/body&gt; 12345678910111213141516&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // const ul = document.querySelector(&#x27;ul&#x27;) // ul // console.log(ul.children) // 得到伪数组 选择的是 亲儿子 const li2 = document.querySelector(&#x27;ul li:nth-child(2)&#x27;) console.log(li2.previousElementSibling) // 上一个兄弟 console.log(li2.nextElementSibling) // 下一个兄弟 &lt;/script&gt;&lt;/body&gt; 结论： previousSibling 获取前一个节点，回车换行会被认为是空白文本节点 nextSibling 获取后一个节点，回车换行会被认为是空白文本节点 previousElementSibling 获取前一个节点，以相对位置查找节点，实际应用中非常灵活。 nextElementSibling 获取后一个节点，以相对位置查找节点，实际应用中非常灵活。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM事件基础","path":"/2024/01/16/DOM事件基础/","content":"事件监听结合 DOM 使用事件时，需要为 DOM 对象添加事件监听，等待事件发生（触发）时，便立即调用一个函数。 addEventListener 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为【事件类型】和【事件回调】。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;事件监听&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;事件监听&lt;/h3&gt; &lt;p id=&quot;text&quot;&gt;为 DOM 元素添加事件监听，等待事件发生，便立即执行一个函数。&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;点击改变文字颜色&lt;/button&gt; &lt;script&gt; // 1. 获取 button 对应的 DOM 对象 const btn = document.querySelector(&#x27;#btn&#x27;) // 2. 添加事件监听 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;等待事件被触发...&#x27;) // 改变 p 标签的文字颜色 let text = document.getElementById(&#x27;text&#x27;) text.style.color = &#x27;red&#x27; &#125;) // 3. 只要用户点击了按钮，事件便触发了！！！ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 完成事件监听分成3个步骤： 获取 DOM 元素 通过 addEventListener 方法为 DOM 节点添加事件监听 等待事件触发，如用户点击了某个按钮时便会触发 click 事件类型 事件触发后，相对应的回调函数会被执行 大白话描述：所谓的事件无非就是找个机会（事件触发）调用一个函数（回调函数）。&#x20; 事件类型将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等，我们逐一展开学习。 鼠标事件鼠标事件是指跟鼠标操作相关的事件，如单击、双击、移动等。 `mouseenter 监听鼠标是否移入 DOM 元素 123456789101112131415161718&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移入当前 DOM 元素 box.addEventListener(&#x27;mouseenter&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移入了...&#x27;; // 修改光标的风格 this.style.cursor = &#x27;move&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; 2.`mouseleave 监听鼠标是否移出 DOM 元素 12345678910111213141516&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移出当前 DOM 元素 box.addEventListener(&#x27;mouseleave&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移出了...&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; 键盘事件keydown 键盘按下触发keyup 键盘抬起触发 焦点事件focus 获得焦点 blur 失去焦点 文本框输入事件input 事件对象任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。 123456789101112131415161718&lt;body&gt; &lt;h3&gt;事件对象&lt;/h3&gt; &lt;p&gt;任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取 .box 元素 const box = document.querySelector(&#x27;.box&#x27;) // 添加事件监听 box.addEventListener(&#x27;click&#x27;, function (e) &#123; console.log(&#x27;任意事件类型被触发后，相关信息会以对象形式被记录下来...&#x27;); // 事件回调函数的第1个参数即所谓的事件对象 console.log(e) &#125;) &lt;/script&gt;&lt;/body&gt; 事件回调函数的【第1个参数】即所谓的事件对象，通常习惯性的将这个对数命名为 event、ev 、ev 。 接下来简单看一下事件对象中包含了哪些有用的信息： ev.type 当前事件的类型 ev.clientX/Y 光标相对浏览器窗口的位置 ev.offsetX/Y 光标相于当前 DOM 元素的位置 注：在事件回调函数内部通过 window.event 同样可以获取事件对象。 环境对象 能够分析判断函数运行在不同环境中 this 所指代的对象。 环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境。 123456789101112131415161718192021222324252627&lt;script&gt; // 声明函数 function sayHi() &#123; // this 是一个变量 console.log(this); &#125; // 声明一个对象 let user = &#123; name: &#x27;张三&#x27;, sayHi: sayHi // 此处把 sayHi 函数，赋值给 sayHi 属性 &#125; let person = &#123; name: &#x27;李四&#x27;, sayHi: sayHi &#125; // 直接调用 sayHi() // window window.sayHi() // window // 做为对象方法调用 user.sayHi()// user person.sayHi()// person&lt;/script&gt; 结论： this 本质上是一个变量，数据类型为对象 函数的调用方式不同 this 变量的值也不同 【谁调用 this 就是谁】是判断 this 值的粗略规则 函数直接调用时实际上 window.sayHi() 所以 this 的值为 window 回调函数如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数。 1234567891011121314151617&lt;script&gt; // 声明 foo 函数 function foo(arg) &#123; console.log(arg); &#125; // 普通的值做为参数 foo(10); foo(&#x27;hello world!&#x27;); foo([&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]); function bar() &#123; console.log(&#x27;函数也能当参数...&#x27;); &#125; // 函数也可以做为参数！！！！ foo(bar);&lt;/script&gt; 结论： 回调函数本质还是函数，只不过把它当成参数使用 使用匿名函数做为回调函数比较常见","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM事件进阶","path":"/2024/01/16/DOM事件进阶/","content":"事件流事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。 如上图所示，任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。 简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。 捕获和冒泡了解了什么是事件流之后，我们来看事件流是如何影响事件执行的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;); const inner = document.querySelector(&#x27;.inner&#x27;); const child = document.querySelector(&#x27;.child&#x27;); // html 元素添加事件 document.documentElement.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;html...&#x27;) &#125;) // body 元素添加事件 document.body.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;body...&#x27;) &#125;) // 外层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;) // 内层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;child...&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？ 结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。 再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。 如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。 如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。 12345678910111213141516171819202122&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;, true) // true 表示在捕获阶段执行事件 // 中间的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;, true) &lt;/script&gt;&lt;/body&gt; 结论： addEventListener 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发 addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false 事件流只会在父子元素具有相同事件类型时才会产生影响 绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获） 如果使用onclick方法，则只有冒泡阶段，没有捕获。 阻止冒泡1、阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;h3&gt;阻止冒泡&lt;/h3&gt; &lt;p&gt;阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) const child = document.querySelector(&#x27;.child&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子 inner.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;inner...&#x27;) // 阻止事件冒泡 ev.stopPropagation() &#125;) // 内层的盒子 child.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;child...&#x27;) // 借助事件对象，阻止事件向上冒泡 ev.stopPropagation() &#125;) &lt;/script&gt;&lt;/body&gt; 结论：事件对象中的 ev.stopPropagation 方法，专门用来阻止事件冒泡。 鼠标经过事件：mouseover 和 mouseout 会有冒泡效果mouseenter 和 mouseleave 没有冒泡效果 (推荐) 123456789101112131415&lt;body&gt; &lt;div class=&quot;dad&quot;&gt; &lt;div class=&quot;baby&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const dad = document.querySelector(&#x27;.dad&#x27;) const baby = document.querySelector(&#x27;.baby&#x27;) dad.addEventListener(&#x27;mouseover&#x27;, function () &#123; console.log(&#x27;鼠标经过&#x27;) &#125;) dad.addEventListener(&#x27;mouseout&#x27;, function () &#123; console.log(&#x27;鼠标离开&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 鼠标经过dad进入baby时，会打印三行 因为经过baby的时候，虽然baby没有绑定事件，但依然会冒泡至dad的mouseover方法。 2、我们某些情况下需要阻止元素的默认行为的发生，比如 阻止链接的跳转，表单域跳转。 e.preventDefault() 事件解绑onclick的解绑方法： 12345btn.onclick=function()&#123;alert(&#x27;点击了&#x27;)&#125;btn.onclick=null addeventlistener的解绑方法： 1234567function fn()&#123;alert(&#x27;点击了&#x27;)&#125;btn.addEventListener(&#x27;click&#x27;,fn)btn.removeEventListener(&#x27;click&#x27;,fn) 注：匿名函数无法被解绑 事件委托事件委托是利用事件流的特征解决一些现实开发需求的知识技巧，主要的作用是提升程序效率。 大量的事件监听是比较耗费性能的，如下代码所示 1234567891011&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;); for(let i = 0; i &lt;= buttons.length; i++) &#123; // 为 10000 个 button 元素添加了事件 buttons.addEventListener(&#x27;click&#x27;, function () &#123; // 省略具体执行逻辑... &#125;) &#125;&lt;/script&gt; 利用事件流的特征，可以对上述的代码进行优化，事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化，如下代码所示： 12345678910&lt;script&gt; // 假设页面中有 10000 个 button 元素 let buttons = document.querySelectorAll(&#x27;table button&#x27;); // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table let parents = document.querySelector(&#x27;table&#x27;); parents.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;点击任意子元素都会触发事件...&#x27;); &#125;)&lt;/script&gt; 我们的最终目的是保证只有点击 button 子元素才去执行事件的回调函数，如何判断用户点击是哪一个子元素呢？ 事件对象中的属性 target 或 srcElement属性表示真正触发事件的元素，它是一个元素类型的节点。 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul&gt; &lt;li&gt;第1个孩子&lt;/li&gt; &lt;li&gt;第2个孩子&lt;/li&gt; &lt;li&gt;第3个孩子&lt;/li&gt; &lt;li&gt;第4个孩子&lt;/li&gt; &lt;li&gt;第5个孩子&lt;/li&gt; &lt;p&gt;我不需要变色&lt;/p&gt; &lt;/ul&gt;&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;) // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table const parents = document.querySelector(&#x27;table&#x27;) parents.addEventListener(&#x27;click&#x27;, function (ev) &#123; // console.log(ev.target); // 只有 button 元素才会真正去执行逻辑 e.target.style.color=&#x27;red&#x27;//这么实现点击&lt;P&gt;标签时仍然会变色，无法实现只点击li才变色 if(ev.target.tagName === &#x27;BUTTON&#x27;) &#123; // 执行的逻辑 &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 优化过的代码只对祖先元素添加事件监听，相比对 10000 个元素添加事件监听执行效率要高许多！！！ tab切换的案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;tab栏切换&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .tab &#123; width: 590px; height: 340px; margin: 20px; border: 1px solid #e4e4e4; &#125; .tab-nav &#123; width: 100%; height: 60px; line-height: 60px; display: flex; justify-content: space-between; &#125; .tab-nav h3 &#123; font-size: 24px; font-weight: normal; margin-left: 20px; &#125; .tab-nav ul &#123; list-style: none; display: flex; justify-content: flex-end; &#125; .tab-nav ul li &#123; margin: 0 20px; font-size: 14px; &#125; .tab-nav ul li a &#123; text-decoration: none; border-bottom: 2px solid transparent; color: #333; &#125; .tab-nav ul li a.active &#123; border-color: #e1251b; color: #e1251b; &#125; .tab-content &#123; padding: 0 16px; &#125; .tab-content .item &#123; display: none; &#125; .tab-content .item.active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tab&quot;&gt; &lt;div class=&quot;tab-nav&quot;&gt; &lt;h3&gt;每日特价&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;javascript:;&quot; data-id=&quot;0&quot;&gt;精选&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;1&quot;&gt;美食&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;2&quot;&gt;百货&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;3&quot;&gt;个护&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;4&quot;&gt;预告&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;tab-content&quot;&gt; &lt;div class=&quot;item active&quot;&gt;&lt;img src=&quot;./assets/tab00.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab01.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab02.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab03.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab04.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //遍历 // const as=document.querySelectorAll(&#x27;.tab-nav a&#x27;) // for(let i=0;i&lt;as.length;i++)&#123; // as[i].addEventListener(&#x27;mouseenter&#x27;,function()&#123; // document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) // as[i].classList.add(&#x27;active&#x27;) // document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) // document.querySelector(`.tab-content .item:nth-child($&#123;i+1&#125;)`).classList.add(&#x27;active&#x27;) // &#125;) // &#125; //事件委托 const ul=document.querySelector(&#x27;.tab-nav ul&#x27;) ul.addEventListener(&#x27;click&#x27;,function(e)&#123; if(e.target.tagName===&#x27;A&#x27;)&#123; document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) e.target.classList.add(&#x27;active&#x27;) const id=+e.target.dataset.id document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) document.querySelector(`.tab-content .item:nth-child($&#123;id+1&#125;)`).classList.add(&#x27;active&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其他事件1. 页面加载事件加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 有些时候需要等页面资源全部处理完了做一些事情 事件名：load监听页面所有资源加载完毕： 123window.addEventListener(&#x27;load&#x27;, function() &#123; // xxxxx&#125;) 事件名：DOMContentLoaded监听页面DOM加载完毕， 无需等待样式表、图像等完全加载。 12document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;&#125;) 2. 元素滚动事件滚动条在滚动的时候持续触发的事件 123window.addEventListener(&#x27;scroll&#x27;, function() &#123; // xxxxx&#125;) 3. 获取位置开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素。 document.documentElement.scrollTop 12345window.addEventListener(&#x27;scroll&#x27;, function() &#123; // xxxxx const n=document.documentElement.scrollTop console.log(n)&#125;) 4. 页面尺寸事件会在窗口尺寸改变的时候触发事件： 123window.addEventListener(&#x27;resize&#x27;, function() &#123; // xxxxx&#125;) 5. 元素尺寸与位置获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 事件名：load 获取元素的可见部分宽高获取元素的可见部分宽高（不包含边框，margin，滚动条等）&#x20; clientWidth和clientHeight rem基准值 flexible.js的源码分析 获取元素的自身宽高获取宽高： 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 获取位置： 获取元素距离自己定位父级元素的左、上距离 offsetLeft和offsetTop 注意是只读属性 获取元素相对于当前视口的宽高element.getBoundingClientRect() 滚动导航栏123456789101112131415161718192021222324&lt;body&gt; &lt;div class=&quot;header&quot;&gt;我是顶部导航栏&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;sk&quot;&gt;秒杀模块&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;backtop&quot;&gt; &lt;img src=&quot;./images/close2.png&quot; alt=&quot;&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; window.addEventListener(&#x27;scroll&#x27;, function () &#123; const n = document.documentElement.scrollTop const sk = document.querySelector(&#x27;.sk&#x27;) const header=document.querySelector(&#x27;.header&#x27;) console.log(n) if (n &gt;= sk.offsetTop) &#123; header.style.top = 0 &#125; else &#123; header.style.top = &#x27;-80px&#x27;//这里一定要加单位 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM操作","path":"/2024/01/16/DOM操作/","content":"DOM（Document Object Model）是将整个 HTML 文档的每一个标签元素视为一个对象，这个对象下包含了许多的属性和方法，通过操作这些属性或者调用这些方法实现对 HTML 的动态更新，为实现网页特效以及用户交互提供技术支撑。 简言之 DOM 是用来动态修改 HTML 的，其目的是开发网页特效及用户交互。 概念DOM 树 DOM 节点节点是文档树的组成部分，每一个节点都是一个 DOM 对象，主要分为元素节点、属性节点、文本节点等。 【元素节点】其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点。 【属性节点】是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性。 【文本节点】是指 HTML 标签的文字内容，如 title 标签中的文字。 【根节点】特指 html 标签。 其它… documentdocument 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，document 是学习 DOM 的核心。 1234567891011&lt;script&gt; // document 是内置的对象 // console.log(typeof document); // 1. 通过 document 获取根节点 console.log(document.documentElement); // 对应 html 标签 // 2. 通过 document 节取 body 节点 console.log(document.body); // 对应 body 标签 // 3. 通过 document.write 方法向网页输出内容 document.write(&#x27;Hello World!&#x27;); &lt;/script&gt; 上述列举了 document 对象的部分属性和方法，我们先对 document 有一个整体的认识 获取dom对象 querySelector 满足条件的第一个元素 querySelectorAll 满足条件的元素集合 返回伪数组 了解其他方式 getElementById getElementsByTagName 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;DOM - 查找节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;查找元素类型节点&lt;/h3&gt; &lt;p&gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const p = document.querySelector(&#x27;p&#x27;) // 获取第一个p元素 const lis = document.querySelectorAll(&#x27;li&#x27;) // 获取第一个p元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结： document.getElementById 专门获取元素类型节点，根据标签的 id 属性查找 任意 DOM 对象都包含 nodeType 属性，用来检检测节点类型 操作元素内容操作元素内容通过修改 DOM 的文本内容，动态改变网页的内容。 innerText 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签不会被解析。1234567&lt;script&gt;// innerText 将文本内容添加/更新到任意标签位置const intro = document.querySelector(&#x27;.intro&#x27;)// intro.innerText = &#x27;嗨~ 我叫李雷！&#x27;// intro.innerText = &#x27;&lt;h4&gt;嗨~ 我叫李雷！&lt;/h4&gt;&#x27;&lt;/script&gt; innerHTML 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签会被解析。12345678&lt;script&gt;// innerHTML 将文本内容添加/更新到任意标签位置const intro = document.querySelector(&#x27;.intro&#x27;)intro.innerHTML = &#x27;嗨~ 我叫韩梅梅！&#x27;intro.innerHTML = &#x27;&lt;h4&gt;嗨~ 我叫韩梅梅！&lt;/h4&gt;&#x27;&lt;/script&gt; 总结：如果文本内容中包含 html 标签时推荐使用 innerHTML，否则建议使用 innerText 属性。 操作元素属性 有3种方式可以实现对属性的修改： 常用属性修改 直接能过属性名修改，最简洁的语法12345678910&lt;script&gt;// 1. 获取 img 对应的 DOM 元素const pic = document.querySelector(&#x27;.pic&#x27;)// 2. 修改属性pic.src = &#x27;./images/lion.webp&#x27;pic.width = 400;pic.alt = &#x27;图片不见了...&#x27;&lt;/script&gt; 控制样式属性 应用【修改样式】，通过修改行内样式 style 属性，实现对样式的动态修改。 通过元素节点获得的 style 属性本身的数据类型也是对象，如 box.style.color、box.style.width 分别用来获取元素节点 CSS 样式的 color 和 width 的值。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.style.color = &#x27;red&#x27; box.style.width = &#x27;300px&#x27; // css 属性的 - 连接符与 JavaScript 的 减运算符 // 冲突，所以要改成驼峰法 box.style.backgroundColor = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 css 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，如 background-color 要写成 box.style.backgroundColor 操作类名(className) 操作CSS 如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt; &lt;style&gt; .pink &#123; background: pink; color: hotpink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.className = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 1.由于class是关键字, 所以使用className去代替 2.className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名 通过 classList 操作类控制CSS 为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 200px; background-color: pink; &#125; .active &#123; width: 300px; height: 300px; background-color: hotpink; margin-left: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;script&gt; // 1.获取元素 // let box = document.querySelector(&#x27;css选择器 let box = document.querySelector(&#x27;div&#x27;) // add是个方法 添加 追加 // box.classList.add(&#x27;active&#x27;) // remove() 移除 类 // box.classList.remove(&#x27;one&#x27;) // 切换类，有就删掉，没有就加上 box.classList.toggle(&#x27;one&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作表单元素属性表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 正常的有属性有取值的跟其他的标签属性没有任何区别 获取:DOM对象.属性名 设置:DOM对象.属性名&#x3D; 新值 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;请输入&quot;&gt; &lt;button disabled&gt;按钮&lt;/button&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;agree&quot;&gt; &lt;script&gt; // 1. 获取元素 let input = document.querySelector(&#x27;input&#x27;) // 2. 取值或者设置值 得到input里面的值可以用 value // console.log(input.value) input.value = &#x27;小米手机&#x27; input.type = &#x27;password&#x27; // 2. 启用按钮 let btn = document.querySelector(&#x27;button&#x27;) // disabled 不可用 = false 这样可以让按钮启用 btn.disabled = false // 3. 勾选复选框 let checkbox = document.querySelector(&#x27;.agree&#x27;) checkbox.checked = false &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 自定义属性标准属性: 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作比如： disabled、checked、selected 自定义属性： 在html5中推出来了专门的data-自定义属性 &#x20; 在标签上一律以data-开头 在DOM对象上一律以dataset对象方式获取 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div data-id=&quot;1&quot;&gt; 自定义属性 &lt;/div&gt; &lt;script&gt; // 1. 获取元素 let div = document.querySelector(&#x27;div&#x27;) // 2. 获取自定义属性值 console.log([div.dataset.id](http://div.dataset.id)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定时器间歇函数知道间歇函数的作用，利用间歇函数创建定时任务。 setInterval 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数。 12345678910&lt;script&gt; // 1. 定义一个普通函数 function repeat() &#123; console.log(&#x27;不知疲倦的执行下去....&#x27;) &#125; // 2. 使用 setInterval 调用 repeat 函数 // 间隔 1000 毫秒，重复调用 repeat setInterval(repeat, 1000) clearInterval(repeat)//关闭定时器&lt;/script&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript对象","path":"/2024/01/16/对象/","content":"遍历对象for 遍历对象的问题： 对象没有像数组一样的length属性,所以无法确定长度 对象里面是无序的键值对, 没有规律. 不像数组里面有规律的下标 forin: 123456789101112131415// 1. 遍历对象 for in let obj = &#123; uname: &#x27;pink老师&#x27;, age: 18, gender: &#x27;男&#x27; &#125; // 2. 遍历对象 for (let k in obj) &#123; console.log(k) // 属性名 &#x27;uname&#x27; &#x27;age&#x27; // console.log(obj.uname) // console.log(obj.k) // console.log(obj.&#x27;uname&#x27;) // console.log(obj[&#x27;uname&#x27;]) &#x27;uname&#x27; === k console.log(obj[k]) // 输出属性值 obj[k] &#125; 内置对象回想一下我们曾经使用过的 console.log，console其实就是 JavaScript 中内置的对象，该对象中存在一个方法叫 log，然后调用 log 这个方法，即 console.log()。 除了 console 对象外，JavaScritp 还有其它的内置的对象 MathMath 是 JavaScript 中内置的对象，称为数学对象，这个对象下即包含了属性，也包含了许多的方法。 属性 Math.PI，获取圆周率 &#x2F;&#x2F; 圆周率 &#x20; console.log(Math.PI); 方法 Math.random，生成 0 到 1 间的随机数 &#x2F;&#x2F; 0 ~ 1 之间的随机数, 包含 0 不包含 1 &#x20; Math.random() Math.ceil，数字向上取整 &#x2F;&#x2F; 舍弃小数部分，整数部分加1 &#x20; Math.ceil(3.4) Math.floor，数字向下取整 &#x2F;&#x2F; 舍弃小数部分，整数部分不变 &#x20; Math.floor(4.68) Math.round，四舍五入取整 &#x2F;&#x2F; 取整，四舍五入原则 &#x20; Math.round(5.46539) &#x20; Math.round(4.849) Math.round(-1.5) -1 Math.max，在一组数中找出最大的 &#x2F;&#x2F; 找出最大值 &#x20; Math.max(10, 21, 7, 24, 13) Math.min，在一组数中找出最小的 &#x2F;&#x2F; 找出最小值 &#x20; Math.min(24, 18, 6, 19, 21) Math.pow，幂方法 &#x2F;&#x2F; 求某个数的多少次方 &#x20; Math.pow(4, 2) &#x2F;&#x2F; 求 4 的 2 次方 &#x20; Math.pow(2, 3) &#x2F;&#x2F; 求 2 的 3 次方 Math.sqrt，平方根 &#x2F;&#x2F; 求某数的平方根 &#x20; Math.sqrt(16) DateECMAScript 中内置了获取系统时间的对象 Date，使用 Date 时与之前学习的内置对象 console 和 Math 不同，它需要借助 new 关键字才能使用。 实例化123456// 1. 实例化// const date = new Date(); // 系统默认时间const date = new Date(&#x27;2020-05-01&#x27;) // 指定时间// date 变量即所谓的时间对象console.log(typeof date) 方法123456// 1. 实例化 const date = new Date(); // 2. 调用时间对象方法 // 通过方法分别获取年、月、日，时、分、秒 const year = date.getFullYear(); // 四位年份 const month = date.getMonth(); // 0 ~ 11 getFullYear 获取四位年份 getMonth 获取月份，取值为 0 ~ 11 getDate 获取月份中的每一天，不同月份取值也不相同 getDay 获取星期，取值为 0 ~ 6 getHours 获取小时，取值为 0 ~ 23 getMinutes 获取分钟，取值为 0 ~ 59 getSeconds 获取秒，取值为 0 ~ 59 时间戳时间戳是指1970年01月01日00时00分00秒起至现在的总秒数或毫秒数，它是一种特殊的计量时间的方式。 注：ECMAScript 中时间戳是以毫秒计的。 12345678 // 1. 实例化 const date = new Date() // 2. 获取时间戳 console.log(date.getTime())// 还有一种获取时间戳的方法 console.log(+new Date()) // 还有一种获取时间戳的方法,这个方法只能获得当前的时间戳 console.log(Date.now()) 获取时间戳的方法，分别为 getTime 和 Date.now 和 +new Date()","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript函数","path":"/2024/01/16/函数/","content":"作用域作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件 处于全局作用域内的变量，称为全局变量 局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。 处于局部作用域内的变量称为局部变量 如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐 但是有一种情况，函数内部的形参可以看做是局部变量。 具名函数声明：function fn() {} 调用：fn() 匿名函数函数可以分为具名函数和匿名函数 匿名函数：没有名字的函数,无法直接使用。可以通过函数表达式和立即执行函数来使用。 函数表达式&#x2F;&#x2F; 声明 &#x20; let fn &#x3D; function() { &#x20; console.log(‘函数表达式’) &#x20; } &#x20; &#x2F;&#x2F; 调用 &#x20; fn() 立即执行函数用于避免全局变量之间的污染 (function(){ xxx })(); &#x20; (function(){xxxx}()); 无需调用，立即执行，其实本质已经调用了 多个立即执行函数之间用分号隔开 逻辑中断短路：只存在于 &amp;&amp; 和 || 中，当满足一定条件会让右边代码不执行 原因：通过左边能得到整个式子的结果，因此没必要再判断右边 运算结果：无论 &amp;&amp; 还是 || ，运算结果都是最后被执行的表达式值，一般用在变量赋值","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript数组","path":"/2024/01/16/数组/","content":"常用api增加元素arr.push push() 方法将指定的元素添加到数组的末尾，并返回新的数组长度。会修改原有数组。 arr.concat([v1,v2]) concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 arr.unshift（v1,v2） unshift() 方法将指定元素添加到数组的开头，并返回数组的新长度。 删除元素arr.splice(start, deleteCount, item1, item2, itemN) splice() 方法通过移除或者替换已存在的元素和&#x2F;或添加新元素就地改变一个数组的内容。 arr.toSpliced() Array 实例的 toSpliced() 方法是 splice() 方法的复制版本。它返回一个新数组，并在给定的索引处删除和&#x2F;或替换了一些元素。 arr.pop() pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。 arr.shift() shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 复制arr.copyWithin(target, start, end) copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。 123456789const array1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];// Copy to index 0 the element at index 3console.log(array1.copyWithin(0, 3, 4));// Expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]// Copy to index 1 all elements from index 3 to the endconsole.log(array1.copyWithin(1, 3));// Expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;] 填充arr.fill(value,start,end) fill() 方法用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组。 反转arr.reverse() reverse() 方法就地反转数组中的元素，并返回同一数组的引用。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。换句话说，数组中的元素顺序将被翻转，变为与之前相反的方向。 arr.toReversed() Array 实例的 toReversed() 方法是 reverse() 方法对应的复制版本。它返回一个元素顺序相反的新数组。 排序arr.sort() sort() 方法就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。 arr.toSorted() Array 实例的 toSorted() 方法是 sort() 方法的复制方法版本。它返回一个新数组，其元素按升序排列。 数组map 方法使用场景： map 可以遍历数组处理数据，并且返回新的数组 语法： 123456789101112&lt;body&gt; &lt;script&gt; const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) &#123; // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + &#x27;颜色&#x27; &#125;)console.log(newArr)&lt;/script&gt;&lt;/body&gt; map 也称为映射。映射是个术语，指两个元素的集之间元素相互“对应”的关系。 map重点在于有返回值，forEach没有返回值（undefined） 数组join方法作用： join() 方法用于把数组中的所有元素转换一个字符串 语法： 1234567891011121314151617181920&lt;body&gt; &lt;script&gt; const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) &#123; // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + &#x27;颜色&#x27; &#125;) console.log(newArr) // 2. 数组join方法 把数组转换为字符串 // 小括号为空则逗号分割 console.log(newArr.join()) // red颜色,blue颜色,pink颜色 // 小括号是空字符串，则元素之间没有分隔符 console.log(newArr.join(&#x27;&#x27;)) //red颜色blue颜色pink颜色 console.log(newArr.join(&#x27;|&#x27;)) //red颜色|blue颜色|pink颜色 &lt;/script&gt;&lt;/body&gt; forEach遍历数组forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 注意： 1.forEach 主要是遍历数组 2.参数当前数组元素是必须要写的， 索引号可选。 1234567891011&lt;body&gt; &lt;script&gt; // forEach 就是遍历 加强版的for循环 适合于遍历数组对象 const arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;] const result = arr.forEach(function (item, index) &#123; console.log(item) // 数组元素 red green pink console.log(index) // 索引号 &#125;) // console.log(result) &lt;/script&gt;&lt;/body&gt; filter筛选数组filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组 1234567891011121314&lt;body&gt; &lt;script&gt; const arr = [10, 20, 30] // const newArr = arr.filter(function (item, index) &#123; // // console.log(item) // // console.log(index) // return item &gt;= 20 // &#125;) // 返回的符合条件的新数组 const newArr = arr.filter(item =&gt; item &gt;= 20) console.log(newArr) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript运算","path":"/2024/01/16/运算/","content":"模板字符串document.write(大家好，我叫$&#123;uname&#125;， 我今年贵庚$&#123;age&#125;岁了) 比较运算符如果相等操作符两边的操作数，不包含 null 或者 undefined，且两个操作数不全是对象，在执行相等比较之前，会先调用 Number() 将两个操作数强制转为 Number 类型，然后进行比较。 转换规则：在比较运算符时会优先转换操作数（强制转换），然后再进行比较。 &#x20;第一步：如果有一个操作数类型为布尔值，则在比较相等之前将其转换为数值类型，即 false &#x3D;&gt; 0, true &#x3D;&gt; 1; &#x20;第二步：如果一个操作数是字符串，另一个是数值，在比较前先将字符串转换成数值 &#x20;第三步：在双等号对比时，左右类型相等的情况下，采用三等号的方式进行比较，严格的运算符判定规则 基本数据类型： 如果有一个操作数是（number，string，Boolean），则在比较相等性之前，将其转换为数值; 在比较相等性之前，不能将 null 和 undefined 转成其他值，且null 和 undefined 是相等的。 如果有一个操作数是 NaN，则都返回 false；（NaN不与任何相等，包括NaN） 123456&#x27;55&#x27; == 55; //true （ Number(&#x27;55&#x27;) -&gt; 55 ）&#x27;1.232&#x27;==1.232; //truefalse == 0; //true （ Number(false ) -&gt; 0 ）&quot;wise&quot; == 3; //false （ Number(&quot;wise&quot;) -&gt; NaN ）[] == 0; //true （ Number([]) -&gt; 0 ） 复杂数据类型： 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；&#x20; 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true； 123456NaN == NaN; //false （参考第4条规则）[] == []; //false[] == ![]; //true&#123;&#125; == &#123;&#125;; //false&#123;&#125; == !&#123;&#125;; //false [] &#x3D;&#x3D; [] 和 {} &#x3D;&#x3D; {}在 JavaScript 中，Object、Array、Function、RegExp、Date 都是引用类型。声明引用类型的时候，变量名保存在 js 的栈内存里面，而对应的值保存在堆内存里面。而这个变量在栈内存中实际保存的是：这个值在堆内存中的地址，也就是指针。 12345678var a = &#123;&#125;;var b = &#123;&#125;;var c = b;a == b; //false（变量a,b保存的分别是a,b的指针，它们指向不同的对象）b == c; //true（变量c保存的是b的指针，它们指向同一个对象）注意：如果两个对象指向同一个对象，相等操作符返回 true，否则则为false [] &#x3D;&#x3D; ![] 和 {} &#x3D;&#x3D; !{}逻辑非 (!) 的优先级高于相等操作符 ( &#x3D;&#x3D; ) 1234567891011121314151617181920[] == ![] //![] == false -&gt;Number([]) == Number(false) -&gt; 0 == 0 -&gt; true&#123;&#125; == !&#123;&#125; //!&#123;&#125; == false -&gt; Number(&#123;&#125;) == Number(false) -&gt; NaN == 0 -&gt; false注意：转布尔值==》Boolean() 代表空、否定的值会被转换为 false ，如 &#x27;&#x27;、0、NaN、null、undefined转数字类型：Number(false) // 0;Number(true) // 1;Number(&#x27;&#x27;) // 0;Number(&#x27;12&#x27;) // 12;Number(&#x27;sda&#x27;) // NaN;Number([1,2]) // NaN;Number(&#123;&#125;) // NaN; 转换对象都是NaNNumber(NaN) // NaN;Number(!NaN) // 1;Number(null) // 0;Number(!null) // 1;Number(!undefined) // 1;Number(undefined) // NaN; 数组与数值数组会先通过调用toString()转换为字符串后再转换为数值，比如[true]转换为字符串后为”true”，然后再转换为数值是NaN，所以[true]&#x3D;&#x3D;1返回false。 12345678console.log([]==0); // trueconsole.log([1]==1); // trueconsole.log([&quot;1&quot;]==1); // trueconsole.log([1,2]==1); // falseconsole.log([true]==1); // falseNumber([&#x27;a&#x27;]) // NaN;[&#x27;1&#x27;] == 1 // true; null &#x3D;&#x3D; 0 、null &gt;&#x3D; 0 、null &gt; 01.关系运算符知 和 相等运算符 并不是一个类别的.2.关系运算符，在设计上总是需要运算元道尝试转为一个number，而相等运算符在设计上，则没有这方面的考虑. 12345678910null==0 //false//解释：null在设计上，对比等于的时候不尝试转型. null和0不转型的话，是不会相等的, 所以null == 0结果为false.（在JavaScript旧版源代码中，没有相匹配的项，最后返回末尾的false。）null &gt; 0 // false// 对比大于或小于的时候, null 会尝试转型为number , 转化之后null为0, 0&gt;0是错误的,所以结果为 false.null&gt;=0 // truenull&lt;=0 // true//对比 大于等于 或 小于等于 的时候, 会先判断大于或小于,转型为number,0&gt;0是错误的,但是0=0是正确的, 这是 “或” 的判断, 所以结果为 true 特殊情况： NAN&#x3D;&#x3D;&#x3D;NAN（false） 0.1+0.2&#x3D;&#x3D;&#x3D;0.3（false）js的小数加法存在精度问题 null&#x3D;&#x3D;undefined(true) null&#x3D;&#x3D;&#x3D;undefined(false) []&#x3D;&#x3D;[](false) []&#x3D;&#x3D;&#x3D;[] (false) undefined进行比较时，是作为对象，转化为NaN来处理。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"BFC","path":"/2024/01/16/9.BFC/","content":"9.1 BFC的定义W3C 上对 BFC 的定义： 译文：浮动、绝对定位元素、不是块盒子的块容器（如 inline-blocks 、 table-cells 和table-captions ），以及 overflow 属性的值除 visible 以外的块盒，将为其内容建立新的块格式化上下文。 MDN 上对 BFC 的描述： 块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 更加通俗的描述： BFC 是 Block Formatting Context （块级格式上下文），可以理解成元素的一个“特异功能”。 &#x20;该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活。 所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）。 9.2 开启了BFC能解决什么问题 元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题。 元素开启 BFC 后，自己不会被其他浮动元素所覆盖。 元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷。 9.3 如何开启BFC 根元素 浮动元素 绝对定位、固定定位的元素 行内块元素 表格单元格： table 、 thead 、 tbody 、 tfoot 、 th 、 td 、 tr 、 caption overflow 的值不为 visible 的块元素 伸缩项目 多列容器 column-span 为 all 的元素（即使该元素没有包裹在多列容器中） display 的值，设置为 flow-root 例子1：解决margin塌陷问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_BFC_演示1&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; /* display: flex; */ &#125; .outer &#123; width: 400px; background-color: #888; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ /* display: flow-root; */ &#125; .inner &#123; width: 100px; height: 100px; margin: 20px; &#125; .inner1 &#123; background-color: orange; &#125; .inner2 &#123; background-color: green; &#125; .inner3 &#123; background-color: deepskyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;hr style=&quot;height: 50px; background-color: red;&quot;&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 例子2：解决float元素遮挡问题 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_BFC_演示2&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; &#125; .box1 &#123; background-color: orange; float: left; &#125; .box2 &#123; background-color: green; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ /* display: flow-root; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 例子3：解决子元素浮动，父元素高度塌陷问题 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_BFC_演示3&lt;/title&gt; &lt;style&gt; .outer &#123; width: 400px; background-color: #888; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ display: flow-root; &#125; .inner &#123; width: 100px; height: 100px; float: left; &#125; .inner1 &#123; background-color: orange; &#125; .inner2 &#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"响应式布局","path":"/2024/01/16/8.响应式布局/","content":"8.1 媒体查询1.媒体类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_媒体查询_媒体类型&lt;/title&gt; &lt;style&gt; h1 &#123; width: 600px; height: 400px; line-height: 400px; background-image: linear-gradient(30deg,red,yellow,green); margin: 0 auto; text-align: center; font-size: 100px; color: white; text-shadow: 0 0 10px black; &#125; /* 只有在打印机或打印预览才应用的样式 */ @media print &#123; h1 &#123; background: transparent; &#125; &#125; /* 只有在屏幕上才应用的样式 */ @media screen &#123; h1 &#123; font-family: &quot;翩翩体-简&quot;; &#125; &#125; /* 一直都应用的样式 */ @media all &#123; h1 &#123; color: red; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;新年快乐&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.媒体特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_媒体查询_媒体特性&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; h1 &#123; height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; &#125; /* 检测到视口的宽度为800px时，应用如下样式 */ @media (width:800px) &#123; h1 &#123; background-color: green; &#125; &#125; /* 检测到视口的宽度小于等于700px时，应用如下样式 */ @media (max-width:700px) &#123; h1 &#123; background-color: orange; &#125; &#125; /* 检测到视口的宽度大于等于900px时，应用如下样式 */ @media (min-width:900px) &#123; h1 &#123; background-color: deepskyblue; &#125; &#125; /* 检测到视口的高度等于800px时，应用如下样式 */ /* @media (height:800px)&#123; h1 &#123; background-color: yellow; &#125; &#125; */ /* 检测到屏幕的宽度等于1536px时，应用如下样式 */ /* @media (device-width:1536px) &#123; h1 &#123; color: white; &#125; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好啊&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3.运算符 only为了处理ie的兼容性问题。让ie直接不认识。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_媒体查询_运算符&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; h1 &#123; height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; &#125; /* 且运算符 */ /* @media (min-width:700px) and (max-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* @media screen and (min-width:700px) and (max-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 或运算符 */ /* @media screen and (max-width:700px) or (min-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 否定运算符 */ /* @media not screen &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 肯定运算符 */ @media only screen and (width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好啊&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 4.常用阈值 5.结合外部样式的写法用法一： 1&lt;link rel=&quot;stylesheet&quot; media=&quot;具体的媒体查询&quot; href=&quot;mystylesheet.css&quot;&gt; 用法二： 123@media screen and (max-width:768px) &#123;/CSS-Code;/&#125;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"伸缩盒模型","path":"/2024/01/16/7.伸缩盒模型/","content":"传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float属性。 flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上 1.伸缩容器、伸缩项目 伸缩容器： 开启了 flex 的元素，就是：伸缩容器。 给元素设置： display:flex 或 display:inline-flex ，该元素就变为了伸缩容器。 display:inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器。 一个元素可以同时是：伸缩容器、伸缩项目。 伸缩项目：伸缩容器所有子元素自动成为了：伸缩项目。 仅伸缩容器的子元素成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目。 无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”。 2.主轴与侧轴主轴： 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）。 侧轴： 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）。 3.主轴方向属性名： flex-direction 常用值如下： row ：主轴方向水平从左到右 —— 默认值 row-reverse ：主轴方向水平从右到左。 column ：主轴方向垂直从上到下。 column-reverse ：主轴方向垂直从下到上 注意：改变了主轴的方向，侧轴方向也随之改变。 4.主轴换行方式属性名： flex-wrap 常用值如下： nowrap ：默认值，不换行。 wrap ：自动换行，伸缩容器不够自动换行。 wrap-reverse ：反向换行。 5.flex-flowflex-flow 是一个复合属性，复合了 flex-direction 和 flex-wrap 两个属性。 值没有顺序要求。 flex-flow: row wrap; 6.主轴对齐方式属性名： justify-content 常用值如下： flex-start ：主轴起点对齐。—— 默认值 flex-end ：主轴终点对齐。 center ：居中对齐 space-between ：均匀分布，两端对齐（最常用）。 space-around ：均匀分布，两端距离是中间距离的一半。 space-evenly ：均匀分布，两端距离与中间距离一致。 7.侧轴对齐方式7.1 一行的情况所需属性： align-items 常用值如下： flex-start ：侧轴的起点对齐。 flex-end ：侧轴的终点对齐。 center ：侧轴的中点对齐。 baseline : 伸缩项目的第一行文字的基线对齐。 stretch ：如果伸缩项目未设置高度，将占满整个容器的高度。—— （默认值） 7.2 多行的情况所需属性： align-content 常用值如下： flex-start ：与侧轴的起点对齐。 flex-end ：与侧轴的终点对齐。 center ：与侧轴的中点对齐。 space-between ：与侧轴两端对齐，中间平均分布。 space-around ：伸缩项目间的距离相等，比距边缘大一倍。 space-evenly : 在侧轴上完全平分。 stretch ：占满整个侧轴。—— 默认值 flex-start 8.伸缩性8.1 flex-basis 概念： flex-basis 设置的是主轴方向的基准长度，会让宽度或高度失效。 备注：主轴横向：宽度失效；主轴纵向：高度失效 作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值 auto ，即：伸缩项目的宽或高。 8.2 flex-grow（伸） 概念： flex-grow 定义伸缩项目的放大比例，默认为 0 ，即：纵使主轴存在剩余空间，也不拉伸（放大）。 规则： 若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）。 若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1&#x2F;6 、 2&#x2F;6 、3&#x2F;6 的空间。 8.3 flex-shrink（缩） 概念： flex-shrink 定义了项目的压缩比例，默认为 1 ，即：如果空间不足，该项目将会缩小。 收缩项目的计算，略微复杂一点，我们拿一个场景举例： 例如： 三个收缩项目，宽度分别为： 200px 、 300px 、 200px ，它们的 flex-shrink 值分别 为： 1 、 2 、 3 若想刚好容纳下三个项目，需要总宽度为 700px ，但目前容器只有 400px ，还差300px 所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算： 计算分母： (200×1) + (300×2) + (200×3) &#x3D; 1400 计算比例： 项目一： (200×1) &#x2F; 1400 &#x3D; 比例值1 项目二： (300×2) &#x2F; 1400 &#x3D; 比例值2 计算最终收缩大小： 项目一需要收缩： 比例值1 × 300 项目二需要收缩： 比例值2 × 300 项目三需要收缩： 比例值3 × 300 9. flex复合属性flex 是复合属性，复合了： flex-grow 、 flex-shrink 、 flex-basis 三个属性，默认值为 0 1 auto 。 如果写 flex:1 1 auto ，则可简写为： flex:auto 如果写 flex:1 1 0 ，则可简写为： flex:1 如果写 flex:0 0 auto ，则可简写为： flex:none 如果写 flex:0 1 auto ，则可简写为： flex:0 auto —— 即 flex 初始值。 10. 项目排序order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 。 11. 单独对齐通过 align-self 属性，可以单独调整某个伸缩项目的对齐方式 默认值为 auto ，表示继承父元素的 align-items 属性。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"多列布局","path":"/2024/01/16/6.多列布局/","content":"作用：专门用于实现类似于报纸的布局。 常用属性如下： column-count ：指定列数，值是数字。 column-width ：指定列宽，值是长度。 columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求。 column-gap ：设置列边距，值是长度。 column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致。 column-rule-width ：设置列与列之间边框的宽度，值是长度。 column-rule-color ：设置列与列之间边框的颜色。 coumn-rule ：设置列边框，复合属性。 column-span 指定是否跨列；值: none 、 all 。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"动画","path":"/2024/01/16/5.动画/","content":"5.1 基本使用第一步：定义关键帧（定义动画） 简单方式定义： 12345678910/*写法一*/@keyframes 动画名 &#123;from &#123;/*property1:value1*//*property2:value2*/&#125;to &#123;/*property1:value1*/&#125;&#125; 完整方式定义： 1234567891011121314151617181920@keyframes 动画名 &#123;0% &#123;/*property1:value1*/&#125;20% &#123;/*property1:value1*/&#125;40% &#123;/*property1:value1*/&#125;60% &#123;/*property1:value1*/&#125;80% &#123;/*property1:value1*/&#125;100% &#123;/*property1:value1*/&#125;&#125; 第二步：给元素应用动画，用到的属性如下： animation-name ：给元素指定具体的动画（具体的关键帧） animation-duration ：设置动画所需时间 animation-delay ：设置动画延迟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_基本使用&lt;/title&gt; &lt;style&gt; .outer &#123; width: 1000px; height: 100px; border: 1px solid black; &#125; /* 定义一个动画（定义一组关键帧）—— 第一种方式 */ @keyframes wangyoudong &#123; /* 第一帧 */ from &#123; &#125; /* 最后一帧 */ to &#123; transform: translate(900px); background-color: red; &#125; &#125; /* 定义一个动画（定义一组关键帧）—— 第二种方式 */ @keyframes wangyoudong2 &#123; /* 第一帧 */ 0% &#123; &#125; /* 29% &#123; background-color: red; &#125; */ /* 48% &#123; background-color: orange; &#125; */ /* 88% &#123; background-color: yellow; &#125; */ /* 最后一帧 */ 100% &#123; transform: translate(900px) rotate(360deg); background-color: purple; border-radius: 50%; &#125; &#125; .inner &#123; width: 100px; height: 100px; background-color: deepskyblue; /* 应用动画到元素 */ animation-name: wangyoudong2; /* 动画持续的时间 */ animation-duration: 3s; /* 动画延迟时间 */ animation-delay: 0.2s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.2 动画的其他属性 animation-timing-function ，设置动画的类型，常用值如下： ease ： 平滑动画 —— 默认值 linear ： 线性过渡 ease-in ： 慢 → 快 ease-out ： 快 → 慢 ease-in-out ： 慢 → 快 → 慢 step-start ： 等同于 steps(1, start) step-end ： 等同于 steps(1, end) steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。 cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。 animation-iteration-count ，指定动画的播放次数，常用值如下： number ：动画循环次数 infinite ： 无限循环 animation-direction ，指定动画方向，常用值如下： normal ： 正常方向 (默认) reverse ： 反方向运行 alternate ： 动画先正常运行再反方向运行，并持续交替运行 alternate-reverse ： 动画先反运行再正方向运行，并持续交替运行 animation-fill-mode ，设置动画之外的状态 forwards ： 设置对象状态为动画结束时的状态 backwards ： 设置对象状态为动画开始时的状态 animation-play-state ，设置动画的播放状态，常用值如下： running ： 运动 (默认) paused ： 暂停 5.3动画复合属性只设置一个时间表示 duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求。 备注： animation-play-state 一般单独使用。 123.inner &#123;animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards;&#125;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"过渡","path":"/2024/01/16/4.过渡/","content":"4.1. transition-property作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会以有过渡 效果。 常用值： none ：不过渡任何属性。 all ：过渡所有能过渡的属性。 具体某个属性名 ，例如： width 、 heigth ，若有多个以逗号分隔。 不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。 常见的支持过渡的属性有：颜色、长度值、百分比、 z-index 、 opacity 、 2D 变换属性、 3D 变换属性、阴影。 4.2. transition-duration作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久。 常用值： 0 ：没有任何过渡时间 —— 默认值。 s 或 ms ：秒或毫秒。 列表 ： 如果想让所有属性都持续一个时间，那就写一个值。 如果想让每个属性持续不同的时间那就写一个时间的列表。 4.3. transition-delay作用：指定开始过渡的延迟时间，单位： s 或 ms 4.4. transition-timing-function作用：设置过渡的类型 常用值： ease ： 平滑过渡 —— 默认值 linear ： 线性过渡 ease-in ： 慢 → 快 ease-out ： 快 → 慢 ease-in-out ： 慢 → 快 → 慢 step-start ： 等同于 steps(1, start) step-end ： 等同于 steps(1, end) steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。 cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。 在线制作贝赛尔曲线：https://cubic-bezier.com 4.5. transition 复合属性如果设置了一个时间，表示 duration ；如果设置了两个时间，第一是 duration ，第二个是delay ；其他值没有顺序要求。 1transition:1s 1s linear all; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_过渡案例&lt;/title&gt; &lt;style&gt; .outer &#123; width: 400px; height: 224px; position: relative; overflow: hidden; &#125; .mask &#123; width: 400px; height: 224px; background-color: black; color: white; position: absolute; top: 0; left: 0; text-align: center; line-height: 224px; font-size: 100px; opacity: 0; transition: 1s linear; cursor: pointer; &#125; img &#123; transition: 0.5s linear; &#125; .outer:hover .mask &#123; opacity: 0.5; &#125; .outer:hover img &#123; transform: scale(1.6) rotate(20deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;img src=&quot;../images/shanghai.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mask&quot;&gt;上海&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot;&gt; &lt;img src=&quot;../images/shanghai.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mask&quot;&gt;上海&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"变换","path":"/2024/01/16/3.变换/","content":"3.1 2D变换3.1.1 2D位移2D 位移可以改变元素的位置，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注意点： 位移与相对定位很相似，都不脱离文档流，不会影响到其它元素。 与相对定位的区别：相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是其自身。 浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高。 transform 可以链式编写，如：transform: translateX(30px) translateY(40px); 位移对行内元素无效。 位移配合定位，可实现元素水平垂直居中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_位移&lt;/title&gt; &lt;style&gt; .outer &#123; width: 200px; height: 200px; border: 2px solid black; margin: 0 auto; margin-top: 100px; position: relative; &#125; .inner &#123; width: 200px; height: 200px; background-color: deepskyblue; /* 水平位移 */ /* transform: translateX(50px); */ /* 垂直位移 */ /* transform: translateY(50px); */ /* 水平+垂直位移 */ /* transform: translate(50px,50px); */ &#125; .inner2 &#123; width: 60px; height: 60px; background-color: orange; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;你好啊&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner2&quot;&gt;你好啊&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.1.2 2D缩放2D 缩放是指：让元素放大或缩小，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注：借助缩放，可实现小于 12px 的文字。 3.1.3 2D旋转2D 旋转是指：让元素在二维平面内，顺时针旋转或逆时针旋转，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注意： rotateZ(20deg) 相当于 rotate(20deg) ， 在平面上实现旋转应用rotateZ 3.1.4 2D扭曲2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 3.1.5 多重变换多个变换，可以同时使用一个 transform 来编写。 transform: translate(-50%, -50%) rotate(45deg); 一般都要把旋转放在最后来写，因为旋转后轴的方向会发生变化。 3.1.5 变换原点 元素变换时，默认的原点是元素的中心，使用 transform-origin 可以设置变换的原点。 修改变换原点对位移没有影响， 对旋转和缩放会产生影响。 如果提供两个值，第一个用于横坐标，第二个用于纵坐标。 如果只提供一个，若是像素值，表示横坐标，纵坐标取 50% ；若是关键词，则另一个坐标取 50% 注： transform-origin: 50% 50% ， 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值 transform-origin: left top ，变换原点在元素的左上角 。 transform-origin: 50px 50px ， 变换原点距离元素左上角 50px 50px 的位置。 transform-origin: 0 ，只写一个值的时候，第二个值默认为 50% 。 3.2 3D变换3.2.1 开启3D空间重要原则：元素进行 3D 变换的首要操作：父元素必须开启 3D 空间！ 使用 transform-style 开启 3D 空间，可选值如下： flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值 preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间） 3.2.2 设置景深何为景深？—— 指定观察者与 z&#x3D;0 平面的距离，能让发生 3D 变换的元素，产生透视效果，看来更加立体。 使用 perspective 设置景深，可选值如下： none ： 不指定透视 ——（默认值） 长度值 ： 指定观察者距离 z&#x3D;0 平面的距离，不允许负值。 注意： perspective 设置给发生 3D 变换元素的父元素！ 3.2.3 透视点位置实质上是camera位置。 所谓透视点位置，就是观察者位置；默认的透视点在元素的中心。 使用 perspective-origin 设置观察者位置（透视点的位置），例如： 注意：通常情况下，我们不需要调整透视点位置。 3.2.4 3D 位移3D 位移是在 2D 位移的基础上，可以让元素沿 z 轴位移，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.5 3D 旋转3D 旋转是在 2D 旋转的基础上，可以让元素沿 x 轴和 y 轴旋转，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.6 3D缩放3D 缩放是在 2D 缩放的基础上，可以让元素沿 z 轴缩放，但html元素没有厚度，所以会在景深上做调整，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.7 多重变换多个变换，可以同时使用一个 transform 来编写。 transform: translateZ(100px) scaleZ(3) rotateY(40deg); 注意点：多重变换时，建议最后旋转。 3.2.8 背部可见性使用 backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下： visible ： 指定元素背面可见，允许显示正面的镜像。—— 默认值 hidden ： 指定元素背面不可见 注意： backface-visibility 需要加在发生 3D 变换元素的自身上。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"CSS3新增内容","path":"/2024/01/16/新增内容/","content":"2.1 新增长度单位 rem 根元素字体大小的倍数，只与根元素字体大小有关。 vw 视口宽度的百分之多少 10vw 就是视口宽度的 10% 。 vh 视口高度的百分之多少 10vh 就是视口高度的 10% 。 vmax 视口宽高中大的那个的百分之多少。（了解即可） vmin 视口宽高中小的那个的百分之多少。（了解即可） 2.2 新增选择器CSS3 新增的选择器有：动态伪类、目标伪类、语言伪类、 UI 伪类、结构伪类、否定伪类、伪元素 2.3 新增盒模型相关属性2.3.1 BOX-SIZING怪异盒模型 2.3.2 resize调整盒子大小使用时要加上overflow，值任意。 2.4.2 box-shadow盒子阴影使用 box-shadow 属性为盒子添加阴影。 语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 2.4.3 opacityopacity 属性能为整个元素添加透明效果， 值是 0 到 1 之间的小数， 0 是完全透明， 1 表示完 全不透明。 opacity 与 rgba 的区别在于 opacity 是一个属性，设置的是整个元素（包括元素里的内容）的不透明度。 rgba 是颜色的设置方式，用于设置颜色，它的透明度，仅仅是调整颜色的透明度 3.新增背景属性3.1 background-origin作用：设置背景图的原点。 语法 padding-box ：从 padding 区域开始显示背景图像。—— 默认值 border-box ： 从 border 区域开始显示背景图像。 content-box ： 从 content 区域开始显示背景图像。 3.2 background-clip作用：设置背景图的向外裁剪的区域。 语法 border-box ： 从 border 区域开始向外裁剪背景。 —— 默认值 padding-box ： 从 padding 区域开始向外裁剪背景。 content-box ： 从 content 区域开始向外裁剪背景。 text ：背景图只呈现在文字上。 注意：若值为 text ，那么 backgroun-clip 要加上 -webkit- 前缀。 3.3 background-size作用：设置背景图的尺寸。 语法： 用长度值指定背景图片大小，不允许负值。 用百分比指定背景图片大小，不允许负值。 auto ： 背景图片的真实大小。 —— 默认值 contain ： 将背景图片等比缩放，使背景图片的宽或高，与容器的宽或高相等，再将完整 背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片。 cover ：将背景图片等比缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要 注意：背景图片有可能显示不完整。—— 相对比较好的选择 3.4. backgorund 复合属性语法： 注意： origin 和 clip 的值如果一样，如果只写一个值，则 origin 和 clip 都设置；如 果设置了两个值，前面的是 origin ，后面的 clip 。 size 的值必须写在 position 值的后面，并且用 &#x2F; 分开。 3.5 多背景图CSS3 允许元素设置多个背景图片 12345/* 添加多个背景图 */background: url(../images/bg-lt.png) no-repeat,url(../images/bg-rt.png) no-repeat right top,url(../images/bg-lb.png) no-repeat left bottom,url(../images/bg-rb.png) no-repeat right bottom; 4. 新增边框属性4.1 边框圆角在 CSS3 中，使用 border-radius 属性可以将盒子变为圆角。 border-radius:10px; border-raidus: 左上角x 右上角x 右下角x 左下角x &#x2F; 左上y 右上y 右下y 左下y 4.2 边框外轮廓outline-width ：外轮廓的宽度。 outline-color ：外轮廓的颜色。 outline-style ：外轮廓的风格。 none ： 无轮廓 dotted ： 点状轮廓 dashed ： 虚线轮廓 solid ： 实线轮廓 double ： 双线轮廓 outline-offset 设置外轮廓与边框的距离，正负值都可以设置。 注意： outline-offset 不是 outline 的子属性，是一个独立的属性。 outline 复合属性 1outline:50px solid blue; 5.新增文本属性5.1文本阴影语法： 默认值： text-shadow:none 表示没有阴影。 5.2 文本换行在 CSS3 中，我们可以使用 white-space 属性设置文本换行方式。 5.3 文本溢出在 CSS3 中，我们可以使用 text-overflow 属性设置文本内容溢出时的呈现模式。 注意：要使得 text-overflow 属性生效，块容器必须显式定义 overflow 为非 visible 值， white-space 为 nowrap 值。 5.4 文本修饰CSS3 升级了 text-decoration 属性，让其变成了复合属性。 子属性及其含义： text-decoration-line 设置文本装饰线的位置 none ： 指定文字无装饰 （默认值） underline ： 指定文字的装饰是下划线 overline ： 指定文字的装饰是上划线 line-through ： 指定文字的装饰是贯穿线 text-decoration-style 文本装饰线条的形状 solid ： 实线 （默认） double ： 双线 dotted ： 点状线条 dashed ： 虚线 wavy ： 波浪线 text-decoration-color 文本装饰线条的颜色 5.5 文本描边注意：文字描边功能仅 webkit 内核浏览器支持。 -webkit-text-stroke-width ：设置文字描边的宽度，写长度值。 -webkit-text-stroke-color ：设置文字描边的颜色，写颜色值。 -webkit-text-stroke ：复合属性，设置文字描边宽度和颜色。 6.新增渐变6.1 线性渐变多个颜色之间的渐变， 默认从上到下渐变。 使用关键词设置线性渐变的方向。 使用角度设置线性渐变的方向。 调整开始渐变的位置 12345background-image: linear-gradient(to top,red,yellow,green);background-image: linear-gradient(to right top,red,yellow,green);background-image: linear-gradient(30deg,red,yellow,green);background-image: linear-gradient(red 50px,yellow 100px ,green 150px); 6.2 径向渐变多个颜色之间的渐变， 默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比） 使用关键词调整渐变圆的圆心位置 使用像素值调整渐变圆的圆心位置。 调整渐变形状为正圆 调整形状的半径 。 调整开始渐变的位置。 1234567background-image: radial-gradient(at right top,red,yellow,green);/*使用关键词调整渐变圆的圆心位置*/background-image: radial-gradient(at 100px 50px,red,yellow,green); /*使用像素值调整渐变圆的圆心位置*/background-image: radial-gradient(circle,red,yellow,green);/*调整渐变形状为正圆*/background-image: radial-gradient(100px,red,yellow,green);/*调整形状的半径*/background-image: radial-gradient(50px 100px,red,yellow,green);background-image: radial-gradient(red 50px,yellow 100px,green 150px)；/*调整开始渐变的位置*/ 6.3 重复渐变无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变。 使用 repeating-linear-gradient 进行重复线性渐变，具体参数同 linear-gradient 。 使用 repeating-radial-gradient 进行重复径向渐变，具体参数同 radial-gradient 。 7.web字体7.1基本用法12345678910111213141516@font-face &#123; font-family: &quot;atguigu&quot;; font-display: swap; src: url(&#x27;webfont.eot&#x27;); /* IE9 */ src: url(&#x27;webfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;webfont.woff2&#x27;) format(&#x27;woff2&#x27;), url(&#x27;webfont.woff&#x27;) format(&#x27;woff&#x27;), /* chrome、firefox */ url(&#x27;webfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* chrome、firefox、opera、Safari, Android*/ url(&#x27;webfont.svg#webfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */&#125;@font-face &#123; font-family: &quot;情书字体&quot;; src: url(&#x27;./方正手迹.ttf&#x27;);&#125; 7.2 字体图标相比图片更加清晰。 灵活性高，更方便改变大小、颜色、风格等。 兼容性好， IE 也能支持。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"CSS3概述","path":"/2024/01/16/1.简介/","content":"1.1 CSS3 的新特性新增了更加实用的选择器，例如：动态伪类选择器、目标伪类选择器、伪元素选择器等等。 新增了更好的视觉效果，例如：圆角、阴影、渐变等。 新增了丰富的背景效果，例如：支持多个背景图片，同时新增了若干个背景相关的属性。 新增了全新的布局方案 —— 弹性盒子。 新增了 Web 字体，可以显示用户电脑上没有安装的字体。 增强了颜色，例如： HSL 、 HSLA 、 RGBA 几种新的颜色模式，新增 opacity 属性来控制 透明度。 增加了 2D 和 3D 变换，例如：旋转、扭曲、缩放、位移等。 增加动画与过渡效果，让效果的变换更具流线性、平滑性。 1.2 CSS3的私有前缀1.2.1 什么是私有前缀如下代码中的 -webkit- 就是私有前缀 12345div &#123; width:400px; height:400px; -webkit-border-radius: 20px;&#125; 1.2.2 为什么要有私有前缀W3C 标准所提出的某个 CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核， 使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了。 举个例子： 12345-webkit-border-radius: 20px;-moz-border-radius: 20px;-ms-border-radius: 20px;-o-border-radius: 20px;border-radius: 20px; 查询 CSS3 兼容性的网站：https://caniuse.com/ 1.2.3 常见浏览器私有前缀Chrome 浏览器： -webkit- Safari 浏览器： -webkit- Firefox 浏览器： -moz- Edge 浏览器： -webkit- 旧 Opera 浏览器： -o- 旧 IE 浏览器： -ms- 注意： 我们在编码时，不用过于关注浏览器私有前缀，不用绞尽脑汁的去记忆，也不用每个都去查询，因 为常用的 CSS3 新特性，主流浏览器都是支持的，即便是为了老浏览器而加前缀，我们也可以借助 现代的构建工具，去帮我们添加私有前缀。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"浮动","path":"/2024/01/16/浮动/","content":"1.浮动在最初，浮动是用来实现文字环绕图片效果的，现在浮动是主流的页面布局方式之一。 浮动后的特点： 🤢脱离文档流。 😊不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高。 😊不会独占一行，可以与其他元素共用一行。 😊不会 margin 合并，也不会 margin 塌陷，能够完美的设置四个方向的 margin和padding。 😊不会像行内块一样被当做文本处理（没有行内块的空白问题）。 2.浮动产生的影响2.1 元素浮动后会有哪些影响对兄弟元素的影响：如果父元素没有高度，会产生高度塌陷， 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。 对父元素的影响： 不能撑起父元素的高度，导致 父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。 2.2 解决浮动产生的影响（清除浮动）解决方案： 方案一： 给父元素指定高度。 方案二： 给父元素也设置浮动，带来其他影响。 方案三： 给父元素设置 overflow:hidden 。 前三种可以解决父元素高度塌陷的问题，但不能解决兄弟元素被覆盖的问题。 4.方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both 。 意思是清除前面所有兄弟的浮动产生的影响，前提是这个元素不浮动并且不是行内元素。 5.方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推荐使用 但是使用时前面的兄弟元素必须全为浮动元素。 12345.parent::after &#123; content: &quot;&quot;; display: block; clear:both;&#125; 布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"定位","path":"/2024/01/16/定位/","content":"1.相对定位1、 如何设置相对定位？给元素设置 position:relative 即可实现相对定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、 相对定位的参考点在哪里？相对自己原来的位置 3、相对定位的特点： 不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 默认规则是： 定位的元素会盖在普通元素之上。都发生定位的两个元素，后写的元素会盖在先写的元素之上。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 相对定位的元素，也能继续浮动，但不推荐这样做。 相对行为的元素，也能通过 margin 调整位置，但不推荐这样做。 注意：绝大多数情况下，相对定位，会与绝对定位配合使用。 4.使用场景 1.对位置微调 2.配合绝对定位适用 2.绝对定位1、 如何设置绝对定位？给元素设置 position: absolute 即可实现绝对定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、绝对定位的参考点在哪里？参考它的包含块。 什么是包含块？ 对于没有脱离文档流的元素：包含块就是父元素； 对于脱离文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都没定位，那包含块就是整个页面）。 3、 绝对定位元素的特点： 脱离文档流，会对后面的兄弟元素、父元素有影响。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 绝对定位、浮动不能同时设置，如果同时设置，浮动失效，以定位为主。 绝对定位的元素，也能通过 margin 调整位置，但不推荐这样做。 无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了定位元素。 何为定位元素？ —— 默认宽、高都被内容所撑开，且能自由设置宽高。 3.固定定位1、 如何设置为固定定位？给元素设置 position: fixed 即可实现固定定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、定定位的参考点在哪里？参考它的视口 什么是视口？—— 对于 PC 浏览器来说，视口就是我们看网页的那扇“窗户”。 3、 固定定位元素的特点 脱离文档流，会对后面的兄弟元素、父元素有影响。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 固定定位和浮动不能同时设置，如果同时设置，浮动失效，以固定定位为主。 固定定位的元素，也能通过 margin 调整位置，但不推荐这样做。 无论是什么元素（行内、行内块、块级）设置为固定定位之后，都变成了定位元素 4.粘性定位1、如何设置为粘性定位？给元素设置 position:sticky 即可实现粘性定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置，不过最常用的是 top 值。 2、粘性定位的参考点在哪里？离它最近的一个拥有“滚动机制”的祖先元素，即便这个祖先不是最近的真实可滚动祖先。 3、粘性定位元素的特点不会脱离文档流，它是一种专门用于窗口滚动时的新的定位方式。 最常用的值是 top 值。 粘性定位和浮动可以同时设置，但不推荐这样做。 粘性定位的元素，也能通过 margin 调整位置，但不推荐这样做。 粘性定位和相对定位的特点基本一致，不同的是：粘性定位可以在元素到达某个位置时将其固定。 5.定位层级 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 如果位置发生重叠，默认情况是：后面的元素，会显示在前面元素之上。 可以通过 css 属性 z-index 调整元素的显示层级。 z-index 的属性值是数字，没有单位，值越大显示层级越高。 只有定位的元素设置 z-index 才有效。 如果 z-index 值大的元素，依然没有覆盖掉 z-index 值小的元素，那么请检查其包含块的层级。 6.定位的特殊应用定位可以越过父元素的padding注意： 发生固定定位、绝对定位后，元素都变成了定位元素，默认宽高被内容撑开，且依然可以设置宽高。 发生相对定位后，元素依然是之前的显示模式。 以下所说的特殊应用，只针对 绝对定位 和 固定定位 的元素，不包括相对定位的元素 1、让定位元素的宽充满包含块定位元素可以没有宽高。 块宽想与包含块一致，可以给定位元素同时设置 left 和 right 为 0 。 高度想与包含块一致， top 和 bottom 设置为 0 。 2、让定位元素在包含块中居中这种情况需要子元素有宽和高。 12345left:0;right:0;top:0;bottom:0;margin:auto; 或者 1234left: 50%;top: 50%;margin-left: 负的宽度一半;margin-top: 负的高度一半;","tags":["CSS","前端"],"categories":["CSS"]},{"title":"重置默认样式","path":"/2024/01/16/布局/","content":"重置默认样式 很多元素都有默认样式，比如： p 元素有默认的上下 margin 。 h1~h6 标题也有上下 margin ，且字体加粗。 body 元素有默认的 8px 外边距。 超链接有默认的文字颜色和下划线。 ul 元素有默认的左 pading 。 方案一：使用全局选择器此种方法，在简单案例中可以用一下，但实际开发中不会使用，因为 * 选择的是所有元素，而并 不是所有的元素都有默认样式；而且我们重置时，有时候是需要做特定处理的，比如：想让 a 元 素的文字是灰色，其他元素文字是蓝色。 方案二：reset.css选择到具有默认样式的元素，清空其默认的样式。 经过 reset 后的网页，好似“一张白纸”，开发人员可根据设计稿，精细的去添加具体的样式。 { margin: 0; padding: 0; …… } 方案三：Normalize.cssNormalize.css 是一种最新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式。 官网地址：http://necolas.github.io/normalize.css/ 相对于 reset.css ， Normalize.css 有如下优点： 保护了有价值的默认样式，而不是完全去掉它们。 为大部分HTML元素提供一般化的样式。 新增对 HTML5 元素的设置。 对并集选择器的使用比较谨慎，有效避免调试工具杂乱。 备注： Normalize.css 的重置，和 reset.css 相比，更加的温和，开发时可根据实际情况进行 选择。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"盒子模型","path":"/2024/01/16/盒子模型/","content":"1.长度单位 px ：像素。 em ：相对元素 font-size 的倍数。如果子元素没有，就往父元素上找。 rem ：相对根字体大小，html标签就是根。 % ：相对父元素计算。 2.元素的显示模式2.1块元素（block）&lt;div&gt; 又称：块级元素 特点： 在页面中独占一行，不会与任何元素共用一行，是从上到下排列的。 默认宽度：撑满父元素。 默认高度：由内容撑开。 可以通过 CSS 设置宽高。 2.2行内元素（inline）&lt;span&gt; 又称：内联元素 特点: 1.在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列 2.默认宽度：由内容撑开。 &#x2F;* 自定义鼠标光标 *&#x2F; cursor: url(“.&#x2F;arrow.png”),pointer; 3. 默认高度：由内容撑开。 4.无法通过 CSS 设置宽高。 2.3行内块元素（inline-block）&lt;img&gt; 又称：内联块元素 特点： 1.在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。 2.默认宽度：由内容撑开。 3.默认高度：由内容撑开。 4.可以通过 CSS 设置宽高。 注意：元素早期只分为：行内元素、块级元素，区分条件也只有一条：”是否独占一行”，如果按照这种分类方式，行内块元素应该算作行内元素。 3.总结块元素（block） 主体结构标签： &lt;html&gt; 、 &lt;body&gt; 排版标签： &lt;h1&gt; ~ &lt;h6&gt; 、 &lt;hr&gt; 、 &lt;p&gt; 、 &lt;pre&gt; 、 &lt;div&gt; 列表标签： &lt;ul&gt; 、 &lt;ol&gt; 、 &lt;li&gt; 、 &lt;dl&gt; 、 &lt;dt&gt; 、 &lt;dd&gt; 表格相关标签： &lt;table&gt; 、 &lt;tbody&gt; 、 &lt;thead&gt; 、 &lt;tfoot&gt; 、 &lt;tr&gt; 、 &lt;caption&gt; &#x20; 5.&lt;form&gt; 与 &lt;option&gt; 行内元素（inline） 文本标签： &lt;br&gt; 、 &lt;em&gt; 、 &lt;strong&gt; 、 &lt;sup&gt; 、 &lt;sub&gt; 、 &lt;del&gt; 、 &lt;ins&gt; &lt;a&gt; 与 &lt;label&gt; 行内块元素（inline-block） 图片： &lt;img&gt; 单元格： &lt;td&gt; 、 &lt;th&gt; 表单控件： &lt;input&gt; 、 &lt;textarea&gt; 、 &lt;select&gt; 、 &lt;button&gt; 框架标签： &lt;iframe&gt; 4.修改元素的显示模式通过 CSS 中的 display 属性可以修改元素的默认显示模式，常用值如下： none：元素会被隐藏。 block：元素将作为块级元素显示。 inline：元素将作为内联元素显示。 inline-block：元素将作为行内块元素显示 5.盒子模型组成 margin（外边距）： 盒子与外界的距离。 border（边框）： 盒子的边框。 padding（内边距）： 紧贴内容的补白区域。 content（内容）：元素中的文本或后代元素都是它的内容。 盒子的大小 &#x3D; content + 左右 padding + 左右 border 。 5.1 paddingpadding 复合属性的使用规则： padding: 10px; 四个方向内边距都是 10px 。 padding: 10px 20px; 上 10px ，左右 20px 。（上下、左右） padding: 10px 20px 30px; 上 10px ，左右 20px ，下 30px 。（上、左右、下） padding: 10px 20px 30px 40px; 上 10px ，右 20px ，下 30px ，左 40px 。（上、右、 下、左） 注意点： padding 的值不能为负数。 行内元素 的 左右内边距是没问题的，上下内边距不能完美的设置。 块级元素、行内块元素，四个方向内边距都可以完美设置。 5.2 margin注意事项 子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着子元素） 上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素的位置。 块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右margin 可以完美设置，上下 margin 设置无效。 margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级元素会在父元素中水平居中。 margin 的值可以是负值。 5.3 margin塌陷问题什么是 margin 塌陷？第一个子元素的上 margin 会作用在父元素上，最后一个子元素的下 margin 会作用在父元素上。如何解决 margin 塌陷？方案一： 给父元素设置不为 0 的 padding 。方案二： 给父元素设置宽度不为 0 的 border 。方案三：给父元素设置 css 样式 overflow:hidden 5.4 margin合并问题什么是 margin 合并？ 上面兄弟元素的下外边距和下面兄弟元素的上外边距会合并，取一个最大的值，而不是相加。 如何解决 margin 塌陷？ 无需解决，布局的时候上下的兄弟元素，只给一个设置上下外边距就可以了。 6.内容溢出 7.隐藏元素方式一：visibility 属性 visibility 属性默认值是 show ，如果设置为 hidden ，元素会隐藏。 元素看不见了，还占有原来的位置（元素的大小依然保持）。 方式二： display 属性 设置 display:none ，就可以让元素隐藏。 彻底地隐藏，不但看不见，也不占用任何位置，没有大小宽高。 8.样式的继承有些样式会继承，元素如果本身设置了某个样式，就使用本身设置的样式；但如果本身没有设置某个样式，会从父元素开始一级一级继承（优先继承离得近的祖先元素）。 会继承的 css 属性： 字体属性、文本属性、文字颜色等 不会继承的 css 属性： 边框、背景、内边距、外边距、宽高、溢出方式等 一个规律：能继承的属性，都是不影响布局的，简单说：都是和盒子模型没关系的。 9.默认样式元素一般都有默认的样式，例如： &lt;a&gt; 元素：下划线、字体颜色、鼠标小手。 &lt;h1&gt; ~ &lt;h6&gt; 元素： 文字加粗、文字大小、上下外边距。 &lt;p&gt; 元素：上下外边距 &lt;ul&gt; 、 ol 元素：左内边距 body 元素： 8px 外边距（4个方向） 优先级：元素的默认样式 &gt; 继承的样式，所以如果要重置元素的默认样式，选择器一定要直接选择器到该元素。 10.布局效果1.行内元素、行内块元素，可以被父元素当做文本处理 即：可以像处理文本对齐一样，去处理：行内、行内块在父元素中的对齐。 例如： text-align 、 line-height 、 text-indent 等。 2.如何让子元素，在父亲中 水平居中： 若子元素为块元素，给父元素加上： margin:0 auto; 。 若子元素为行内元素、行内块元素，给父元素加上： text-align:center 。 📌3.如何让子元素，在父亲中 垂直居中： 若子元素为块元素，给子元素加上： margin-top ，值为：(父元素 content －子元素盒子 总高) &#x2F; 2。 若子元素为行内元素、行内块元素： 让父元素的 height &#x3D; line-height ，每个子元素都加上： vertical-align:middle; 。 补充：若想绝对垂直居中，父元素 font-size 设置为 0 。 11.元素之间的空白问题产生的原因： 行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符。 解决方案： 方案一： 去掉换行和空格（不推荐）。 方案二： 给父元素设置 font-size:0 ，再给需要显示文字的元素，单独设置字体大小（推 荐）。 12.行内块的幽灵空白问题产生原因： 行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的。 解决方案： &#x20;方案一： 给行行内块设置 vertical ，值不为 baseline 即可，设置为 middel 、 bottom 、top 均可。 方案二： 若父元素中只有一张图片，没有文字，设置图片为 display:block 。 方案三： 给父元素设置 font-size: 0 。如果该行内块内部还有文本，则需单独设置 font-size 。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"常用属性","path":"/2024/01/16/常用属性/","content":"1.字体font-size：字体的大小font-family：控制字体类型。可以设置多个字体，按照从左到右的顺序逐个查找，找到就用，没有找到就使用后面 的，且通常在最后写上 serif （衬线字体）或 sans-serif （非衬线字体）。 font-style：字体是否为斜体常用值： normal ：正常（默认值） italic ：斜体（使用字体自带的斜体效果） oblique ：斜体（强制倾斜产生的斜体效果） 实现斜体时，更推荐使用 italic 。 font-weight：控制字体的粗细。 lighter ：细 normal ： 正常 bold ：粗 bolder ：很粗 （多数字体不支持） 字体复合写法属性名： font ，可以把上述字体样式合并成一个属性。 作用：将上述所有字体相关的属性复合在一起编写。 编写规则： 字体大小、字体族必须都写上。 字体族必须是最后一位、字体大小必须是倒数第二位。 各个属性间用空格隔开。 实际开发中更推荐复合写法，但这也不是绝对的，比如只想设置字体大小，那就直接用 font- size 属性 2.文本color： 颜色名 rgb 或 rgba HEX 或 HEXA （十六进制） HSL 或 HSLA 开发中常用的是： rgb&#x2F;rgba 或 HEX&#x2F;HEXA （十六进制）。 间距：字母间距： letter-spacing 单词间距： word-spacing （通过空格识别词，每个中文算一个letter） 属性值为像素（ px ），正值让间距增大，负值让间距缩小。 text-decoration:控制文本的各种装饰线。可选值： none ： 无装饰线（常用） underline ：下划线（常用） overline ： 上划线 line-through ： 删除线 可搭配如下值使用： dotted ：虚线 wavy ：波浪线 也可以指定颜色 text-indent：文本缩进作用：控制文本首字母的缩进。 属性值： css 中的长度单位，例如： px text-align：控制文本的水平对齐方式。常用值： left ：左对齐（默认值） right ：右对齐 center ：居中对齐 line-height：制一行文字的高度。可选值： normal ：由浏览器根据文字大小决定的一个默认值。 像素( px )。 数字：参考自身 font-size 的倍数（很常用）。 百分比：参考自身 font-size 的百分比。 注 ： line-height 过小会怎样？—— 文字产生重叠，且最小值是 0 ，不能为负数。 line-height 是可以继承的，且为了能更好的呈现文字，最好写数值。 line-height 和 height 是什么关系？ 设置了 height ，那么高度就是 height 的值。 不设置 height 的时候，会根据 line-height 计算高度 文本对齐_垂直 顶部：无需任何属性，在垂直方向上，默认就是顶部对齐。 居中：对于单行文字，让 height &#x3D; line-height 即可。 问题：多行文字垂直居中怎么办？—— 后面我们用定位去做。 3底部：对于单行文字，目前一个临时的方式： 让 line-height &#x3D; ( height × 2 ) - font-size - x 。 备注： x 是根据字体族，动态决定的一个值。 问题：垂直方向上的底部对齐，更好的解决办法是什么？—— 后面我们用定位去做。 vertical-align :垂直对齐方式用于指定同一行元素之间，或 表格单元格内文字的垂直对齐方式。 常用值： baseline （默认值）：使元素的基线与父元素的基线对齐。 top ：使元素的顶部与其所在行的顶部对齐。 middle ：使元素的中部与父元素的基线加上父元素字母 x 的一半对齐。 bottom ：使元素的底部与其所在行的底部对齐。 特别注意： vertical-align 不能控制块元素，只能控制父级元素里的子元素 3.列表属性 4.表格属性4.1边框属性 注意： 以上 4 个边框相关的属性，其他元素也可以用，这是我们第一次遇见它们。 4.2表格属性 5.背景属性 6.鼠标属性","tags":["CSS","前端"],"categories":["CSS"]},{"title":"三大特性","path":"/2024/01/16/三大特性/","content":"1.层叠性概念：如果发生了样式冲突，那就会根据一定的规则（选择器优先级），进行样式的层叠（覆 盖）。 2.继承性概念：元素会自动拥有其父元素、或其祖先元素上所设置的某些样式。 规则：优先继承离得近的。 常见的可继承属性： 3.优先级!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; * &gt; 继承的样 式。 见选择器","tags":["CSS","前端"],"categories":["CSS"]},{"title":"选择器","path":"/2024/01/16/选择器/","content":"1.基本选择器1.1 通配选择器作用：可以选中所有的 HTML 元素。 语法： 123* &#123; color：orange&#125; 备注：清除样式时，会对我们有很大帮助 1.2元素选择器作用：为页面中某种元素统一设置样式。 语法： 1234h1 &#123; color: red; font-size: 40px;&#125; 1.3 类选择器作用：根据元素的 class 值，来选中某些元素。 123.button_choose&#123; color:red;&#125; 注： 一个元素的 class 属性，能写多个值，要用空格隔开，例如： 1&lt;h1 class=&quot;speak big&quot;&gt;你好&lt;/h1&gt; 1.4 ID选择器作用：根据元素的 id 值，来选中某个元素。 123#button_choose&#123; color:red;&#125; 注： 一个元素的 class 属性，能写多个值，要用空格隔开，例如： 1&lt;h1 class=&quot;speak big&quot;&gt;你好&lt;/h1&gt; 注： 1、id 属性值：尽量由字母、数字、下划线( _ )、短杠( - )组成，最好以字母开头、不要包含空 格、区分大小写。 2、一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同。 3、一个元素可以同时拥有 id 和 class 属性。 2.复合选择器2.1交集选择器交集选择器中不可能出现两个元素选择器，因为一个元素，不可能即是 p 元素又是 span 元 素 用的最多的交集选择器是：元素选择器配合类名选择器，例如： p.beauty 。 12345678/* 选中：类名为beauty的p元素，为此种写法用的非常多！！！！ */p.beauty &#123; color: blue;&#125;/* 选中：类名包含rich和beauty的元素 */.rich.beauty &#123; color: green;&#125; 2.2 并集选择器12345678/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */#peiqi,.rich,.beauty &#123; font-size: 40px; background-color: skyblue; width: 200px;&#125; 2.3 后代选择器&#x20;&#x20;子、孙子、重孙子、重重孙子 …… 统称后代 12345678910111213141516/* 选中ul中的所有li */ul li &#123; color: red;&#125;/* 选中ul中所有li中的a */ul li a &#123; color: orange;&#125;/* 选中类名为subject元素中的所有li */.subject li &#123; color: blue;&#125;/* 选中类名为subject元素中的所有类名为front-end的li */.subject li.front-end &#123; color: blue;&#125; 2.4 子代选择器选择器之间，用 &gt; 隔开， &gt; 可以理解为：” xxx 的子代”，其实就是儿子的意思。 只选儿子 12345678/* div中的子代a元素 */div&gt;a &#123; color: red;&#125;/* 类名为persons的元素中的子代a元素 */.persons&gt;a&#123; color: red;&#125; 2.5 兄弟选择器2.5.1相邻兄弟选择器作用：选中指定元素后，符合条件的相邻兄弟元素。 所谓相邻，就是紧挨着他的下一个，简记：睡在我下铺的兄弟。 123456789101112131415161718&lt;html&gt; &lt;style&gt; /* 选中div后相邻的兄弟p元素 */ div+p &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 使用场景： 想让23都变为红色 1234567891011121314&lt;html&gt; &lt;style&gt; li+li &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 2.5.2通用兄弟选择器作用：选中指定元素后，符合条件的所有兄弟元素。（简记：睡在我下铺的所有兄弟） 123456789101112131415&lt;html&gt; &lt;style&gt; /* 选中div后的所有的兄弟p元素 */ div~p &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 注意：两种兄弟选择器，选择的是下面的兄弟。 2.6 属性选择器作用：选中属性值符合一定要求的元素。 语法： [属性名] 选中具有某个属性的元素。 [属性名&#x3D;”值”] 选中包含某个属性，且属性值等于指定值的元素。 [属性名^&#x3D;”值”] 选中包含某个属性，且属性值以指定的值开头的元素。 [属性名$&#x3D;”值”] 选中包含某个属性，且属性值以指定的值结尾的元素。 [属性名 *&#x3D;“值”] 选择包含某个属性，属性值包含指定值的元素 1234567891011/* 选中具有title属性的元素 */div[title]&#123;color:red;&#125;/* 选中title属性值为atguigu的元素 */div[title=&quot;atguigu&quot;]&#123;color:red;&#125;/* 选中title属性值以a开头的元素 */div[title^=&quot;a&quot;]&#123;color:red;&#125;/* 选中title属性值以u结尾的元素 */div[title$=&quot;u&quot;]&#123;color:red;&#125;/* 选中title属性值包含g的元素 */div[title*=&quot;g&quot;]&#123;color:red;&#125; 2.7 伪类选择器作用：选中特殊状态的元素。 2.7.1动态伪类1. :link 超链接未被访问的状态。 2. :visited 超链接访问过的状态。 3.:hover 鼠标悬停在元素上的状态。 4.:active 元素激活的状态。 激活：按下鼠标不松开。 注意点：遵循 LVHA 的顺序，即： link 、 visited 、 hover 、 active 。 5.:focus 获取焦点的元素。 表单类元素才能使用 :focus 伪类。 当用户点击元素、触摸元素、或通过键盘的 “ tab ” 键等方式，选择元素时，就是获得焦点。 2.7.2 结构伪类1.常用的 :first-child 所有兄弟元素中的第一个。 :last-child 所有兄弟元素中的最后一个。 :nth-child(n) 所有兄弟元素中的第 n 个。 :first-of-type 所有同类型兄弟元素中的第一个。 :last-of-type 所有同类型兄弟元素中的最后一个。 :nth-of-type(n) 所有同类型兄弟元素中的 第n个 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;09_伪类选择器_结构伪类_1&lt;/title&gt; &lt;style&gt; /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的） —— 看结构1 */ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的） —— 看结构2 选不到 因为span是第一个儿子*/ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的后代p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子（按照所有兄弟计算的） 所以测试三和测试二会变红—— 看结构3 */ /* div p:first-child &#123; color: red; &#125; */ /* 选中的是p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子（按照所有兄弟计算的） —— 看结构3 测试一测试二测试三都变红 */ p:first-child &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 结构1 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构2 --&gt; &lt;!-- &lt;div&gt; &lt;span&gt;张三：98分&lt;/span&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构3 --&gt; &lt;p&gt;测试1&lt;/p&gt; &lt;div&gt; &lt;p&gt;测试2&lt;/p&gt; &lt;marquee&gt; &lt;p&gt;测试3&lt;/p&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;/marquee&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：关于 n 的值： 0 或 不写 ：什么都选不中 —— 几乎不用。 n ：选中所有子元素 —— 几乎不用。 1~正无穷的整数 ：选中对应序号的子元素。 2n 或 even ：选中序号为偶数的子元素。 2n+1 或 odd ：选中序号为奇数的子元素。 -n+3 ：选中的是前 3 个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;10_伪类选择器_结构伪类_2&lt;/title&gt; &lt;style&gt; /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的）—— 结构1*/ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的最后一个儿子p元素（按照所有兄弟计算的）—— 结构1*/ /* div&gt;p:last-child &#123; color: red; &#125; */ /* 选中的是div的第n个儿子p元素（按照所有兄弟计算的）—— 结构1 */ /* div&gt;p:nth-child(3) &#123; color: red; &#125; */ /* 选中的是div的偶数个儿子p元素（按照所有兄弟计算的）—— 结构2 */ /* 关于n的值 —— 结构2： 1. 0或不写：什么都选不中 —— 几乎不用。 2. n ：选中所有子元素 —— 几乎不用。 3. 1 ~ 正无穷的整数，选中对应序号的子元素。 4. 2n 或 even ：选中序号为偶数的子元素。 5. 2n+1 或 odd ：选中序号为奇数的子元素。 6. -n+3 : 选中前三个。 */ /* div&gt;p:nth-child(2n) &#123; color: red; &#125; */ /* 选中的是div的第一个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:first-of-type&#123; color: red; &#125; */ /* 选中的是div的最后一个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:last-of-type&#123; color: red; &#125; */ /* 选中的是div的第n个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:nth-of-type(5) &#123; color: red; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 结构1 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;p&gt;孙七：58分&lt;/p&gt; &lt;p&gt;老八：48分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构2 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;第1个&lt;/p&gt; &lt;p&gt;第2个&lt;/p&gt; &lt;p&gt;第3个&lt;/p&gt; &lt;p&gt;第4个&lt;/p&gt; &lt;p&gt;第5个&lt;/p&gt; &lt;p&gt;第6个&lt;/p&gt; &lt;p&gt;第7个&lt;/p&gt; &lt;p&gt;第8个&lt;/p&gt; &lt;p&gt;第9个&lt;/p&gt; &lt;p&gt;第10个&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构3 --&gt; &lt;!-- &lt;div&gt; &lt;span&gt;测试1&lt;/span&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;span&gt;测试2&lt;/span&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;span&gt;测试3&lt;/span&gt; &lt;p&gt;孙七：58分&lt;/p&gt; &lt;span&gt;测试4&lt;/span&gt; &lt;p&gt;老八：48分&lt;/p&gt; &lt;span&gt;测试5&lt;/span&gt; &lt;/div&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 了解： :nth-last-child(n) 所有兄弟元素中的倒数第 n 个。 :nth-last-of-type(n) 所有同类型兄弟元素中的 倒数第n个 。 :only-child 选择没有兄弟的元素（独生子女）。 :only-of-type 选择没有同类型兄弟的元素。 :root 根元素。 :empty 内容为空元素（空格也算内容）。 2.7.3 否定伪类:not(选择器) 排除满足括号中条件的元素。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12_伪类选择器_否定伪类&lt;/title&gt; &lt;style&gt; /* 选中的是div的儿子p元素，但是排除类名为fail的元素 */ /* div&gt;p:not(.fail) &#123; color: red; &#125; */ /* 选中的是div的儿子p元素，但是排除title属性值以“你要加油”开头的 */ /* div&gt;p:not([title^=&quot;你要加油&quot;]) &#123; color: red; &#125; */ /* 选中的是div的儿子p元素，但排除第一个儿子p元素 */ div&gt;p:not(:first-child) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;p class=&quot;fail&quot; title=&quot;你要加油啊！孙七&quot;&gt;孙七：58分&lt;/p&gt; &lt;p class=&quot;fail&quot; title=&quot;你要加油啊！老八&quot;&gt;老八：48分&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.7.4 UI伪类:checked 被选中的复选框或单选按钮。 :enable 可用的表单元素（没有 disabled 属性） :disabled 不可用的表单元素（有 disabled 属性）。 2.7.3 目标伪类:target 选中锚点指向的元素 2.7.4 语言伪类:lang() 根据指定的语言选择元素（本质是看 lang 属性的值）。 2.8 伪元素选择器作用：选中元素中的一些特殊位置。 常用伪元素： ::first-letter 选中元素中的第一个文字。 ::first-line 选中元素中的第一行文字。 ::selection 选中被鼠标选中的内容。 ::placeholder 选中输入框的提示文字。 ::before 在元素最开始的位置，创建一个子元素（必须用 content 属性指定内容）。 ::after 在元素最后的位置，创建一个子元素（必须用 content 属性指定内容）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;16_伪元素选择器&lt;/title&gt; &lt;style&gt; /* 什么是伪元素？ —— 很像元素，但不是元素（element），是元素中的一些特殊位置 */ /* 选中的是div中的第一个文字 */ div::first-letter &#123; color: red; font-size: 40px; &#125; /* 选中的是div中的第一行文字 */ div::first-line &#123; background-color: yellow; &#125; /* 选中的是div中被鼠标选择的文字 */ div::selection &#123; background-color: green; color: orange; &#125; /* 选中的是input元素中的提示文字 */ input::placeholder &#123; color: skyblue; &#125; /* 选中的是p元素最开始的位置，随后创建一个子元素 */ p::before &#123; content:&quot;￥&quot;; &#125; /* 选中的是p元素最后的位置，随后创建一个子元素 */ p::after &#123; content:&quot;.00&quot; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt quibusdam amet eligendi velit dolore sequi, exercitationem consequatur, quis maiores tempore accusantium ipsum aspernatur iusto fugiat fuga natus est placeat. Accusamus maiores culpa et sunt dolorum incidunt. Ducimus in odio tempora minima provident deleniti, ex voluptatem facere, molestias unde exercitationem pariatur rem vero ut quidem quaerat aliquam, nam debitis perspiciatis. Facere?&lt;/div&gt; &lt;br&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的用户名&quot;&gt; &lt;p&gt;199&lt;/p&gt; &lt;p&gt;299&lt;/p&gt; &lt;p&gt;399&lt;/p&gt; &lt;p&gt;499&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.选择器优先级行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配选择器。 详细描述： 计算方式：每个选择器，都可计算出一组权重，格式为： (a,b,c) a : ID 选择器的个数。 b : 类、伪类、属性 选择器的个数。 c : 元素、伪元素 选择器的个数。 比较规则：按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比，例如： (1,0,0) &gt; (0,2,2) (1,1,0) &gt; (1,0,3) (1,1,3) &gt; (1,1,2) 特殊规则： 行内样式权重大于所有选择器。 !important 的权重，大于行内样式，大于所有选择器，权重最高！","tags":["CSS","前端"],"categories":["CSS"]},{"title":"Javascript变量与常量","path":"/2024/01/16/变量与常量/","content":"typeof 结果 {} object [] object null object undefined undefined NaN number 0 number true boolean ‘’ string let与var与constvar的特点1、var的作用域 var 声明的作用域是全局的或函数&#x2F;局部的。 当 var 变量在函数外部声明时，作用域是全局的。这意味着在函数体外用 var 声明的任何变量都可以在整个窗口中使用。 var 在函数中声明时，它的作用域是在函数体内。这意味着它只能在该函数中被访问。 2、var 变量可以重新声明和更新 3、var的提升 提升（hoisting）是一种 JavaScript 机制，其中变量和函数声明在代码执行之前被移动到其作用域的顶部。 let的特点1、let是块级作用域 块是由 &#123;&#125; 界定的代码块。一个块存在于花括号中。花括号内的任何内容都是一个块。 因此，在带有 let 的块中声明的变量只能在该块中使用。 2、let可以更新但不能重新声明 就像 var 一样，使用 let 声明的变量可以在其作用域内更新。与 var 不同，let 变量不能在其作用域内重新声明。 3、let的提升 就像 var 一样，let 声明被提升到顶部。与初始化为 undefined 的 var 不同，let 关键字未初始化。所以如果你在声明之前尝试使用 let 变量，你会得到一个 Reference Error。 const的特点1、const 声明是块作用域 与 let 声明一样，const 声明只能在它们声明的块内访问。 2、const 不能更新或重新声明 这意味着用 const 声明的变量的值在其作用域内保持不变。它不能被更新或重新声明。 3、const 的提升 就像 let 一样，const 声明被提升到顶部但没有被初始化。 区别 var 声明是全局作用域或函数作用域，而 let 和 const 是块作用域。 var 变量可以在其作用域内更新和重新声明；let 变量可以更新但不能重新声明；const 变量既不能更新也不能重新声明。 它们都被提升到了作用域的顶部。但是，var 变量是用 undefined 初始化的，而 let 和 const 变量不会被初始化。 var 和 let 可以在不初始化的情况下声明，而 const 必须在声明时初始化。 类型转换 理解弱类型语言的特征，掌握显式类型转换的方法 在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。 隐式转换某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 +号两边只要有一个是字符串，都会把另外一个转成字符串 除了+以外的算术运算符，比如 - * &#x2F; 等都会把数据转成数字类型。 +号作为正号解析可以转换成数字型 任何数据和字符串相加结果都是字符串 有字符串的加法“”+1，结果是“1” 减法-（像大多数数学运算一样）只能用于数字，它会使空字符串””转换为0 null经过数字转换之后会变为0 undefined经过数字转换之后会变为NaN 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript 基础 - 隐式转换&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let num = 13 // 数值 let num2 = &#x27;2&#x27; // 字符串 // 结果为 132 // 原因是将数值 num 转换成了字符串，相当于 &#x27;13&#x27; // 然后 + 将两个字符串拼接到了一起 console.log(num + num2) // 结果为 11 // 原因是将字符串 num2 转换成了数值，相当于 2 // 然后数值 13 减去 数值 2 console.log(num - num2) let a = prompt(&#x27;请输入一个数字&#x27;) let b = prompt(&#x27;请再输入一个数字&#x27;) alert(a + b); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换。 补充介绍模板字符串的拼接的使用 显式转换编写程序时过度依靠系统内部的隐式转换是不严谨的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 转为Number1、通过 Number 显示转换成数值类型，当转换失败时结果为 NaN（Not a Number）即不是一个数字。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript 基础 - 隐式转换&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let t = &#x27;12&#x27; let f = 8 // 显式将字符串 12 转换成数值 12 t = Number(t) // 检测转换后的类型 // console.log(typeof t); console.log(t + f) // 结果为 20 // 并不是所有的值都可以被转成数值类型 let str = &#x27;hello&#x27; // 将 hello 转成数值是不现实的，当无法转换成 // 数值时，得到的结果为 NaN （Not a Number） console.log(Number(str)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果字符串内容里有非数字，转换失败时结果为 NaN（Not a Number）即不是一个数字 NaN也是number类型的数据，代表非数字 特殊转换： Number转换 结果 Number({}) NaN Number([]) 0 Number(‘’) 0 Number(null) 0 Number(undefined) undefined Number(NaN) NAN Number(false) 0 Number(true) 1 2、parseInt(数据) 只保留整数，数字只能在字符串开头，否则NaN。 3、parseFloat(数据) 可以保留小数，数字只能在字符串开头，否则NaN。 转换为字符型123String(数据)\t1.对于Number 和 Boolean 实际就是调用 toString()\t2.对于undefined 和 null 是直接转换为 &quot;undefined&quot; 和 &quot;null&quot; 123变量.toString(进制) 1.该方法不会影响原变量 2.Null, Undefined 没有 toString()方法，使用会报错 1234任意数据类型 + &quot;&quot; 1.隐式转换 2.任何数据类型与字符串相加都是先调用 String() 转为字符串再拼接 3.最常用⭐ 转换为Boolean值‘’、0、undefined、null、false、NaN转换为布尔值后都是false,其余则为true Null和Undefined123456789101112131415161718&lt;body&gt; &lt;script&gt; // 1. true false 是布尔型字面量 // console.log(3 &gt; 4) // let isCool = false // console.log(isCool) // 2. 未定义类型 弱数据类型 声明一个变量未赋值就是 undefined // let num // console.log(num) // 3. null 空的 // let obj = null // console.log(obj) // 计算有区别 console.log(undefined + 1) // NaN console.log(null + 1) // 1 &lt;/script&gt;&lt;/body&gt; null 和 undefined 区别：undefined 表示没有赋值null 表示赋值了，但是内容为空 null 开发中的使用场景：官方解释：把 null 作为尚未创建的对象大白话： 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"样式表优先级","path":"/2024/01/15/样式表优先级/","content":"优先级规则：行内样式 &gt; 内部样式 &#x3D; 外部样式 遵循后来者居上原则。CSS写在后面的起作用。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"H5新增内容","path":"/2024/01/15/H5/","content":"1、语义化标签1.1 布局标签 关于 article 和 section ： artical 里面可以有多个 section 。 section 强调的是分段或分块，如果你想将一块内容分成几段的时候，可使用 section 元素。 article 比 section 更强调独立性，一块内容如果比较独立、比较完整，应该使用article 元素。 1.2 状态标签1、meter标签 语义：定义已知范围内的标量测量。也被称为 gauge （尺度），双标签，例如：电量、磁盘用量 等。 常用属性： 2、progeress标签 语义：显示某个任务完成的进度的指示器，一般用于表示进度条，双标签，例如：工作完成进度 等。 1.3列表标签 1.4新增文本标签1、文本注音 1234&lt;ruby&gt;&lt;span&gt;魑魅魍魉&lt;/span&gt;&lt;rt&gt;chī mèi wǎng liǎng &lt;/rt&gt;&lt;/ruby&gt; 2、文本标记 2、新增表单功能2.1表单控件新增属性 2.2 input新增属性值 2.3 form新增属性 3 多媒体标签3.1 视频标签&lt;video&gt; 标签用来定义视频，它是双标签。 3.2 音频标签 4.新增全局属性 5. 兼容性处理添加元信息，让浏览器处于最优渲染模式。 1234&lt;!--设置IE总是使用最新的文档模式进行渲染--&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;!--优先使用 webkit ( Chromium ) 内核进行渲染, 针对360等壳浏览器--&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 使用 html5shiv 让低版本浏览器认识 的语义化标签。 123&lt;!--[if lt ie 9]&gt;&lt;script src=&quot;../sources/js/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 扩展 lt 小于 lte 小于等于 gt 大于 gte 大于等于 ! 逻辑非 示例： 123456&lt;!--[if IE 8]&gt;仅IE8可见&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;仅IE8以上可见&lt;![endif]—&gt;&lt;!--[if lt IE 8]&gt;仅IE8以下可见&lt;![endif]—&gt;&lt;!--[if gte IE 8]&gt;IE8及以上可见&lt;![endif]—&gt;&lt;!--[if lte IE 8]&gt;IE8及以下可见&lt;![endif]—&gt;&lt;!--[if !IE 8]&gt;非IE8的IE可见&lt;![endif]--&gt;","tags":["前端","html"],"categories":["html"]},{"title":"补充标签","path":"/2024/01/15/补充标签/","content":"&lt; br&gt;换行 &lt; pre&gt;按原文显示 &lt; hr&gt;分割 隐藏域： &lt;input type&#x3D;”hidden” name&#x3D;”tag” value&#x3D;”100” &gt; 用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据。 name 属性：指定数据的名称。 value 属性：指定的是真正提交的数据。 &lt;label&gt;: label 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点。 两种与 label 关联方式如下： 让 label 标签的 for 属性的值等于表单控件的 id 。 把表单控件套在 label 标签的里面。 &lt;iframe&gt;嵌入内容","tags":["前端","html"],"categories":["html"]},{"title":"字符实体","path":"/2024/01/15/字符实体/","content":"空格的字符实体&amp;nbsp; &amp;#160 标签&lt;&gt;的字符实体&amp;lt; h1 &amp;gt; &amp;的字符实体&amp;amp;&#x20; 人民币的字符实体&amp;yen; 版权的字符实体&amp;copy; 乘号的字符实体&amp;times; 除号的字符实体&amp;divide;","tags":["前端","html"],"categories":["html"]},{"title":"表格","path":"/2024/01/15/表格/","content":"结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;table border=&quot;1&quot;&gt;&lt;!-- 表格标题 --&gt;&lt;caption&gt;学生信息&lt;/caption&gt;&lt;!-- 表格头部 --&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;民族&lt;/th&gt;&lt;th&gt;政治面貌&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;2. 常用属性&lt;!-- 表格主体 --&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;汉族&lt;/td&gt;&lt;td&gt;团员&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;满族&lt;/td&gt;&lt;td&gt;群众&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;王五&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;回族&lt;/td&gt;&lt;td&gt;党员&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;赵六&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;td&gt;壮族&lt;/td&gt;&lt;td&gt;团员&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;!-- 表格脚注 --&gt;&lt;tfoot&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;共计：4人&lt;/td&gt;&lt;/tr&gt;&lt;/tfoot&gt;&lt;/table&gt; 属性 一般table的属性height意义为最小高度。table会通过自动调整tbody来让整个table高度达到最小高度。","tags":["前端","html"],"categories":["html"]},{"title":"块级元素、行内元素、行内块元素","path":"/2024/01/15/块级元素、行内元素、行内块元素/","content":"块级元素blockquote、address 独占一行。 行内元素文本标签（&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;a&gt;等） 不独占一行 规则1：块级元素中能写行内元素、块级元素。 规则2：行内元素中能写行内元素，不能写块级元素 特殊规则: H1-H6不能嵌套 特殊规则：p标签中不能写块元素 特殊规则：a标签内可以包含除自身之外的任何元素 行内块元素IMG","tags":["前端","html"],"categories":["html"]},{"title":"函数式组件","path":"/2023/06/28/函数式组件/","content":"12345678910111213141516171819&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;test&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../react.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../react-dom.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../babel.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;function demo()&#123;console.log(this);//此处的this是undefined，因为babel编译后开启了严格模式return &lt;h2&gt;我是用函数定义的组件&lt;/h2&gt;&#125; &lt;/script&gt;&lt;/html&gt;","tags":["前端","react","组件"],"categories":["react"]},{"title":"jsx基础知识","path":"/2023/06/18/jsx/","content":"jsx语法JSX是类似于XML的js扩展语法，其本质是React.createElement(component,props,…children)方法的语法糖 注：XML早期用于存储和传输数据。 XML格式如下： 1234&lt;student&gt;&lt;name&gt;Tom&lt;/name&gt;&lt;age&gt;19&lt;/age&gt;&lt;/student&gt; JSON格式如下： 1&quot;&#123;&quot;name&quot;：&quot;Tom&quot;,&quot;age&quot;:19&#125;&quot; jsx语法规则1、定义虚拟DOM时，不要写引号。 12345const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&quot;test&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 2、标签里如果要用JS的表达式，要用{}。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&#123;myID.toLowerCase()&#125;&gt; &lt;span&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 3、写样式时指定类名不用class，用className。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 className=&quot;title&quot; id=&#123;myID.toLowerCase()&#125;&gt; &lt;span&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 12345&lt;style&gt;.title&#123;background:red;&#125;&lt;/style&gt; 4、写内联样式时用style&#x3D;\"{{kay:value}}\"的样式。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 className=&quot;title&quot; id=&#123;myID.toLowerCase()&#125;&gt; &lt;span style=&#123;&#123;color:&#x27;white&#x27;,fontSize:&#x27;29px&#x27;&#125;&#125;&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 5、虚拟DOM必须只有一个根标签。 6、标签必须闭合。 7、标签首字母 1）若小写字母开头，则将标签转为html中同名元素，若html中不存在同名元素，则报错。 2）若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。 注：区分js语句和js表达式 1、表达式：会产生一个值，可以放在任何一个需要值的地方。如a、a+b、demo(1)、arr.map()、function test（）{} 2、语句（代码）： 比如if(){}、for(){}、switch（）{case: ….}","tags":["前端","react","jsx"],"categories":["react"]},{"title":"虚拟DOM创建","path":"/2023/06/18/虚拟DOM创建/","content":"1.用jsx创建虚拟DOM1234const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&quot;title&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;)ReactDOM.render(VDOM,document.querySelector(&#x27;.test&#x27;)) 2.用js创建虚拟DOM1234//1.创建虚拟DOM,创建嵌套格式的domconst VDOM=React.createElement(&#x27;h1&#x27;,&#123;id:&#x27;title&#x27;&#125;,React.createElement(&#x27;span&#x27;,&#123;&#125;,&#x27;hello,React&#x27;))//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.querySelector(&#x27;.test&#x27;)). 3.虚拟DOM与真实DOM的区别1、虚拟DOM本质上就是Object类型的对象 2、虚拟DOM较为轻量级，真实DOM较为重量级，因为虚拟DOM运用于React内部，无需真实DOM上的过多属性。 3、虚拟DOM最终会被React转化为真实DOM。","tags":["前端","react"],"categories":["react"]},{"title":"类式组件","path":"/2023/06/18/类式组件/","content":"类123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt;class Person&#123;constructor(name,age)&#123;//构造器方法//构造器中的this是类的实例对象this.name=namethis.age=age&#125;//一般方法speak()&#123;//speak方法放在了类的原型对象上，供实例使用console.log(`我叫$(this.name),我的年龄是$(this.age)`)&#125;&#125;class Student extends Person&#123; constructor(name,age,grade)&#123; super(name,age) this.grade=grade; &#125; speak()&#123; console.log(`我叫$&#123;this.name&#125;,我的年龄是$&#123;this.age&#125;,我的年纪是$&#123;this.grade&#125;`) &#125;&#125;const p1=new Person(&#x27;tom&#x27;,18)const p2=new Person(&#x27;jerry&#x27;,19)const s1=new Student(&#x27;zhang&#x27;,15,&#x27;高一&#x27;)p1.speak()p2.speak()s1.speak()&lt;/script&gt; 注： 1、类的构造器不是一定要写的 2、如果a类继承于b类，且a类中写了构造器，则a类构造器中super必须要调用。 3、类定义的方法，都放在类的原型对象上，共实例使用 创建类组件12345678910111213&lt;script type=&quot;text/babel&quot;&gt;class MyComponent extends React.Component&#123;//这里Component的c要大写//render是放在MyComponent原型对象上，供实例使用的render()&#123;return&#123;//render中的this是MyComponent的实例对象&lt;h2&gt;我是类定义的组件&lt;/h2&gt;&#125;&#125;&#125;ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))&lt;/script&gt; 执行ReactDOM.render（&lt;MyComponent&#x2F;&gt;）之后。发生了什么？ 1、react解析组件标签，找到MyComponent组件 2、发现组件是使用类定义的，随后new出该类的实例，并通过该实例调用到原型上的render方法 3、将render返回的虚拟dom转为真实dom，随后呈现在页面中。","tags":["前端","react","组件"],"categories":["react"]},{"title":"Hello","path":"/2023/04/15/testlx/","content":"Do not go gentle into that good night.","tags":["随笔"],"categories":["随笔"]},{"path":"/index.html","content":"欢迎来到小璇妙妙屋 About Me计算机科学与技术专业研二在读吭哧吭哧学习前端中酷爱听歌，并且什么风格都听MBTI：ENTP SOSTaylorSwiftNewJeansNewJeansDavid TaoBeauty Behind The Madness 今年第一个小目标 O1 2024年的小目标：完成目前的论文写作并收到accept 正常 17% KR1 跑通实验，确定代码的架构不再改动 跑通原本算法的代码 已完成跑通修改后的版本的代码 已完成敲定修改后的代码，并确认大的架构不再改动 50 未完成 70% KR2 完成中文版本论文的写作 完成引言和背景介绍部分 0完成算法本身描述部分 0完成实验结果对比和分析部分 0完成总结和引用部分 0 未完成 0% KR3 完成英文版本论文的写作 简单翻译 0自己润色 0老师修改 0完成润色 0 未完成 0% KR-4 投出并根据反馈修改 待续… 未完成 0% Did You Know that there's a tunnel under Ocean BlvdDesire,I Want To Turn Into YoumelodramaNorman Fucking RockwellMr. Morale & The Big Steppersasuka 今年第二个小目标 O1 2024年的小目标：找到合适的实习/工作 正常 17% KR1 准备简历，完善经历 完成简历 50准备八股 50准备算法题 50 未完成 50% KR2 投出简历，在面试的同时查漏补缺 投出简历 0开始面试 0总结分析 0 未完成 0% KR3 拿到offer！ 未完成 0%"},{"title":"friends","path":"/friends/index.html","content":"fengASENNIUM3jinxsherlockxing5sqyuyu"}]