[{"title":"细说webpack与vite的区别","path":"/2024/03/29/webpack与vite/","content":"周一面试的时候被问到两者之间的区别，当时答得并不是很好，今天从webpack和vite 的工作原理来分析vite与webpack的具体区别。 Webpack首先，众所周知，Webpack 是一个基于打包器的构建工具，同一个入口文件的代码会打包成一个 Bundle 文件。Webpack 长期来的一个痛点是对于大规模应用的应用启动和热更新速度很慢。 当文件发生变动时，整个 JavaScript Bundle 文件会被 Webpack 重新构建，这就是为什么使用 Webpack 的大规模应用在应用启动和热更新时速度很慢的原因，从而给进行大规模 JavaScript 应用的开发者造成了很差的开发体验。 Vite首先要了解，Vite 主要由两方面组成： 一个开发服务器，基于 ESM 提供丰富的内建能力，比如速度快到惊人的模块热更新（HMR）； 一套构建指令，使用 rollup 进行代码打包，且零配置即可输出用于生产环境的高度优化的静态代码。 Vite 的核心能力和 webpack + webpack-dev-server 相似，但是在开发者体验上有一些提升： 无论项目大小有多大，启动应用都只需更少的时间； 无论项目大小有多大，HMR（Hot Module Replacing）热更新都可以做到及时响应； 按需编译； 零配置，开箱即用； Esbuild 能力带来的 Typescript&#x2F;jsx 的原生支持。 Vite 的工作流程如下图所示，其实就是通过原生 ES Modules 托管源代码，本质上是让浏览器来接管部分打包器的工作。Vite 只会在浏览器请求发生时，按需将源码转成 ES Modules 格式返回给浏览器，由浏览器加载并执行 ES Modules 文件。 接下来介绍一下vite的一些特性。 热更新在基于 Bundle 构建的构建器中，当一个文件变动时，重新构建整个 Bundle 文件是非常低效的，且随着应用规模的上升，构建速度会直线下降。 传统的构建器虽然提供了热更新的能力，但是也会存在随着应用规模上升，热更新速度显著下降的问题。 Vite 基于 ES Modules按需提供源码文件，当一个文件被编辑后，Vite 只会重新编译并提供该文件。因此，无论项目规模多大，Vite 的热更新都可以保持快速更新。 此外，Vite 合理利用浏览器缓存来加速页面加载，源码模块请求根据 304 Not Modified 进行协商缓存；依赖模块请求通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦缓存，不会再次请求。 生产环境仍需打包在生产环境使用 ES Modules会存在大量额外网络请求问题，因此生产环境不太试用 ES Modules，最好的方式还是代码进行 tree-shaking、懒加载、和 chunk 分隔等。 那么生产环境的构建为什么不直接使用 esbuild，而是使用 rollup 呢？这是因为 esbuild 在代码分隔、css 处理等方面的功能仍在开发中，rollup 在应用打包方面更加的成熟且灵活。 性能提升Vite 依托支持原生 ES Modules 模块的现代浏览器，极大的降低了应用的启动和重新构建时间。Vite 本质上是一个在开发环境为浏览器按需提供文件的 Web Server，这些文件包含源码模块和在第一次运行时使用 esbuild 预构建的依赖模块。 Vite 和 Webpack 的主要不同在于开发环境下对于源码如何被托管以及支持哪种模块规范。 依赖预构建Vite 在首次启动时，会进行依赖预构建。依赖预构建有两个目的： CommonJs 和 UMD 的兼容性：开发阶段，Vite 的 Dev Server 将所有代码视为原生 ES 模块。因此，Vite 必须将 CommonJS 或 UMD 发布的依赖项转为 ESM。 性能：Vite 将有很多内部模块的依赖视为单个模块，以提升页面加载性能。比如，lodash-es 拥有超过 600 个内部模块，当 import &#123;debounce&#125; from &#39;lodash-es&#39;; 时，浏览器会同时发起超过 600 个请求，并行请求过多将会显著影响页面加载性能。因此预构建将 lodash-es 视为一个模块，浏览器只需要发起一个请求。 缓存文件系统缓存Vite 会将预构建的依赖缓存到 node_modules/.vite ，它根据几个源决定是否需要重新运行预构建步骤： package.json 中的 dependencies 列表； 包管理的 lockfile，例如 package-lock.json，yarn.lock 或者 pnpm-lock.yaml 可能在 vite.config.js 相关字段中配置过的。 只有在上述其中一项发生更改时，才需要重新运行预构建。 如果处于某些原因，你想要强制 Vite 重新构建依赖，你可以用 --force 命令选项启动开发服务器，或者手动删除 node_modules/.vite 目录。 浏览器缓存解析后的依赖请求会以 HTTP 头 max-age=31536000,immutable 强缓存，以提高开发时的页面重载性能。如果你想通过本地编辑来调试依赖项，可以： 通过浏览器调试工具的 Network 选项卡暂时禁用缓存； 重启 Vite Dev Server，并添加 --force 命令以重新构建依赖； 重新载入页面。 vite比webpack快的原因综上所述，开发阶段vite的速度远快于webpack，主要是因为：webpack是先打包再启动开发服务器，vite是直接启动开发服务器，然后按需编译依赖文件。 下面详细来说： webpack先打包，再启动开发服务器，请求服务器时直接给予打包后的结果； vite直接启动开发服务器，请求哪个模块再对哪个模块进行实时编译； 由于现代浏览器本身就支持ES Modules，会主动发起请求去获取所需文件。vite充分利用这点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack先打包，交给浏览器执行的文件是打包后的； 由于vite启动的时候不需要打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite的开发时优势越明显； 在HRM方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像webpack重新将该模块的所有依赖重新编译； 当需要打包到生产环境时，vite使用传统的rollup进行打包，所以，vite的优势是体现在开发阶段，另外，由于vite使用的是ES Module，所以代码中不可以使用CommonJs；","tags":["前端","Webpack"],"categories":["Webpack"]},{"title":"Vue原理系列之五：虚拟节点 vnode 生成真实DOM","path":"/2024/03/22/Vue原理系列之五：虚拟节点 vnode 生成真实DOM/","content":"首先，我们从前面的文章可以得知 Virtual DOM 渲染成真实的 DOM 实际上要经历 VNode 的定义、diff、patch 等过程。 深入浅出虚拟 DOM 和 Diff 算法，及 Vue2 与 Vue3 中的区别 - 掘金 (juejin.cn) Diff 算法1. 只比较同一层级，不跨级比较vue中的diff算法有个特点，就是只能在同级比较，不能跨级比较。 即图中颜色相同部分进行比较。 举个例子: 12345678910111213141516&lt;!-- 之前 --&gt;&lt;div&gt; &lt;!-- 层级1 --&gt; &lt;p&gt; &lt;!-- 层级2 --&gt; &lt;b&gt; aoy &lt;/b&gt; &lt;!-- 层级3 --&gt; &lt;span&gt;diff&lt;/Span&gt; &lt;/P&gt; &lt;/div&gt;&lt;!-- 之后 --&gt;&lt;div&gt; &lt;!-- 层级1 --&gt; &lt;p&gt; &lt;!-- 层级2 --&gt; &lt;b&gt; aoy &lt;/b&gt; &lt;!-- 层级3 --&gt; &lt;/p&gt; &lt;span&gt;diff&lt;/Span&gt;&lt;/div&gt; 我们可能期望将&lt;span&gt;直接移动到&lt;p&gt;的后边，这是最优的操作。但是实际的diff操作是移除&lt;p&gt;里的&lt;span&gt;在创建一个新的&lt;span&gt;插到&lt;p&gt;的后边。因为新加的&lt;span&gt;在层级2，旧的在层级3，属于不同层级的比较。vue中的diff算法可能不是最优的操作，但是在一颗虚拟DOM树比较复杂的情况下是相对比较友好的。 2. 比较标签名如果同一层级的比较标签名不同，就直接移除老的虚拟 DOM 对应的节点，不继续按这个树状结构做深度比较，这是简化比较次数的第二个方面 3. 比较 key如果标签名相同，key 也相同，就会认为是相同节点，也不继续按这个树状结构做深度比较，比如我们写 v-for 的时候会比较 key，不写 key 就会报错，这也就是因为 Diff 算法需要比较 key 面试中有一道特别常见的题，就是让你说一下 key 的作用，实际上考查的就是大家对虚拟 DOM 和 patch 细节的掌握程度，能够反应出我们面试者的理解层次，所以这里扩展一下 key key 的作用比如有一个列表，我们需要在中间插入一个元素，会发生什么变化呢？先看个图 如图的 li1 和 li2 不会重新渲染，这个没有争议的。而 li3、li4、li5 都会重新渲染 因为在不使用 key 或者列表的 index 作为 key 的时候，每个元素对应的位置关系都是 index，上图中的结果直接导致我们插入的元素到后面的全部元素，对应的位置关系都发生了变更，所以全部都会执行更新操作，这可不是我们想要的，我们希望的是渲染添加的那一个元素，其他四个元素不做任何变更，也就不要重新渲染 而在使用唯一 key 的情况下，每个元素对应的位置关系就是 key，来看一下使用唯一 key 值的情况下 这样如图中的 li3 和 li4 就不会重新渲染，因为元素内容没发生改变，对应的位置关系也没有发生改变。 这也是为什么 v-for 必须要写 key，而且不建议开发中使用数组的 index 作为 key 的原因 总结一下： key 的作用主要是为了更高效的更新虚拟 DOM，因为它可以非常精确的找到相同节点，因此 patch 过程会非常高效 Vue 在 patch 过程中会判断两个节点是不是相同节点时，key 是一个必要条件。比如渲染列表时，如果不写 key，Vue 在比较的时候，就可能会导致频繁更新元素，使整个 patch 过程比较低效，影响性能 应该避免使用数组下标作为 key，因为 key 值不是唯一的话可能会导致上面图中表示的 bug，使 Vue 无法区分它他，还有比如在使用相同标签元素过渡切换的时候，就会导致只替换其内部属性而不会触发过渡效果 从源码里可以知道，Vue 判断两个节点是否相同时主要判断两者的元素类型和 key 等，如果不设置 key，就可能永远认为这两个是相同节点，只能去做更新操作，就造成大量不必要的 DOM 更新操作，明显是不可取的 Vue源码的diff调用逻辑Vue.js 源码实例化了一个 watcher，这个 ~ 被添加到了在模板当中所绑定变量的依赖当中，一旦 model 中的响应式的数据发生了变化，这些响应式的数据所维护的 dep 数组便会调用 dep.notify() 方法完成所有依赖遍历执行的工作，这包括视图的更新，即 updateComponent 方法的调用。watcher 和 updateComponent方法定义在 src/core/instance/lifecycle.js 文件中 。 123456789101112131415161718192021222324252627282930313233343536export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el // 省略一系列其它代码 let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; // 生成虚拟 vnode const vnode = vm._render() // 更新 DOM vm._update(vnode, hydrating) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法 new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false return vm&#125; 完成视图的更新工作事实上就是调用了vm._update方法，这个方法接收的第一个参数是刚生成的Vnode，调用的vm._update方法定义在 src/core/instance/lifecycle.js中。 123456789101112131415161718192021222324252627Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode if (!prevVnode) &#123; // 第一个参数为真实的node节点，则为初始化 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125;&#125; 在这个方法当中最为关键的就是 vm.__patch__ 方法，这也是整个 virtual-dom 当中最为核心的方法，主要完成了prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作。 patch先来介绍几个有用的api invokeDestroyHook: 用来删除dom节点 createElm:用来创建一个节点 patchVnode: patch的核心方法，主要对比就发生在这个方法中。 invokeInsertHook: 用来插入节点。 removeVnodes: 用来移除旧节点。 sameVnode: 比较两个node的tag、isComment、inputType是否相同以及是否都有data属性。 patch的方式主要分为4步 如果oldVnode存在,vnode不存在,则是要做删除oldVnode节点的操作。 如果oldVnode不存在,vnode存在,则是要做创建vnode节点的操作。 如果oldVnode、vnode都存在，且标签名相同、inputType属性(若有)相同且都存在data，则执行patchVnode方法。 如果oldVnode、vnode都存在，但是不满足第三步条件，则**删除oldVnode节点,创建vnode**节点 patchVnode1234567891011121314151617181920212223242526272829303132333435363738394041424344function patchVnode ( oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly ) &#123; // 完全相同，则什么都不做 if (oldVnode === vnode) &#123; return &#125; const elm = vnode.elm = oldVnode.elm // 都是静态节点且key相同,且当vnode是克隆节点或是v-once指令控制的节点 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; vnode.componentInstance = oldVnode.componentInstance return &#125; const oldCh = oldVnode.children const ch = vnode.children // 不都是文本节点 if (isUndef(vnode.text)) &#123; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;) addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; removeVnodes(oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, &#x27;&#x27;) &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; // 都是文本节点 nodeOps.setTextContent(elm, vnode.text) &#125; &#125; patchVnode方法主要分为以下步骤： 若vnode和oldVnode完全相同，则不需要做任何事情 若vnode和oldVnode都是静态节点，且具有相同的key,则当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上，也不用再有其他操作。 若vnode和oldVnode不是文本节点或注释节点时 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在updateChildren函数中实现）。 如果只有oldVnode有子节点，那就把这些节点都删除 如果只有vnode有子节点，那就创建这些子节点 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串 如果vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以. updateChildren12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*** parentElm:父级元素节点* oldCh: oldVnode的children* newCh: vnode的children**/function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; // 定义4个索引 let oldStartIdx = 0 // 旧头 let newStartIdx = 0 // 新头 let oldEndIdx = oldCh.length - 1 // 旧尾 let oldStartVnode = oldCh[0] // oldStartIdx对应的node let oldEndVnode = oldCh[oldEndIdx] // oldEndIdx对应的node let newEndIdx = newCh.length - 1 // 新尾 let newStartVnode = newCh[0] // newStartIdx对应的node let newEndVnode = newCh[newEndIdx] // newEndIdx对应的node let oldKeyToIdx, idxInOld, vnodeToMove, refElm // 当vnode和oldVnode在下标之间有node存在时 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 首先我们定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引，同时oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 分别指向这几个索引对应的 VNode 节点。 举个例子 假设现在oldch、newCh分别如上图所示。那么接下来就要执行 12while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) 在这个循环中，oldStartIdx、oldEndIdx和newStartIdx、newEndIdx分别从两边向中间移动，直到有其中一个存在交叉部分(startIdx&gt;&#x3D;endIdx) 首先当 oldStartVnode 或者 oldEndVnode 不存在的时候，oldStartIdx 与 oldEndIdx 继续向中间靠拢，并更新对应的 oldStartVnode 与 oldEndVnode 的指向,这里需要注意就是伴随着Idx移动，其对应的指向node也发生变化 123456if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left&#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx]&#125; 接下来就是新旧vnode的首首、首尾、尾尾、尾首对比的过程，即oldStartVnode、newStartVnode和oldEndVnode、newEndVnode两两之间执行patchVnode，同时Idx向中间移动 1234567891011121314151617181920else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx]&#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx]&#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx]&#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx]&#125; ok,接下来我们来分别分析 首先如果oldStartVnode、newStartVnode符合 sameVnode 时，说明oldVnode 节点的头部与 vNode 节点的头部是相同的VNode节点，直接进行 patchVnode，同时 oldStartIdx 与 newStartIdx 向后移动一位。 oldEndVnode、newEndVnode同理，若两者符合 sameVnode，直接进行 patchVnode，同时 oldEndIdx 与 newEndIdx 向前移动一位。 接下来比较oldStartVnode、newEndVnode,若两者符合 sameVnode，也就是老 oldVnode 节点的头部与新 vNode 节点的尾部是同一节点的时候，将 oldStartVnode.elm 这个节点直接移动到 oldEndVnode.elm 这个节点的后面即可。然后 oldStartIdx 向后移动一位，newEndIdx 向前移动一位。 同理，oldEndVnode 与 newStartVnode 符合 sameVnode 时，也就是老 oldVnode 节点的尾部与新 vNode 节点的头部是同一节点的时候，将 oldEndVnode.elm 插入到 oldStartVnode.elm 前面。同样的，oldEndIdx 向前移动一位，newStartIdx 向后移动一位。 如果以上四种情况都没有命中，就不断拿新的开始节点的 key 去老的 children 里找 如果没找到，就创建一个新的节点 如果找到了，再对比标签是不是同一个节点 如果是同一个节点，就调用 patchVnode 进行后续对比，然后把这个节点插入到老的开始前面，并且移动新的开始下标，继续下一轮循环对比 如果不是相同节点，就创建一个新的节点&#x20; 如果老的 vnode 先遍历完，就添加新的 vnode 没有遍历的节点 如果新的 vnode 先遍历完，就删除老的 vnode 没有遍历的节点 123456789101112131415161718192021222324252627282930313233else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; // function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map = &#123;&#125; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key if (isDef(key)) map[key] = i &#125; return map&#125; createKeyToOldIdx 的作用是产生 key 与 index 索引对应的一个 map 表。比如说有这么一个oldChild(为举例，格式不正确)： 1234567[ &#123;xx: xx, key: &#x27;key0&#x27;&#125;, &#123;xx: xx, key: &#x27;key1&#x27;&#125;, &#123;xx: xx, key: &#x27;key2&#x27;&#125;] 经过createKeyToOldIdx转换后就会变为 123456&#123; key0: 0, key1: 1, key2: 2&#125; 通过这种方式，就可以在oldCh中快速找到与当前节点(newStartVnode) key相同的节点的索引idxInOld. 12345if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) 如果没有找到这个idxInOld,则通过 createElm 创建一个新节点，并将 newStartIdx 向后移动一位。 12345if (isUndef(idxInOld)) &#123; // 创建新节点 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)&#125; 如果存在这个idxInOld,且符合sameVnode,则执行patchVnode并将oldCh[idxInOld] = undefined,最后将newStartIdx 向后移动一位。 1234567vnodeToMove = oldCh[idxInOld]if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)&#125; 如果不符合 sameVnode，只能创建一个新节点插入到 parentElm 的子节点中，newStartIdx 往后移动一位。 一张图总结 最后，当while循环执行完成,会有两种情况 如果 oldStartIdx &gt; oldEndIdx，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 addVnodes 将这些节点插入即可。 如果 newStartIdx &gt; newEndIdx 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 removeVnodes 批量删除即可。","tags":["前端","Vue2"],"categories":["Vue"]},{"title":"Vue原理系列之四：渲染函数 render() 执行后生成虚拟节点 vnode","path":"/2024/03/22/Vue原理系列之四：渲染函数 render() 执行后生成虚拟节点 vnode/","content":"VNode概念虚拟节点（virtual node， 简写VNode），一个vnode就是一个js对象（通过VNode实例而来），用来描述一个真实DOM元素，它所包含的信息会告诉Vue页面上需要渲染什么样的节点，包括及其子节点的描述信息。 而虚拟DOM是对Vue组件树建立起来的整个VNode树的称呼。 先来看看VNode类的代码： 12345678910111213141516171819202122232425262728293031323334var VNode = function VNode( tag, data, children, text, elm, context, componentOptions, asyncFactory) &#123; this.tag = tag; // 节点标签名 this.data = data; // 节点数据（VNodeData类型） this.children = children; // 子节点 this.text = text; // 节点文本 this.elm = elm; // 节点对应的真实DOM节点 this.ns = undefined; // 命名空间 this.context = context; // 上下文 this.fnContext = undefined; // 函数化组件上下文 this.fnOptions = undefined; // 函数化组件配置项 this.fnScopeId = undefined; // 函数化组件ScopeId this.key = data &amp;&amp; data.key; // 节点的key属性，用于作为节点的标识，有利于patch的优化 this.componentOptions = componentOptions; // 组件配置项 this.componentInstance = undefined; // 组件实例 this.parent = undefined; // 父节点 this.raw = false; // 是否为原生HTML或只是普通文本 this.isStatic = false; // 静态节点标志 keep-alive this.isRootInsert = true; // 是否作为根节点插入 this.isComment = false; // 是否为注释节点 this.isCloned = false; // 是否为克隆节点 this.isOnce = false; // 当前节点是否有v-once指令 this.asyncFactory = asyncFactory; // 异步工厂方法 this.asyncMeta = undefined; // 异步Meta this.isAsyncPlaceholder = false; // 是否为异步占位&#125;; VNode的作用由于每次渲染视图时都是先创建vnode，然后使用它创建的真实DOM插入到页面中，所以可以将上一次渲染视图时先所创建的vnode先缓存起来，之后每当需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode对比，查看他们之间有哪些不一样的地方，找出不一样的地方并基于此去修改真实的DOM。Vue.js目前对状态的侦测策略采用了中等粒度。当状态发生变化时，只通知到组件级别，然后组件内使用虚拟DOM来渲染视图。 如果组件只有一个节点发生了变化，那么重新渲染整个组件的所有节点，很明显会造成很大的性能浪费。因此，对vnode进行缓存，并将上一次的缓存和当前创建的vnode对比，只更新有差异的节点就变得很重要。这也是vnode最重要的一个作用。 VNode的类型vnode类型有以下几种： 注释节点12345678var createEmptyVNode = function (text) &#123; if (text === void 0) text = &quot;&quot;; var node = new VNode(); node.text = text; node.isComment = true; return node;&#125;; 一个注释节点只有两个有效属性text 和isComment，其余属性全是默认undefined或者false 12345// &lt;!-- 注释节点 --&gt;&#123; text: &quot;注释节点&quot;, isComment: true&#125; 文本节点123function createTextVNode(val) &#123; return new VNode(undefined, undefined, undefined, String(val));&#125; 元素节点元素节点通常会存在以下4中有效属性。 tag：tag就是一个节点的名称，例如 p、ul、li和div等。 data：改属性包含了一些节点上的数据，比如attrs、class和style等。 children：当前节点的子节点列表。 context：它是当前组件的Vue.js实例 比如 1&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;/p&gt; 对应的vnode： 1234567&#123; children: [VNode, VNode], context: &#123;...&#125;, data: &#123;...&#125;, tag: &quot;p&quot;, ...&#125; 组件节点组件节点有以下两个独有的属性： componentOptions：组件节点的选项参数，其中包含了propsData、tag和children等信息componentInstance：组件的实例，也就是Vue.js的实例。事实上，在Vue.js中，每个组件都有一个Vue.js实例比如&lt;child&gt;&lt;&#x2F;child&gt;，对应的vnode 12345678&#123; componentInstance: &#123;...&#125;, componentOptions: &#123;...&#125;, context: &#123;...&#125;, data: &#123;...&#125;, tag: &quot;vue-component-1-child&quot;, ... &#125; 函数式组件函数式节点有两个独有的属性functionalContext和functionalOptions 1234567&#123; functionalContext: &#123;...&#125;, functionalOptions: &#123;...&#125;, context: &#123;...&#125;, data: &#123;...&#125;, tag: &quot;div&quot; &#125; 克隆节点克隆节点是将现有节点的属性赋值到新节点中，让新创建的节点和被克隆的节点的属性保持一致，从而实现克隆效果。它的作用是优化静态节点和插槽节点（slot node）。 以静态节点为例，当组件内某个状态发生变化后，当前组件会通过虚拟DOM重新渲染视图，静态节点因为它的内容不会改变，所以除了首次渲染需要执行渲染函数获取vnode之外，后续更新不需要执行渲染函数重新生成vnode。 因此，这是就会使用创建克隆节点的方法将vnode克隆一份，使用克隆节点进行渲染。这样就不需要执行渲染函数生成新的静态节点的vnode，从而提升一定的性能。 12345678910111213141516171819202122function cloneVNode(vnode) &#123; var cloned = new VNode( vnode.tag, vnode.data, vnode.children &amp;&amp; vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory ); cloned.ns = vnode.ns; cloned.isStatic = vnode.isStatic; cloned.key = vnode.key; cloned.isComment = vnode.isComment; cloned.fnContext = vnode.fnContext; cloned.fnOptions = vnode.fnOptions; cloned.fnScopeId = vnode.fnScopeId; cloned.asyncMeta = vnode.asyncMeta; cloned.isCloned = true; return cloned;&#125; 生成一个新的vnode的过程通常使用createElement用来创建一个虚拟节点。 当data上已经绑定__ob__的时候，代表该对象已经被Oberver过了，所以创建一个空节点。tag不存在的时候同样创建一个空节点。当tag不是一个String类型的时候代表tag是一个组件的构造类，直接用new VNode创建。当tag是String类型的时候，如果是保留标签，则用new VNode创建一个VNode实例，如果在vm的option的components找得到该tag，代表这是一个组件，否则统一用new VNode创建。","tags":["前端","Vue2"],"categories":["Vue"]},{"title":"Vue原理系列之三：AST编译为render（）","path":"/2024/03/21/Vue原理系列之三：AST编译为render（）/","content":"渲染函数是 AST 到虚拟 DOM 节点的中间媒介，本质上就是 JS 的函数，执行后会基于『运行时』返回虚拟节点的对象。 在 Vue.js 2 中，通过执行「渲染函数」获得了虚拟 DOM 节点，用于虚拟节点 Diff 并最终生成真实 DOM。 123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 上述3行源码中，调用的vm._render()即是「渲染函数」，其返回值即为「虚拟 DOM 节点」。 将虚拟 DOM 节点作为参数传给vm._update()后，就开始了著名的『虚拟 DOM Diff』。 generategenerate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。 render函数的就是返回一个_c(‘tagName’,data,children)的方法 第一个参数是标签名 第二个参数是他的一些数据，包括属性&#x2F;指令&#x2F;方法／表达式等等。 第三个参数是当前标签的子标签,同样的，每一个子标签的格式也是_c(‘tagName’,data,children)。 12345function render() &#123; with(this) &#123; return _c(&#x27;div&#x27;,[_v(_s(msg))]) &#125;&#125; generate就是通过不断递归形成了这么一种树形结构。 这里对后面会用到的方法以及函数做一个简单的介绍 genElement：用来生成基本的render结构或者叫createElement结构genData: 处理ast结构上的一些属性，用来生成datagenChildren:处理ast的children,并在内部调用genElement,形成子元素的_c()方法 render字符串内部有几种方法： _c：对应的是 createElement 方法，顾名思义，它的含义是创建一个元素(Vnode) _v：创建一个文本结点。 _s：把一个值转换为字符串。（eg: ） _m：渲染静态内容 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;val&#125;&#125; &lt;img src=&quot;http://xx.jpg&quot;&gt; &lt;/div&gt;&lt;/template&gt;&#123; render: with(this) &#123; return _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, [_v(&quot; &quot; + _s(val) + &quot; &quot;), _c(&#x27;img&#x27;, &#123; attrs: &#123; &quot;src&quot;: &quot;&quot; &#125; &#125;) ] ) &#125;&#125; 核心原理1. 把字符串函数体转化为函数写 JS 时，我们可以通过声明或表达式的形式创造函数。 但是在 JS 的执行过程中「创造函数」我们需要new Function() API，即JS中函数的构造函数。 通过调用函数的构造函数，我们可以将「字符串」类型的函数体，转化为一个可执行的JS函数： 12345678const func = new Function(&#x27;console.log(`新函数`)&#x27;)/* func ===ƒ anonymous() &#123; console.log(`新函数`)&#125;*/func() // 打印 `新函数` 通过new Function()API，我们就拥有了在 JS 执行过程中生成函数体，并最终声明函数的能力。 2. 基于AST生成字符串格式的函数体有了声明函数的能力，我们就可以把 AST 编译为「字符串格式的函数体」，再将之转化为可执行的函数。 例如，我们有一个&lt;div /&gt;对应的 AST： 12345&#123; &quot;type&quot;: 1, &quot;tag&quot;: &quot;div&quot;, &quot;children&quot;: [],&#125; 想要把 AST 编译为渲染函数的函数体：_c(&#39;div&#39;)。 我们只需要对 AST 进行遍历，根据tag属性就可以拼接出想要的函数体： 12345function generate(ast) &#123; if (ast.tag) &#123; return `_c(&#x27;$&#123;ast.tag&#125;&#x27;)` &#125;&#125; 如果 AST 的children属性不为空，我们继续对其进行深度优先递归搜索，就可继续增加渲染函数的函数体，最终生成各种复杂的渲染函数，渲染出复杂的 DOM，例如： 1234567891011121314const render = function () &#123; with (this) &#123; return _c( &#x27;div&#x27;, &#123;attrs: &#123;&quot;id&quot;: &quot;app&quot;&#125;&#125;, [ _c(&#x27;h1&#x27;, [_v(&quot;Hello vue-template-babel-compiler&quot;)]), _v(&quot; &quot;), (optional?.chaining) ? _c(&#x27;h2&#x27;, [_v(&quot;\\ Optional Chaining enabled: &quot; + _s(optional?.chaining) + &quot;\\ &quot;)]) : _e() ] ) &#125;&#125; 如果有兴趣，可以找到自己项目中的node_modules/vue-template-compiler/build.js第4815行：var code = generate(ast, options); 加上console.log(code)，npm run serve运行后，就可以在控制台中看到自己写的.vue文件编译出的渲染函数。 具体步骤1. 增加CodeGenerator类及其调用我们用CodeGenerator封装编译AST为渲染函数的逻辑，其带有一个generate(ast)方法， 传入 AST 作为参数，调用后会返回带有 render() 函数作为属性值的对象： 12345678910class CodeGenerator &#123; generate(ast) &#123; debugger var code = this.genElement(ast) return &#123; render: (&quot;with(this)&#123;return &quot; + code + &quot;&#125;&quot;), &#125; &#125;&#125; 2. 编译 AST 中的父元素我们再为类添加一个genElement方法， 这个方法接受一个 AST 节点，做2件事： 继续编译 AST 节点的子节点children 拼接字符串，将当前 AST 节点编译为渲染函数 12345genElement(el) &#123; var children = this.genChildren(el) const code = `_c(&#x27;$&#123;el.tag&#125;&#x27;$&#123;children ? `,$&#123;children&#125;` : &#x27;&#x27;&#125;)` return code&#125; genElement用于将AST： 12345&#123; &quot;type&quot;: 1, &quot;tag&quot;: &quot;div&quot;, &quot;children&quot;: [],&#125; 编译为字符串函数体：_c(&#39;div&#39;) 3. 编译 AST 中的子元素接下来我们编译子元素ast.children children是一个数组，可能有多个子元素，所以我们需要对其进行.map()遍历，分别处理每一个子元素。 123456genChildren (el, state) &#123; var children = el.children if (children.length) &#123; return `[$&#123;children.map(c =&gt; this.genNode(c, state)).join(&#x27;,&#x27;)&#125;]` &#125;&#125; 我们再为类添加一个genElement方法，用于调用genChildren： 123456genElement(el) &#123; debugger var children = this.genChildren(el) const code = `_c(&#x27;$&#123;el.tag&#125;&#x27;$&#123;children ? `,$&#123;children&#125;` : &#x27;&#x27;&#125;)` return code&#125; 4. 分别处理每一个子元素我们用genNode(node)方法处理子元素， 生产环境中，子元素有多种，可能是文本、注释、HTML元素，所以需要用if (node.type === 2)判断类型，在分情况处理。 123456genNode(node) &#123; if (node.type === 2) &#123; return this.genText(node) &#125; // TODO else if (node.type === otherType) &#123;&#125;&#125; 我们此次需要处理的只有「文本」（node.type === 2）这一种，所以我们再增加一个genText(text)来处理。 123genText(text) &#123; return `_v($&#123;text.expression&#125;)`&#125; 在编译 AST 阶段，我们已经把&#123;&#123;msg&#125;&#125;编译为了一个 JS 对象： 12345678910&#123; &quot;type&quot;: 2, &quot;expression&quot;: &quot;_s(msg)&quot;, &quot;tokens&quot;: [ &#123; &quot;@binding&quot;: &quot;msg&quot; &#125; ], &quot;text&quot;: &quot;&#123;&#123;msg&#125;&#125;&quot;&#125; 现在我们只要取expression属性，就是其对应的渲染函数。 简而言之_s()是 Vue.js 内置的一个方法，可以把传入的字符串生成一个对应的虚拟 DOM 节点。 后续我们将详细介绍_s(msg)的含义及其实现。 5. 拼接为字符串函数体、生成渲染函数经过以上各步骤，我们已将 AST 对象解析成了渲染函数的函数体字符串：with(this)&#123;return _c(&#39;div&#39;,[_v(_s(msg))])&#125;， 为了将仍然是字符串函数体的render属性，转化为可执行的函数，我们再增加一段new Function(code)逻辑， 并把createFunction (code)声明到VueCompiler类，以便于最终调用： 1234567createFunction (code) &#123; try &#123; return new Function(code) &#125; catch (err) &#123; throw err &#125;&#125; 最后我们来统一调用。 在VueCompiler类的compile(template)中添加CodeGenerator实例及this.CodeGenerator.generate(ast)调用： 12345678910111213141516class VueCompiler &#123; HTMLParser = new HTMLParser() CodeGenerator = new CodeGenerator() compile(template) &#123; const ast = this.parse(template) console.log(`一、《template 字符串编译为抽象语法树 AST》`) console.log(`ast = $&#123;JSON.stringify(ast, null, 2)&#125;`) const code = this.CodeGenerator.generate(ast) const render = this.createFunction(code.render) console.log(`二、《抽象语法树 AST 编译为渲染函数 render()》`) console.log(`render() = $&#123;render&#125;`) return render &#125;&#125;","tags":["前端","Vue2"],"categories":["Vue"]},{"title":"Vue原理系列之二：template模板编译为AST","path":"/2024/03/21/Vue原理系列之二：template模板编译为AST/","content":"AST（抽象语法树）的概念在模板语法中（如v-for循环中）如果我们直接将模板语法编译成正常的HTLM语法是非常困难的。 所以，我们需通过AST抽象语法树，将模板语法转换成正常的HTML语法，如下图所示 那么AST抽象语法树到底是什么呢？其实AST抽象语法树本质上是一个JS对象 上面图中，用JS结构来表示HTML结构实际上就是AST抽象语法树。抽象语法树是服务于模板编译的，从一种语法翻译成另外一种语法，比如 ES6 转 ES5 知识储备在进一步讲述如何将template转化为AST之前，我们先来做一些知识储备，假定你对正则表达式、栈、递归的概念有一些基础的了解，那么请看接下来的这道题。 试编写“智能重复”，smartRepeat函数，实现： 将’3[abc]’变成abcabcabc 将’3[2[a]2[b]]’变成aabbaabbaabb 将’2[1[a]3[b]2[3[c]4[d]]]’变成abbbcccddddcccdddabbbcccddddcccddd 看到题目，一些小伙伴们就可能就会想到用递归的方法进行编写，但是你会发现这个是一个字符串，而且这个[不知道是和哪一个 ] 进行拼接的，所以使用的递归的方法比较麻烦，不是说不可以解题，但是会很复杂。这里我们就需要使用栈的思想来解决问题。 首先需要两个栈stack1和stack2，一个用来存储数字，一个用来存储字符串。 遍历每一个字符串 如果这个字符是数字，那么就将数字压入 stack1栈，把空字符串压入stack2栈， 如果这个字符是字母，那么此时就把stack2栈顶 这一项改为这个字母， 如果这个字符是]，那么就将数字从 stack1 栈中弹出，把 stack2的栈顶元素重复 stack1中 弹栈的数字的次数，然后将其从stack2中弹出，拼接到stack2的新栈顶上。 分析了思路之后，相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function smartRepeat(templateStr) &#123; // 指针 var index = 0 // 栈1 var stack1 = [] // 栈2 var stack2 = [] // 尾部 var rest = templateStr while(index &lt; templateStr.length -1) &#123; // 改变尾部 剩余部分 rest = templateStr.substring(index) // 检测是否以数字和[开头 if (/^\\d+\\[/.test(rest)) &#123; // 将数字入栈1 // 如果这个字符是数字，那么就将数字压入 stack1栈，把`空字符串压入stack2栈， let times = Number(rest.match(/^(\\d+)\\[/)[1]) stack1.push(times) // 将空字符串入栈2 stack2.push(&#x27;&#x27;) // 让指针后移 times这个数字多少就后移多少位 +1 // +1 是[括号 index += times.toString().length + 1 &#125; else if (/^\\w+\\]/.test(rest)) &#123; // 如果这个字符是字母，那么此时就把stack2栈顶这一项改为这个字母， let word = rest.match(/^(\\w+)\\]/)[1] // 字母和]开头 stack2[stack2.length-1] = word // 让指针后移 word这个数字多少就后移多少位 index += word.length &#125; else if(rest[0] == &#x27;]&#x27;)&#123; // 如果这个字符是]，那么就将数字从 stack1 栈中弹出，把 stack2的栈顶元素重复 stack1中 弹栈的数字的次数`， // 然后将其从stack2中弹出，拼接到stack2的新栈顶上。 let times = stack1.pop() let word = stack2.pop() // repeat是h5中新增的方法 比如： &#x27;a&#x27;.repeat(2) = &#x27;aa&#x27; stack2[stack2.length -1 ] += word.repeat(times) index++ &#125; console.log(index, stack1,stack2); &#125; // while遍历结束 stack1和stack2各剩一项 return stack2[0].repeat(stack1[0])&#125;console.log(smartRepeat(&#x27;3[2[a]2[b]]&#x27;)); &#x20;记住这个解题思路，因为接下来的词法分析会用到栈的思路去解决问题。 AST抽象树的手动实现12345678910111213import parse from &quot;./parse&quot;;var templateStr = `&lt;div&gt; &lt;h3&gt;你好&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;li&gt;C&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;`let ast = parse(templateStr)console.log(ast); 根据以上给出的html代码，我们可以得到转换后的AST抽象语法树应为： 通过观察我们发现，其实这 AST抽象语法树 的转换和上面栈的题目几乎差不多，都是要使用两个栈来进行运算，当遇到 &lt;&gt;标签 时进栈，遇到 &lt;/&gt;标签 出栈。所以我们可以借助上面的题目 栈的思路 来完成 AST抽象语法树 的转换。如果你真的理解上面的题目，这道题你理解起来很非常轻松。 parse（）方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 作用：用来生成AST抽象语法树 * @param &#123;*&#125; templateStr 传入的模板字符串 */export default function parse(templateStr) &#123; // 指针 var index = 0 // 栈1 存储标签 var stack1 = [] // 栈2 存储文字内容 默认留一项 不用判断stack2结束 var stack2 = [&#123;&#x27;children&#x27;:[]&#125;] // 尾巴 var rest = templateStr // 开始正则 var startRegExp = /^\\&lt;([a-z]+[1-6]?)\\&gt;/ // 结束正则 var endRegExp = /^\\&lt;\\/([a-z]+[1-6]?)\\&gt;/ // 文字正则 var wordErgExp = /^([^\\&lt;]+)\\&lt;\\/([a-z]+[1-6]?)\\&gt;/ while (index &lt; templateStr.length - 1) &#123; rest = templateStr.substring(index) // 识别遍历到这个字符的时候，是不是一个开始标签 if (startRegExp.test(rest)) &#123; let tag = rest.match(startRegExp)[1] // 入栈 stack1.push(tag) stack2.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: []&#125;) // 指针跳过标签 并且&lt;&gt; 所以要+2 index += tag.length + 2 &#125;else if (endRegExp.test(rest))&#123; // 识别这个字符是不是结束标签 let tag = rest.match(endRegExp)[1] //此时tag一定和栈1的栈顶相同 let pop_tag = stack1.pop() if(tag === pop_tag ) &#123; // 出栈 let pop_arr = stack2.pop() // 检测stack2是否有children属性 if(stack2.length &gt; 0) &#123; stack2[stack2.length - 1].children.push(pop_arr) &#125; &#125; else &#123; new Error(stack1[stack1.length - 1] + &#x27;标签没有闭合&#x27;) &#125; // 指针跳过标签 并包含&lt;/&gt; 所以要+3 index += tag.length + 3 &#125; else if(wordErgExp.test(rest)) &#123; // 检测到文字 let word = rest.match(wordErgExp)[1] // 文字不能是全空 去除空格 if(!/^\\s+$/.test(word)) &#123; // 改变此时stack2栈顶元素 stack2[stack2.length - 1].children.push(&#123;&#x27;text&#x27;: word, &#x27;type&#x27;: 3&#125;) &#125; index += word.length &#125; else &#123; index++ &#125; &#125; // console.log(stack2); return stack2[0].children[0]&#125; 当我们往标签中添加类名的时候，其实会报如下图的错误。 12345678910111213import parse from &quot;./parse&quot;;var templateStr = `&lt;div&gt; &lt;h3 class=&quot;box box1&quot; id=&quot;h3&quot;&gt;你好&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;li&gt;C&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;`let ast = parse(templateStr)console.log(ast); 原因很简单，就是在解析标签的时候，会默认将class&#x3D;”box box1” id&#x3D;”h3”也当成标签来处理，所以就会报错，即我们还需要将开始标签的正则进行完善 123456789101112131415161718//修改开始正则，如果存在以空格除&lt;之外的任意字符 +表示一个或多个 ？表示没有类名或id 属性名 var startRegExp = /^\\&lt;([a-z]+[1-6]?)(\\s[^\\&lt;]+)?\\&gt;/ ... if (startRegExp.test(rest)) &#123; // 获取标签 let tag = rest.match(startRegExp)[1] // 获取属性 let attrsString = rest.match(startRegExp)[2] console.log(&#x27;开始标记&#x27;, tag); // 入栈 stack1.push(tag) stack2.push(&#123;&#x27;tag&#x27;: tag, &#x27;children&#x27;: [],attrs: attrsString&#125;) // 指针跳过标签 并且&lt;&gt; 所以要+2 // 判断是否存在attrsString 因为有些标签是没有attrs属性的 const attrsStringLength = attrsString != null ? attrsString.length : 0 index += tag.length + 2 + attrsStringLength ... 可以发现有了attrs属性，但是attrs属性是一个数组，里面包含name和value的值，所以我们需要对attrs进行改造。 12attrs:[&#123;name:class,value:box&#125;,&#123;name:id,value:h3&#125;] parseAttrsString（）方法将attrs改造成数组包含对象name和value属性。 通过上面的动图思路，我们就可以通过这个思路去书写代码： 123456789101112131415161718192021222324252627282930313233343536export default function parseAttrsString(attrsString) &#123; if (attrsString == undefined) return [] // 遇到引号 标记 去除不在引号里面的空格 false 不在 true在 var isClass = false // 断点 使用指针的思想 var point = 0 // 结果数组 var result = [] for (let i = 0; i &lt; attrsString.length; i++) &#123; let char = attrsString[i] if (char == &#x27;&quot;&#x27;) &#123; // 遇到引号 改标记 isClass = !isClass &#125; else if (char == &#x27; &#x27; &amp;&amp; !isClass) &#123; // 遇到空格并且不在引号内 if (!/^\\s*$/.test(attrsString.substring(point, i).trim())) &#123; //去掉空格 result.push(attrsString.substring(point, i).trim()) point = i &#125; &#125; &#125; // 循环结束之后还剩一项 result.push(attrsString.substring(point).trim()) // 映射 将[&quot;k = v&quot;, &quot;k = v&quot;] 变成[&#123;name: &#x27;k&#x27;, value:&#x27;v&#x27;&#125;,&#123;name: &#x27;k&#x27;, value: &#x27;v&#x27;&#125;]形式 result = result.map(item =&gt; &#123; // 根据等号拆分 let obj = item.match(/^(.+)=&quot;(.+)&quot;$/) return &#123; name: obj[1], // 第一个（）的捕获 value: obj[2] // 第二个（）捕获 &#125; &#125;) return result&#125; 最后一个完美的 AST抽象语法树 就完成了，测试结果如下图所示：","tags":["前端","Vue2"],"categories":["Vue"]},{"title":"Vue原理系列之一：Vue的运行机制","path":"/2024/03/21/Vue原理系列之一：Vue的运行机制/","content":"开始前首先贴上个人看到的比较好的一些讲述了vue底层原理的文章，大佬们写的非常详细，由浅入深。本系列是站在各位大佬的肩膀上进行的一个总结。 纯干货！图解Vue响应式原理 - 掘金 (juejin.cn) https://juejin.cn/user/2647279730694029/posts https://juejin.cn/post/7076002091570823181#heading-12 https://segmentfault.com/a/1190000041689097 引入首先简单贴一下vue2的 运行机制图 初始化及挂载 在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。 其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」，后面会详细讲到，这里只要有一个印象即可。 初始化之后调用 $mount 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。 编译 1. parse parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。 2. optimize optimize 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。 3. generate generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。 在经历过 parse、optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。 响应式 这里的 getter 跟 setter 已经在之前的文章已经介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。 当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。 在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略，这个我们后面再讲。 Virtual DOM 我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 比如说下面这样一个简单的例子： 12345678910&#123; tag: &#x27;div&#x27;, /*说明这是一个div标签*/ children: [ /*存放该标签的子节点*/ &#123; tag: &#x27;a&#x27;, /*说明这是一个a标签*/ text: &#x27;click me&#x27; /*标签的内容*/ &#125; ]&#125; 渲染后可以得到 12345&lt;div&gt; &lt;a&gt;click me&lt;/a&gt;&lt;/div&gt; 更新视图 前面我们说到，在修改一个对象值的时候，会通过 setter -&gt; Watcher -&gt; update 的流程来修改对应的视图，那么最终是如何更新视图的呢？ 当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。 那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「**patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异**」的对应 DOM 进行修改即可。 关于nextTick通过以上的了解我们知道，vue整个内部运行的机制。那么，现在这里存在一个问题，我们每次数据更新不可能只更新一个数据或者说当某个数据持续更新时，难道我们每更新一次数据都会生成一个DOM吗？ 答案当然是否定的。Vue.js在默认情况下，每次触发某个数据的setter方法后，对应的 Watcher 对象会被 push 进一个队列中，它会在下一次tick的时候将这些watcher拿出来，执行一遍对应的patch操作。 那么什么是下一个tick呢？且听随后分解。","tags":["前端","Vue2"],"categories":["Vue"]},{"title":"文件上传的n种实现方式","path":"/2024/03/20/文件上传的n种实现方式/","content":"这篇文章按照场景的不同分别讲述了几种文件上传的实现方式以及原理。分别包括： 通过form-data格式上传文件 通过base64格式上传图片 前端选择图片时需要预览，并且需要前端为文件名起一个唯一的标识符的场景 前端需要实时展示文件上传进度的场景 有多个文件需要批量上传并且均需展示进度条的场景 拖拽上传的实现 大文件分片上传以及断点重传功能。 通过form-data格式上传文件对于文件上传，我们需要设置请求头为content-type:multipart/form-data 因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高 传统前端文件上传的表单结构如下： 1234&lt;form action=&quot;http://localhost:8080/api/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; value=&quot;&quot; multiple=&quot;multiple&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; action 就是我们的提交到的接口，enctype=&quot;multipart/form-data&quot; 就是指定上传文件格式，input 的 name 属性一定要等于file 注：此处后端使用multiparty实现文件上传处理 和form-data解析 multiparty会自动为文件生成一个hash值编译后的文件名，防止文件名重复出现覆盖的情况 通过base64格式上传图片将图片转化为base64格式的方法有两种 1、image+canvas 1234567891011121314151617const getBase64Image = src =&gt; &#123; return new Promise(resolve =&gt; &#123; const img = new Image() img.crossOrigin = &#x27;&#x27; img.src = src img.onload = function () &#123; const canvas = document.createElement(&#x27;canvas&#x27;) canvas.width = img.width canvas.height = img.height const ctx = canvas.getContext(&#x27;2d&#x27;) ctx?.drawImage(img, 0, 0, img.width, img.height) const ext = img.src.substring(img.src.lastIndexOf(&#x27;.&#x27;) + 1).toLowerCase() const dataURL = canvas.toDataURL(&#x27;image/&#x27; + ext) resolve(dataURL) &#125; &#125;)&#125; 2、xhr+FileReader&#x20; readAsDataURL ， 这个方法会返回一个你得到的这个对象的一个base64的地址，但是这个地址，你会发现你的文件越大，这个地址就越长，其实这个地址是一个Base64编码的文件数据字符串 123456789101112const changeBase64 = file =&gt; &#123; return new Promise(resolve =&gt; &#123; let fileReader = new FileReader() //FileReader里面有个方法readAsDataURL 可以将图片转base64进制 fileReader.readAsDataURL(file) // onload可以监听转换完成后 fileReader.onload = ev =&gt; &#123; resolve(ev.target.result) &#125; &#125;) &#125; 传送的时候需要使用encodeURIComponent方法防止base64中的一些特殊字符被识别为其他内容，并且设置请求头 12345678data = await instance.post(&#x27;/upload_single_base64&#x27;, &#123; file: encodeURIComponent(Base64), filename: _file.name &#125;, &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125; &#125;) 预览图片，处理文件名缩略图的实现使用给img的src绑定base64来处理。 123base64 = await changeBase64(_file) upload_abbre.style.display = &#x27;block&#x27; upload_abbre_img.src = base64 文件名的处理需要用到readAsArrayBuffer 和sparkMD5，下面对这两个方法分别做介绍。 readAsArrayBuffer 读取指定的Blob中的内容, 一旦完成，result 属性中保存的将是被读取文件的 ArrayBuffer数据对象。 ArrayBuffer 对象用来表示通用的原始二进制数据缓冲区 SparkMD5是一种JavaScript库，用于计算文件的MD5哈希值。它可以用于在浏览器中计算文件的哈希值，而不需要将整个文件上传到服务器。SparkMD5通过分块处理文件，每个块使用JavaScript的ArrayBuffer对象来读取，以便可以快速计算文件的哈希值。 12345678910111213141516171819const changeBuffer = file =&gt; &#123; return new Promise(resolve =&gt; &#123; let fileReader = new FileReader() fileReader.readAsArrayBuffer(file) fileReader.onload = ev =&gt; &#123; let buffer = ev.target.result, spark = new SparkMD5.ArrayBuffer(), Hash; spark.append(buffer) Hash = spark.end() suffix = /\\.([a-zA-Z0-9]+)$/.exec(_file.name)[1] console.log(buffer) console.log(spark) console.log(Hash) resolve(&#123; buffer, Hash, suffix, filename: `$&#123;Hash&#125;.$&#123;suffix&#125;` &#125;) &#125; &#125;) &#125; 我们创建了一个SparkMD5.ArrayBuffer实例和一个FileReader实例。当用户选择一个文件后，我们使用FileReader读取文件并将数据附加到SparkMD5实例中。最后，我们调用SparkMD5的end()方法来计算文件的哈希值，随后获取文件原本的后缀值拼接到我们生成的哈希值后，作为文件的新文件名。 上传进度条使用axios提供的onUploadProgress来实时获取文件上传进度，这个API的实现实际是基于XMLHttpRequest的upload事件封装的，upload事件本身就提供loaded和total属性。 1234567data = await instance.post(&#x27;/upload_single&#x27;, formData, &#123; onUploadProgress(ev) &#123; let &#123; loaded, total &#125; = ev upload_progress.style.display = &#x27;block&#x27; upload_progress_value.style.width = `$&#123;loaded / total * 100&#125;%` &#125; &#125;) 在这个例子中，我们POST了一个请求到&#x2F;upload_single，并传递了一个对象。该对象包含一个onUploadProgress.属性，该属性是一个回调函数。每当上传进度发生变化时，该函数会被调用。我们可以在该函数中将上传进度百分比输出到控制台。 多文件上传html结构 123456789101112&lt;div class=&quot;item&quot;&gt; &lt;h3&gt;多文件上传&lt;/h3&gt; &lt;section class=&quot;upload_box&quot; id=&quot;upload5&quot;&gt; &lt;input type=&quot;file&quot; class=&quot;upload_inp&quot; multiple&gt; &lt;div class=&quot;upload_button_box&quot;&gt; &lt;button class=&quot;upload_button select&quot;&gt;选择文件&lt;/button&gt; &lt;button class=&quot;upload_button upload&quot;&gt;上传到服务器&lt;/button&gt; &lt;/div&gt; &lt;ul class=&quot;upload_list&quot;&gt; &lt;/ul&gt; &lt;/section&gt; &lt;/div&gt; 除了通过循环发送每个文件的请求之外，这里还有一些需要处理的小问题。 首先就是当我们选择完文件后，想要删除其中任意一个，如何为每一个文件绑定一个唯一的id值以确保我们能获取到正确的待删除文件。这里使用random生成随机数再乘以当前的时间来确保每一个文件的id都不同。 1234const createRandom = () =&gt; &#123; let ran = Math.random() * new Date() return ran.toString(16).replace(&#x27;.&#x27;, &#x27;&#x27;)&#125; 123456789101112131415_files = Array.from(upload_inp.files) let str = `` _files = _files.map(file =&gt; &#123; return &#123; file, filename: file.name, key: createRandom() &#125; &#125;) _files.forEach((item, index) =&gt; &#123; str += `&lt;li key=$&#123;item.key&#125;&gt; &lt;span&gt;文件$&#123;index + 1&#125;：$&#123;item.filename&#125;&lt;/span&gt; &lt;span&gt;&lt;em&gt;移除&lt;/em&gt;&lt;/span&gt; &lt;/li&gt;` &#125;) 循环发送请求 12345678910111213141516171819202122232425262728293031323334let upload_list_arr = Array.from(upload_list.querySelectorAll(&#x27;li&#x27;)) _files = _files.map(item =&gt; &#123; let fm = new FormData //获取当前循环的li let curLi = upload_list_arr.find(liBox =&gt; liBox.getAttribute(&#x27;key&#x27;) === item.key), //获取最后一个span，复写删除变成百分比 curSpan = curLi ? curLi.querySelector(&#x27;span:nth-last-child(1)&#x27;) : null; fm.append(&#x27;file&#x27;, item.file) fm.append(&#x27;filename&#x27;, item.filename) return instance.post(&#x27;upload_single&#x27;, fm, &#123; onUploadProgress(ev) &#123; //检测每一个上传进度 curSpan.innerHTML = `$&#123;(ev.loaded / ev.total * 100).toFixed(2)&#125;%` &#125; &#125;).then(data =&gt; &#123; if (+data.code === 0) &#123; if (curSpan) &#123; curSpan.innerHTML = `100%` &#125; return &#125; return Promise.reject() &#125;) &#125;) Promise.all(_files).then(() =&gt; &#123; alert(&#x27;恭喜您，所有文件都上传成功&#x27;) &#125;).catch(() =&gt; &#123; alert(&#x27;上传过程中出现问题，请稍后再试&#x27;) &#125;).finally(() =&gt; &#123; handleDisable(false) _files = [] upload_list.innerHTML = &#x27;&#x27; upload_list.style.display = &#x27;none&#x27; &#125;) 拖拽上传主要实现方式为监听drop事件，注意当鼠标拖入目标区域时，dragover事件会被一直触发，这里需要手动阻止默认事件的发生。 另外，上传的过程中，目标区域需要设置一个遮罩层提示用户上传文件正在进行中。 1234567891011121314151617181920212223242526272829upload.addEventListener(&#x27;drop&#x27;, function (ev) &#123; ev.preventDefault() let file = ev.dataTransfer.files[0] if (!file) return uploadFile(file) &#125;)const uploadFile = async file =&gt; &#123; if (isRun) return isRun = true //显示遮罩层 upload_mark.style.display = &#x27;block&#x27; try &#123; let fm = new FormData(), data; fm.append(&#x27;file&#x27;, file) fm.append(&#x27;filename&#x27;, file.name) data = await instance.post(&#x27;/upload_single&#x27;, fm); if (+data.code === 0) &#123; alert(&#x27;上传成功&#x27;) return &#125; throw data.codeText &#125; catch (err) &#123; alert(&#x27;文件上传失败&#x27;) &#125; finally &#123; upload_mark.style.display = &#x27;none&#x27; isRun = false &#125; &#125; 大文件分片上传与断点重传在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。 大文件上传我们需要考虑三个方面： 切片：拆分上传请求 断点续传 显示上传进度和暂停上传 切片识别切片来源 保证切片拼接顺序 我们一般采用编码的方式进行上传，获取文件对应的二进制内容。 计算出内容的总大小，根据文件大小切成对应的分片。 上传时标识出当前文件，告诉后端上传到了第几个(可以用时间戳形式)。 不加表示的话，后端在追加切片时，无法识别切片顺序 接口异常的情况下无法正确拼接 实现根据文件名、文件长度等基本信息进行拼接根据文件的二进制内容计算文件的hash，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大.将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可 断点续传我们在上传或者下载文件的时候，如果已经进行了一部分，这时候网络故障、页面关闭的情况下，不需要从头开始操作，而是从指定位置继续进行操作，这种处理方式就是所说的“断点续传” 断点： 的由来是在下载过程中，将一个下载文件分成了多个部分，同时进行多个部分一起的下载，当某个时间点，任务被暂停了，此时下载暂停的位置就是断点了。续传：一个任务从暂停到开始时，会从上一次任务暂停处开始(可以每次传输成功后加一个表示为告诉前端传输进度)。 实现思路： 保存已上传的切片信息 选择未上传的切片进行上传 全部上传成功后后端进行文件合并 实现方案： 本地存储：我们可以利用localstorage，cookie等方式存储在浏览器内，这种情况下我们不依赖于后端，直接本地读取就行。清理了本地文件，会导致上传记录丢失。 服务器知道我们已经传输到了哪些切片，我们通过接口去传输未上传的切片即可 这里采用第二种方法实现 上传进度与前面提到的方法相同 123456789101112131415161718const changeBuffer = file =&gt; &#123; return new Promise(resolve =&gt; &#123; let fileReader = new FileReader() fileReader.readAsArrayBuffer(file) fileReader.onload = ev =&gt; &#123; let buffer = ev.target.result, spark = new SparkMD5.ArrayBuffer(), HASH; spark.append(buffer) HASH = spark.end() suffix = /\\.([a-zA-Z0-9]+)$/.exec(_file.name)[1] console.log(buffer) console.log(spark) console.log(HASH) resolve(&#123; buffer, HASH, suffix, filename: `$&#123;HASH&#125;.$&#123;suffix&#125;` &#125;) &#125; &#125;) &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100upload_inp.addEventListener(&#x27;change&#x27;, async function () &#123; _file = upload_inp.files[0] if (!_file) return; handleDisable(true) upload_button_select.classList.add(&#x27;loading&#x27;) upload_progress.style.display = &#x27;block&#x27; let already = [], data = null, &#123; HASH, suffix &#125; = await changeBuffer(_file) //获取已经上传的切片信息 try &#123; data = await instance.get(&#x27;/upload_already&#x27;, &#123; params: &#123; HASH &#125; &#125;); if (+data.code === 0) &#123; already = data.fileList &#125; &#125; catch (err) &#123; &#125; //实现文件切片处理【固定数量&amp;&amp;固定大小】 let maxSize = 1024 * 100, index = 0, chunks = [], count = _file.size / maxSize; if (count &gt; 100) &#123; max = _file.size / 100; count = 100 &#125; while (index &lt; count) &#123; chunks.push(&#123; file: _file.slice(index * max, (index + 1) * max), filename: `$&#123;HASH&#125;_$&#123;index + 1&#125;.$&#123;suffix&#125;` &#125;) index++ &#125; index = 0; //上传成功的处理 const clear = () =&gt; &#123; upload_button_select.classList.remove(&#x27;loading&#x27;) upload_progress.style.display = &#x27;none&#x27; upload_progress_value.style.width = &#x27;0%&#x27; &#125; const complete = async () =&gt; &#123; //管控进度条 index++; upload_progress_value.style.width = `$&#123;index / count * 100&#125;%` if (index &lt; count) return; upload_progress_value.style.width = `100%` //当所有切片都上传成功，合并切片 try &#123; data = await instance.post(&#x27;/upload_merge&#x27;, &#123; HASH, count &#125;, &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125; &#125;); if (+data.code === 0) &#123; alert(&#x27;文件上传成功&#x27;) clear() return; &#125; throw data.codeText &#125; catch (err) &#123; alert(&#x27;切片合并失败&#x27;) clear(); &#125; finally &#123; handleDisable(false) &#125; &#125; //上传切片 chunks.forEach(chunk =&gt; &#123; //已经上传的无需再上传 if (already.length &gt; 0 &amp;&amp; already.includes(chunk.filename)) &#123; complete() return; &#125; let fm = new FormData; fm.append(&#x27;file&#x27;, chunk.file) fm.append(&#x27;filename&#x27;, chunk.filename) instance.post(&#x27;/upload_chunk&#x27;, fm).then(data =&gt; &#123; if (+data.code === 0) &#123; complete() return &#125; return Promise.reject(data.codeText) &#125; ).catch(() =&gt; &#123; alert(&#x27;有切片上传失败&#x27;) clear() &#125;) &#125;) //使用file原型链上的slice方法 console.log(_file) &#125;)","tags":["项目"],"categories":["项目"]},{"title":"单点登录的四种实现方式","path":"/2024/03/19/单点登录的四种实现方式/","content":"在做单点登录功能的时候，在网络上搜索了很多文章，大部分都是站在后端如何处理session共享、有无状态登录的角度攥写的，并没有综合前端如何处理多个子系统之间传输token的角度来说明，故此整合了这样一篇笔记，从多个角度尽量全面地来说明单点登录的几种实方式。 引入众所周知，HTTP是无状态的协议，这意味着服务器无法确认用户的信息。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是Cookie。 如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。Session相当于在服务器中建立了一份“客户明细表”。 HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为SESSIONID的Cookie，它的值是Session的id值。其实Session是依据Cookie来识别是否是同一个用户。 所以，一般我们单系统实现登录会这样做： 登录：将用户信息保存在Session对象中 如果在Session对象中能查到，说明已经登录 如果在Session对象中查不到，说明没登录（或者已经退出了登录） 注销（退出登录）：从Session中删除用户的信息 记住我（关闭掉浏览器后，重新打开浏览器还能保持登录状态）：配合Cookie来用 单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是不共享的。 解决系统之间Session不共享问题有一下几种方案： Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】 根据请求的IP进行Hash映射到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】 把Session数据放在Redis中（使用Redis模拟Session）【建议】 我们可以将登录功能单独抽取出来，做成一个子系统。 SSO系统生成一个token，并将用户信息存到Redis中，并设置过期时间 其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中 每次请求时，Cookie都会带上，拦截器得到token，判断是否已经登录 到这里，其实我们会发现其实就两个变化： 将登陆功能抽取为一个系统（SSO），其他系统请求SSO进行登录 本来将用户信息存到Session，现在将用户信息存到Redis 上面我们解决了Session不能共享的问题，但其实还有另一个问题。Cookie是不能跨域的 比如说，我们请求&lt;https://www.google.com/&gt;时，浏览器会自动把google.com的Cookie带过去给google的服务器，而不会把&lt;https://www.baidu.com/&gt;的Cookie带过去给google的服务器。 这就意味着，由于域名不同，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。 针对Cookie存在跨域问题，有几种解决方案： 服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了 多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。 将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了） 到这里，我们已经可以实现单点登录了。 到目前为止，我们在单点登录的过程中遇到了这样几个问题： 1、session共享问题（有状态登录） 2、cookie跨域问题（解决token存储问题） 其中第一个问题除了上面提到的几种方案之外，还可以通过做无状态登录来解决。 接下来从这些方面来介绍目前存在的一些方案。 共享Session共享Session可谓是实现单点登录最直接、最简单的方式。将用户认证信息保存于Session中，即以Session内存储的值为用户凭证，这在单个站点内使用是很正常也很容易实现的，而在用户验证、用户信息管理与业务应用分离的场景下即会遇到单点登录的问题，在应用体系简单，子系统很少的情况下，可以考虑采用Session共享的方法来处理这个问题。 这个架构可以使用基于Redis的Session共享方案。将Session存储于Redis上，然后将整个系统的全局Cookie Domain设置于顶级域名上，这样SessionID就能在各个子系统间共享。分布式Session共享解决方案，这篇推荐大家看下。 这个方案存在着严重的扩展性问题，首先，http://ASP.NET的Session存储必须为SessionStateItemCollection对象，而存储的结构是经过序列化后经过加密存储的。 并且当用户访问应用时，他首先做的就是将存储容器里的所有内容全部取出，并且反序列化为SessionStateItemCollection对象。 这就决定了他具有以下约束： 1.Session中所涉及的类型必须是子系统中共同拥有的（即程序集、类型都需要一致），这导致Session的使用受到诸多限制； 2.跨顶级域名的情况完全无法处理； 基于OpenId的单点登录这种单点登录将用户的身份标识信息简化为OpenId存放于客户端，当用户登录某个子系统时，将OpenId传送到服务端，服务端根据OpenId构造用户验证信息，多用于C&#x2F;S与B&#x2F;S相结合的系统，属于有状态登录，流程如下： 由上图可以看到，这套单点登录依赖于OpenId的传递，其验证的基础在于OpenId的存储以及发送。 1.当用户第一次登录时，将用户名密码发送给验证服务； 2.验证服务将用户标识OpenId返回到客户端； 3.客户端进行存储； 4.访问子系统时，将OpenId发送到子系统； 5.子系统将OpenId转发到验证服务； 6.验证服务将用户认证信息返回给子系统； 7.子系统构建用户验证信息后将授权后的内容返回给客户端。 这套单点登录验证机制的主要问题在于他基于C&#x2F;S架构下将用户的OpenId存储于客户端，在子系统之间发送OpenId，而B&#x2F;S模式下要做到这一点就显得较为困难。为了处理这个问题我们将引出下一种方式，这种方式将解决B&#x2F;S模式下的OpenId的存储、传递问题。 基于Cookie的OpenId存储方案我们知道，Cookie的作用在于充当一个信息载体在Server端和Browser端进行信息传递，而Cookie一般是以域名为分割的，例如http://a.xxx.com与http://b.xxx.com的Cookie是不能互相访问的，但是子域名是可以访问上级域名的Cookie的。即http://a.xxx.com和http://b.xxx.com是可以访问http://xxx.com下的Cookie的，于是就能将顶级域名的Cookie作为OpenId的载体。 验证步骤和上第二个方法非常相似： 1、 在提供验证服务的站点里登录； 2、 将OpenId写入顶级域名Cookie里； 3、 访问子系统（Cookie里带有OpenId） 4、 子系统取出OpenId通过并向验证服务发送OpenId 5、 返回用户认证信息 6、 返回授权后的内容 在以上两种方法中我们都可以看到通过OpenId解耦了Session共享方案中的类型等问题，并且构造用户验证信息将更灵活，子系统间的验证是相互独立的，但是在第三种方案里，我们基于所有子系统都是同一个顶级域名的假设，而在实际生产环境里有多个域名是很正常的事情，那么就不得不考虑跨域问题究竟如何解决。 基于jwt的无状态单点登录方案登录状态无状态登录微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 带来的好处是什么呢？ 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩 减小服务端存储压力 无状态登录流程无状态登录的流程： 当客户端第一次请求服务时，服务端对用户进行信息认证（登录） 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证 以后每次请求，客户端都携带认证的token 服务的对token进行解密，判断是否有效。 jwt实现无状态登录JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权； 数据格式JWT包含三部分数据： Header：头部，通常头部有两部分信息： token类型：JWT 加密方式：base64（HS256） Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息（注意，这里因为采用base64编码，可解码，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64编码，得到第二部分数据 Signature：签名，是整个数据的认证信息。根据前两步的数据，再加上指定的密钥（secret）（不要泄漏，最好周期性更换），通指定的算法编码生成。首先，需要指定一个密码（secret）。该密码仅仅保存在服务器中，并且不能向用户公开。然后，使用标头中所指定的签名算法（默认为HS256）根据以下公式生成签名。 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(claims), secret) JWT交互流程 用户登录 服务的认证，通过后根据secret生成token 将生成的token返回给浏览器，客户端在接收到服务器返回的JWT，就将其保存在Cookie或者localStoreage中，此后，客户端的每次请求都到带上Jwt。如果将它存储在cookie中，就可以自动发送，但是不会解决跨域，因此一般是将它放入到HTTP请求的Header Authorization字段中。当跨域时，也可以将JWT被放置于POST请求的数据主体中。 用户每次请求携带token 服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息 处理请求，返回响应结果 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。 非对称加密加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类： 对称加密，如AES 基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。 优势：算法公开、计算量小、加密速度快、加密效率高 缺陷：双方都使用同样密钥，安全性得不到保证 非对称加密，如RSA 基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端 私钥加密，持有公钥才可以解密 公钥加密，持有私钥才可解密 优点：安全，难以破解 缺点：算法比较耗时 不可逆加密，如MD5，SHA 基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。 存在的问题 JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。 生产的token可以包含基本信息，比如id、用户昵称、头像等信息，避免再次查库 存储在客户端，不占用服务端的内存资源 JWT默认不加密，但可以加密。生成原始令牌后，可以再次对其进行加密。 当JWT未加密时，一些私密数据无法通过JWT传输。 JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。 JWT本身包含认证信息，token是经过base64编码，所以可以解码，因此token加密前的对象不应该包含敏感信息，一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。 为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输 CAS（Central Authentication Service）思想CAS（Central Authentication Service）是一个开源的认证系统，它主要用于为Web应用程序创建和维护单点登录会话。它提供了一个安全可靠的方式来验证用户的身份，并且可以集成到各种Web应用程序中。在单点登录（SSO）环境中，CAS扮演着非常重要的角色。它充当了一个中心认证服务器，负责验证用户的身份，并生成会话令牌，该令牌可以由其他应用程序用于验证用户的身份。这样，用户只需要在一个应用程序中登录，就可以在其他应用程序中无缝地访问，而无需再次输入用户名和密码。CAS还提供了多种认证机制，包括基于令牌的认证、基于密码的认证和多因素认证等。此外，它还支持多种协议，如CAS、OAuth、SAML等，这使得它可以与各种不同的Web应用程序集成。 如果已经将登录单独抽取成系统出来，我们还能这样玩。现在我们有两个系统，分别是www.java3y.com和www.java4y.com，一个SSOwww.sso.com 首先，用户想要访问系统Awww.java3y.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统Awww.java3y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下： www.sso.com?service=www.java3y.com sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上） 全局会话是若干客户端通过浏览器和单一认证中心之间建立并保持的会话，当某一客户端重定向访问认证中心进行首次登录操作时，浏览器地址栏会由客户端的域名变为认证中心的域名，相当于浏览器发起了一次访问认证中心的请求并建立起全局会话，此时全局会话的JSESSIONID会自动地被浏览器保存在认证中心域名下的cookie中。后续其它客户端再在此台浏览器重定向访问认证中心时，由于浏览器地址栏请求的域名都是认证中心的域名，浏览器会自动带上该域名的cookie访问认证中心，由于cookie中jsessionid相同的，所以是一个会话，称为全局会话，实现了session共享。 随后，认证中心重定向回系统A，并把Token携带过去给系统A，重定向的地址如下： www.java3y.com?token=xxxxxxx 接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（创建Session）。到此，系统A和用户已经是登录状态了。 此时，用户想要访问系统Bwww.java4y.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统Bwww.java4y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下： www.sso.com?service=www.java4y.com 注意，因为之前用户与认证中心www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心www.sso.com是可以带上Cookie的。 认证中心根据带过来的Cookie发现已经与用户建立了全局会话了，认证中心重定向回系统B，并把Token携带过去给系统B，重定向的地址如下： www.java4y.com?token=xxxxxxx 接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（创建Session）。到此，系统B和用户已经是登录状态了。 看到这里，其实就可以理解为SSO认证中心就类似一个中转站，这里实现的仍然是一个有状态登录。","tags":["项目"],"categories":["项目"]},{"title":"大量数据渲染的优化方案","path":"/2024/03/17/上万条数据渲染优化/","content":"方式1：使用requestAnimationFrame 不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次 在渲染大量数据时，避免一次性将所有数据都渲染出来可以提高性能，以保持界面的流畅性。以下是一个示例代码，演示如何使用requestAnimationFrame来分批渲染大量数据，避免卡住界面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt;控件&lt;/ul&gt; &lt;script&gt; setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000 // 一次插入 20 条，可以根据实际性能调整 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector(&quot;ul&quot;); function add() &#123; // 优化性能，使用文档片段插入，减少回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement(&quot;li&quot;); li.innerText = Math.floor(Math.random() * total); fragment.appendChild(li); &#125; ul.appendChild(fragment); countOfRender += 1; loop(); &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; // 使用requestAnimationFrame在每一帧中执行渲染 window.requestAnimationFrame(add); &#125; &#125; loop(); &#125;, 0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码会将十万条数据分批插入到ul列表中，每次插入20条数据，并通过requestAnimationFrame在每一帧中执行渲染，保证不卡住界面。这样用户可以逐步看到数据的渲染过程，而不是等待所有数据都渲染完毕后才显示。这种方式可以提高用户体验并避免界面卡顿。 方式2：使用虚拟滚动使用虚拟滚动（Virtual Scrolling）可以在渲染大量数据时提高性能，只渲染可见区域的数据，而不是将所有数据都插入到DOM中。这样可以减少DOM操作和内存占用，从而提升性能和响应速度。以下是使用虚拟滚动完成这道题的示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; height: 300px; overflow: auto; &#125; .item &#123; height: 30px; line-height: 30px; border-bottom: 1px solid #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; setTimeout(() =&gt; &#123; const total = 100000; const itemHeight = 30; const container = document.querySelector(&quot;.container&quot;); const content = document.querySelector(&quot;.content&quot;); // 创建并设置虚拟内容的总高度 let spacer = document.createElement(&quot;div&quot;); content.appendChild(spacer); const visibleHeight = container.clientHeight; const visibleItemCount = Math.ceil(visibleHeight / itemHeight); // 创建一个固定内容的数组 const data = Array.from(&#123; length: total &#125;, (_, index) =&gt; index); function renderItems() &#123; const scrollTop = container.scrollTop; const startIndex = Math.floor(scrollTop / itemHeight); const endIndex = startIndex + visibleItemCount; // 更新spacer高度来模拟滚动位置之前的未渲染内容 spacer.style.height = `$&#123;startIndex * itemHeight&#125;px`; const itemsFragment = document.createDocumentFragment(); for (let i = startIndex; i &lt; endIndex &amp;&amp; i &lt; total; i++) &#123; const item = document.createElement(&quot;div&quot;); item.className = &quot;item&quot;; item.innerText = `Item $&#123;i&#125;`; itemsFragment.appendChild(item); &#125; // 移除旧的项目并添加新的项目 Array.from(content.children).forEach(child =&gt; &#123; if (child !== spacer) content.removeChild(child); &#125;); content.appendChild(itemsFragment); // 调整内容区域的总高度以适应新的spacer高度 content.style.height = `$&#123;Math.max(total * itemHeight - spacer.style.height.replace(&#x27;px&#x27;, &#x27;&#x27;), 0)&#125;px`; &#125; function handleScroll() &#123; startIndex = Math.floor(container.scrollTop / itemHeight); endIndex = startIndex + visibleItemCount; renderItems(); &#125; container.addEventListener(&quot;scroll&quot;, handleScroll); renderItems(); &#125;, 0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上述代码中，通过设置一个具有固定高度的容器，使用overflow: auto来实现滚动。通过计算可见区域的高度和单个元素的高度，确定可见区域能容纳的元素数量。然后根据滚动位置计算出当前可见区域的元素索引范围，只渲染这一部分数据，从而实现虚拟滚动。随着滚动事件的触发，动态更新可见区域的元素。这样在大量数据的情况下，只有可见区域的元素会被渲染，大大提高了性能和响应速度。 其核心思想就是在处理用户滚动时，只改变列表在可视区域的渲染部分，具体步骤为： 先计算可见区域起始数据的索引值 startIndex和当前可见区域结束数据的索引值 endIndex，假如元素的高度是固定的，那么 startIndex的算法很简单，即 startIndex = Math.floor(scrollTop/itemHeight)，endIndex = startIndex + (clientHeight/itemHeight) - 1，再根据 startIndex 和 endIndex取相应范围的数据，渲染到可视区域，然后再计算 startOffset（上滚动空白区域）和 endOffset（下滚动空白区域），这两个偏移量的作用就是来撑开容器元素的内容，从而起到缓冲的作用，使得滚动条保持平滑滚动，并使滚动条处于一个正确的位置 上述的操作可以总结成五步： 不把长列表数据一次性全部直接渲染在页面上 截取长列表一部分数据用来填充可视区域 长列表数据不可视部分使用空白占位填充（下图中的 startOffset和 endOffset区域） 监听滚动事件根据滚动位置动态改变可视列表 监听滚动事件根据滚动位置动态改变空白填充","tags":["前端"],"categories":["前端性能优化"]},{"title":"图片懒加载的4种实现方式","path":"/2024/03/16/图片懒加载/","content":"图片懒加载的原理是没有在可视区域的图片暂时不加载图片，等进入可视区域后在加载图片，这样可以减少初始页面加载的图片数量而提升页面加载速度。 图片懒加载在提升页面加载速度的同时也会伴随用户看其他未展示的图片时会有等待时间；图片加载显示会伴有布局抖动等问题。 方案图片懒加载的关键是：判断一个元素是否在可视区域。 img的loading属性设为“lazy” HTMLImageElement 的 loading 属性为一个字符串，它的值会提示 用户代理 告诉浏览器不在可视视口内的图片该如何加载。这样一来，通过推迟图片加载仅让其在需要的时候加载而非页面初始载入时立刻加载，优化了页面的载入。lazy 告诉用户代理推迟图片加载直到浏览器认为其需要立即加载时才去加载。例如，如果用户正在往下滚动页面，值为 lazy 会导致图片仅在马上要出现在 可视视口中时开始加载。 使用方法12&lt;img src=&quot;xxx.jpg&quot; loading=&quot;lazy&quot; /&gt; 缺点虽然整个方案简单性能好，但问题也是最多的，所以很少使用这种方案。 前面提到图片懒加载用户看其他未展示的图片时会有等待时间，一般会设置一个默认图片，这种方案不能设置默认图片 图片的加载数量和图片的布局、可视区域尺寸有关，难以控制 图片的加载顺序也难以控制 该方案能粗略的实现图片懒加载基本功能。 通过offsetTop来计算是否在可视区域内可视区域高度是 document.documentElement.clientHeight ，而可视区域的位置是在滚动条滚动位置 scrollTop 到 scrollTop+document.documentElement.clientHeight之间。因此通过 image.offsetTop &lt;= document.documentElement.clientHeight + document.documentElement.scrollTop 判断图片是否可以在可视区域内。 12345678910111213function lazyload() &#123; var lazyImages = document.querySelectorAll(&quot;.lazyload&quot;); lazyImages.forEach(function (image) &#123; //如果元素距离文档顶部的高度小于浏览器的滚动高度加浏览器的可视高度，则需要加载 if ( image.offsetTop &lt;= document.documentElement.clientHeight + document.documentElement.scrollTop) &#123; image.src = image.getAttribute(&quot;data-src&quot;); &#125; &#125;);&#125; window.onscroll = function () &#123; lazyload();&#125;; 12&lt;img src=&quot;./default.gif&quot; class=&quot;lazyload&quot; data-src=&quot;./photo-1.jpg&quot; /&gt; 采用getBoundingClientRect原理都是一样的，只不过是判断元素出现在可视范围内的方式不同。 getBoundingClientRect用于获取其相对于视口的位置，这种方式更容易理解。 该api返回值是一个 DOMRect对象，拥有left, top, right, bottom, x, y, width, 和 height属性 123456789101112131415161718function isInViewPort(element) &#123; const viewWidth = window.innerWidth || document.documentElement.clientWidth; const viewHeight = window.innerHeight || document.documentElement.clientHeight; const &#123; top, right, bottom, left, &#125; = element.getBoundingClientRect();​ return ( top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight );&#125; Intersection ObserverIntersectionObserver的作用是监听目标元素与祖先元素是否有相交（默认是浏览器的视口），如果相交就触发事件。使用IntersectionObserver完成懒加载，优势在于我们不用再去计算元素距离判断图片是否已经出现在视口了，当图片出现在视口内时它会自动触发回调，完成我们回调内部的业务逻辑。 使用步骤主要分为两步：创建观察者和传入被观察者 创建观察者1234567891011const options = &#123; // 表示重叠面积占被观察者的比例，从 0 - 1 取值， // 1 表示完全被包含 threshold: 1.0, root:document.querySelector(&#x27;#scrollArea&#x27;) // 必须是目标元素的父级元素&#125;;​const callback = (entries, observer) =&gt; &#123; ....&#125;​const observer = new IntersectionObserver(callback, options); 通过new IntersectionObserver创建了观察者 observer，传入的参数 callback 在重叠比例超过 threshold 时会被执行` 关于callback回调函数常用属性如下： 123456789101112// 上段代码中被省略的 callbackconst callback = function(entries, observer) &#123; entries.forEach(entry =&gt; &#123; entry.time; // 触发的时间 entry.rootBounds; // 根元素的位置矩形，这种情况下为视窗位置 entry.boundingClientRect; // 被观察者的位置举行 entry.intersectionRect; // 重叠区域的位置矩形 entry.intersectionRatio; // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算） entry.target; // 被观察者 &#125;);&#125;; 传入被观察者通过 observer.observe(target) 这一行代码即可简单的注册被观察者 123const target = document.querySelector(&#x27;.target&#x27;);observer.observe(target); 举例假如我们需要实现图片加载前loading的效果的话，我们就可以给img的src设为loading图片的路径，data-src设为图片真实路径，在上述callback函数，将data-src的值赋给src即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app &#123; display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; &#125; .img &#123; height: 300px; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;img class=&quot;img&quot; src=&quot;./loading.gif&quot; data-src=&quot;https://p26-passport.byteacctimg.com/img/user-avatar/fd965033fba9d2b1b67d0dd6d1c80ad3~150x150.awebp&quot; alt=&quot;&quot;&gt; &lt;!-- ......此处省略一堆img --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const config = &#123; root:null, //监听元素的祖先元素dom对象，其边界盒将被视作视口。默认为浏览器视口 rootMargin:&#x27;0px 0px 0px 0px&#x27;, // 距离视口多远触发回调函数 threshold:&#x27;0&#x27; // 目标元素与设置root元素相交的比例，若指定值为 1.0，则意味着整个元素都在可见范围内时才触发回调 &#125; var observer = new IntersectionObserver((entries, observer) =&gt; &#123; entries.forEach(entry =&gt; &#123; // isIntersecting为true说明出现在视口了 if (entry.isIntersecting) &#123; entry.target.src = entry.target.dataset.src // 更改过地址的img 就取消监听 优化性能 observer.unobserve(entry.target) &#125; &#125;) &#125;,config ); const imgs = document.querySelectorAll(&#x27;img&#x27;) // 使用observer.observe监听所有的img imgs.forEach(img =&gt; &#123; observer.observe(img) &#125;)&lt;/script&gt;&lt;/html&gt; 优点Intersection Observer的优点在于不需要对事件进行监听，而上面两个方法都需要对类似于scroll事件进行监听，如果渲染列表很长，有可能会造成页面卡顿，因为scroll事件伴随了大量的计算，会造成资源方面的浪费","tags":["前端"],"categories":["前端性能优化"]},{"title":"Vue2与Vue3 响应式原理","path":"/2024/03/13/响应式原理/","content":"发布订阅、观察者设计模式观察者模式观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新 观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯 实现代码如下： 被观察者模式 123456789101112131415161718class Subject &#123; constructor() &#123; this.observerList = []; &#125; addObserver(observer) &#123; this.observerList.push(observer); &#125; removeObserver(observer) &#123; const index = this.observerList.findIndex(o =&gt; o.name === observer.name); this.observerList.splice(index, 1); &#125; notifyObservers(message) &#123; const observers = this.observeList; observers.forEach(observer =&gt; observer.notified(message)); &#125;&#125; 观察者： 12345678910111213class Observer &#123; constructor(name, subject) &#123; this.name = name; if (subject) &#123; subject.addObserver(this); &#125; &#125; notified(message) &#123; console.log(this.name, &#x27;got message&#x27;, message); &#125;&#125; 使用代码如下： 1234567const subject = new Subject();const observerA = new Observer(&#x27;observerA&#x27;, subject);const observerB = new Observer(&#x27;observerB&#x27;);subject.addObserver(observerB);subject.notifyObservers(&#x27;Hello from subject&#x27;);subject.removeObserver(observerA);subject.notifyObservers(&#x27;Hello again&#x27;); 上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表 发布订阅模式发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在 实现代码如下： 12345678910111213141516171819202122232425262728class PubSub &#123; constructor() &#123; this.messages = &#123;&#125;; this.listeners = &#123;&#125;; &#125; // 添加发布者 publish(type, content) &#123; const existContent = this.messages[type]; if (!existContent) &#123; this.messages[type] = []; &#125; this.messages[type].push(content); &#125; // 添加订阅者 subscribe(type, cb) &#123; const existListener = this.listeners[type]; if (!existListener) &#123; this.listeners[type] = []; &#125; this.listeners[type].push(cb); &#125; // 通知 notify(type) &#123; const messages = this.messages[type]; const subscribers = this.listeners[type] || []; subscribers.forEach((cb, index) =&gt; cb(messages[index])); &#125;&#125; 发布者代码如下： 123456789class Publisher &#123; constructor(name, context) &#123; this.name = name; this.context = context; &#125; publish(type, content) &#123; this.context.publish(type, content); &#125;&#125; 订阅者代码如下： 123456789class Subscriber &#123; constructor(name, context) &#123; this.name = name; this.context = context; &#125; subscribe(type, cb) &#123; this.context.subscribe(type, cb); &#125;&#125; 使用代码如下： 123456789101112131415161718192021222324252627282930const TYPE_A = &#x27;music&#x27;;const TYPE_B = &#x27;movie&#x27;;const TYPE_C = &#x27;novel&#x27;;const pubsub = new PubSub();const publisherA = new Publisher(&#x27;publisherA&#x27;, pubsub);publisherA.publish(TYPE_A, &#x27;we are young&#x27;);publisherA.publish(TYPE_B, &#x27;the silicon valley&#x27;);const publisherB = new Publisher(&#x27;publisherB&#x27;, pubsub);publisherB.publish(TYPE_A, &#x27;stronger&#x27;);const publisherC = new Publisher(&#x27;publisherC&#x27;, pubsub);publisherC.publish(TYPE_C, &#x27;a brief history of time&#x27;);const subscriberA = new Subscriber(&#x27;subscriberA&#x27;, pubsub);subscriberA.subscribe(TYPE_A, res =&gt; &#123; console.log(&#x27;subscriberA received&#x27;, res)&#125;);const subscriberB = new Subscriber(&#x27;subscriberB&#x27;, pubsub);subscriberB.subscribe(TYPE_C, res =&gt; &#123; console.log(&#x27;subscriberB received&#x27;, res)&#125;);const subscriberC = new Subscriber(&#x27;subscriberC&#x27;, pubsub);subscriberC.subscribe(TYPE_B, res =&gt; &#123; console.log(&#x27;subscriberC received&#x27;, res)&#125;);pubsub.notify(TYPE_A);pubsub.notify(TYPE_B);pubsub.notify(TYPE_C); 上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责 区别 在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列） vue2的响应式原理双向绑定的构成双向绑定由三个重要部分构成 数据层（Model）：应用的数据及业务逻辑 视图层（View）：应用的展示效果，各类UI组件 业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来 理解ViewModel它的主要职责就是： 数据变化后更新视图 视图变化后更新数据 当然，它还有两个主要部分组成 监听器（Observer）：对所有数据的属性进行监听 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 双向绑定流程1. 初始化阶段 响应式属性的创建：通过 observe 函数和 Observer 类，Vue 将组件的 data 对象转换成响应式对象。对每个属性，通过 Object.defineProperty 设置其 getter 和 setter，以便进行依赖收集和派发更新。 Dep** 实例的创建**：在响应式属性的 getter 和 setter 中闭包的 Dep 实例负责收集当前属性的所有依赖（即观察者，也就是 Watcher 实例）。 2. 组件渲染和依赖收集 Watcher** 实例的创建**：当组件渲染（或计算属性被访问，或侦听器被初始化）时，Vue 创建一个 Watcher 实例。这个实例负责评估表达式或渲染函数，并收集依赖（即被访问的响应式属性）。 依赖收集过程：在 Watcher 的构造过程中，Dep.target 被临时设置为当前的 Watcher。然后，当访问任何响应式属性的 getter 时，这个属性的 Dep 实例会调用 addDep 方法将当前的 Dep.target（也就是这个 Watcher）添加到它的依赖列表中。这样，每个被访问的响应式属性都会收集到当前的 Watcher 作为它的依赖。 3. 更新过程 当响应式属性的值发生变化（触发 setter）时，属性对应的 Dep 实例会通知它的所有依赖（即收集到的所有 Watcher 实例），调用它们的 update 方法来响应数据变化。 Watcher 的 update 方法最终会导致组件的重新渲染，或者计算属性&#x2F;侦听器的重新评估。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Vue &#123; constructor(options) &#123; this.$options = options; this.$data = options.data; // 对data选项做响应式处理 observe(this.$data); // 代理data到vm上 proxy(this); // 执行编译 new Compile(options.el, this); &#125; &#125; function observe(obj) &#123; if (typeof obj !== &quot;object&quot; || obj == null) &#123; return; &#125; new Observer(obj); &#125; class Observer &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; walk(obj) &#123; Object.keys(obj).forEach((key) =&gt; &#123; defineReactive(obj, key, obj[key]); &#125;); &#125; &#125; class Compile &#123; constructor(el, vm) &#123; this.$vm = vm; this.$el = document.querySelector(el); // 获取dom if (this.$el) &#123; this.compile(this.$el); &#125; &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; // 遍历子元素 if (this.isElement(node)) &#123; // 判断是否为节点 console.log(&quot;编译元素&quot; + node.nodeName); &#125; else if (this.isInterpolation(node)) &#123; console.log(&quot;编译插值⽂本&quot; + node.textContent); // 判断是否为插值文本 &#123;&#123;&#125;&#125; &#125; if (node.childNodes &amp;&amp; node.childNodes.length &gt; 0) &#123; // 判断是否有子元素 this.compile(node); // 对子元素进行递归遍历 &#125; &#125;); &#125; isElement(node) &#123; return node.nodeType == 1; &#125; isInterpolation(node) &#123; return node.nodeType == 3 &amp;&amp; /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(node.textContent); &#125; &#125; // 负责更新视图 class Watcher &#123; constructor(vm, key, updater) &#123; this.vm = vm this.key = key this.updaterFn = updater // 创建实例时，把当前实例指定到Dep.target静态属性上 Dep.target = this // 读一下key，触发get vm[key] // 置空 Dep.target = null &#125; // 未来执行dom更新函数，由dep调用的 update() &#123; this.updaterFn.call(this.vm, this.vm[this.key]) &#125; &#125; class Dep &#123; constructor() &#123; this.deps = []; // 依赖管理 &#125; addDep(dep) &#123; this.deps.push(dep); &#125; notify() &#123; this.deps.forEach((dep) =&gt; dep.update()); &#125; &#125; function defineReactive(obj, key, val) &#123; this.observe(val); const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; Dep.target &amp;&amp; dep.addDep(Dep.target);// Dep.target也就是Watcher实例 return val; &#125;, set(newVal) &#123; if (newVal === val) return; dep.notify(); // 通知dep执行更新方法 &#125;, &#125;); &#125; 依赖收集实现思路： defineReactive时为每⼀个key创建⼀个Dep实例 初始化视图时读取某个key，例如name1，创建⼀个watcher1 由于触发name1的getter方法，便将watcher1添加到name1对应的Dep中 当name1更新，setter触发时，便可通过对应Dep通知其管理所有Watcher更新 从上面的实现可以看出来，vue2的基于Object.defineProperty实现的get和set方法存在一定的缺陷： 检测不到对象属性的添加和删除 数组API方法无法监听到 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题 vue3的响应式原理Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了 在ES6中，我们详细讲解过Proxy的使用，就不再述说了 下面通过代码进行展示： 定义一个响应式方法reactive 123456789101112131415161718192021222324function reactive(obj) &#123; if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123; return obj &#125; // Proxy相当于在对象外层加拦截 const observed = new Proxy(obj, &#123; get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver) console.log(`获取$&#123;key&#125;:$&#123;res&#125;`) return res &#125;, set(target, key, value, receiver) &#123; const res = Reflect.set(target, key, value, receiver) console.log(`设置$&#123;key&#125;:$&#123;value&#125;`) return res &#125;, deleteProperty(target, key) &#123; const res = Reflect.deleteProperty(target, key) console.log(`删除$&#123;key&#125;:$&#123;res&#125;`) return res &#125; &#125;) return observed&#125; 测试一下简单数据的操作，发现都能劫持 123456789101112const state = reactive(&#123; foo: &#x27;foo&#x27;&#125;)// 1.获取state.foo // ok// 2.设置已存在属性state.foo = &#x27;fooooooo&#x27; // ok// 3.设置不存在属性state.dong = &#x27;dong&#x27; // ok// 4.删除属性delete state.dong // ok 再测试嵌套对象情况，这时候发现就不那么 OK&#x20; 123456const state = reactive(&#123; bar: &#123; a: 1 &#125;&#125;)// 设置嵌套对象属性state.bar.a = 10 // no ok 如果要解决，需要在get之上再进行一层代理 12345678910111213function reactive(obj) &#123; if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123; return obj &#125; // Proxy相当于在对象外层加拦截 const observed = new Proxy(obj, &#123; get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver) console.log(`获取$&#123;key&#125;:$&#123;res&#125;`) return isObject(res) ? reactive(res) : res &#125;, return observed&#125; 为什么用 Reflect.get() 和 Reflect.set()，而不是直接用 target[key]？ 根据 MDN 介绍 set() 要返回一个布尔值，比如 Reflect.set() 会返回一个是否修改成功的布尔值，直接赋值 target[key] = newValue，而不返回 true 就会报错。而且不管 Proxy 怎么修改默认行为，都可以通过 Reflect 获取默认行为。get() 同理。 vue3 的响应式核心原理即是通过 Proxy 代理目标对象的存取器，拦截存取操作，在执行收集依赖 track 以及触发更新 trigger 的方法后再完成原先的存取操作。 vue3.0 建立响应式的方法有两种： 第一个就是运用composition-api中的reactive直接构建响应式，composition-api的出现我们可以在.vue文件中，直接用setup()函数来处理之前的大部分逻辑，也就是说我们没有必要在 export default{ } 中在声明生命周期 ， data(){} 函数，watch{} , computed{} 等 ，取而代之的是我们在setup函数中，用vue3.0 reactive watch 生命周期api来到达同样的效果，这样就像react-hooks一样提升代码的复用率，逻辑性更强。 第二个就是用传统的 data(){ return{} } 形式 ,vue3.0没有放弃对vue2.0写法的支持，而是对vue2.0的写法是完全兼容的，提供了applyOptions 来处理options形式的vue组件。但是options里面的data , watch , computed等处理逻辑，还是用了composition-api中的API对应处理。 composition-api reactiveReactive 相当于当前的 Vue.observable () API，经过reactive处理后的函数能变成响应式的数据，类似于option api里面的vue处理data函数的返回值。 我们用一个todoList的demo试着尝尝鲜。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const &#123; reactive , onMounted &#125; = Vuesetup()&#123; const state = reactive(&#123; count:0, todoList:[] &#125;) /* 生命周期mounted */ onMounted(() =&gt; &#123; console.log(&#x27;mounted&#x27;) &#125;) /* 增加count数量 */ function add()&#123; state.count++ &#125; /* 减少count数量 */ function del()&#123; state.count-- &#125; /* 添加代办事项 */ function addTodo(id,title,content)&#123; state.todoList.push(&#123; id, title, content, done:false &#125;) &#125; /* 完成代办事项 */ function complete(id)&#123; for(let i = 0; i&lt; state.todoList.length; i++)&#123; const currentTodo = state.todoList[i] if(id === currentTodo.id)&#123; state.todoList[i] = &#123; ...currentTodo, done:true &#125; break &#125; &#125; &#125; return &#123; state, add, del, addTodo, complete &#125;&#125; options dataoptions形式的和vue2.0并没有什么区别 1234567891011121314151617181920212223242526272829303132333435363738394041export default &#123; data()&#123; return&#123; count:0, todoList:[] &#125; &#125;, mounted()&#123; console.log(&#x27;mounted&#x27;) &#125; methods:&#123; add()&#123; this.count++ &#125;, del()&#123; this.count-- &#125;, addTodo(id,title,content)&#123; this.todoList.push(&#123; id, title, content, done:false &#125;) &#125;, complete(id)&#123; for(let i = 0; i&lt; this.todoList.length; i++)&#123; const currentTodo = this.todoList[i] if(id === currentTodo.id)&#123; this.todoList[i] = &#123; ...currentTodo, done:true &#125; break &#125; &#125; &#125; &#125;&#125; 不同类型的Reactivevue3.0可以根据业务需求引进不同的API方法。这里需要 ① reactive建立响应式reactive，返回proxy对象，这个reactive可以深层次递归，也就是如果发现展开的属性值是引用类型的而且被引用，还会用reactive递归处理。而且属性是可以被修改的。 ② shallowReactive建立响应式shallowReactive，返回proxy对象。和reactive的区别是只建立一层的响应式，也就是说如果发现展开属性是引用类型也不会递归。 ③ readonly返回的proxy处理的对象，可以展开递归处理，但是属性是只读的，不能修改。可以做props传递给子组件使用。 ④ shallowReadonly返回经过处理的proxy对象，但是建立响应式属性是只读的，不展开引用也不递归转换，可以这用于为有状态组件创建props代理对象。 储存对象与proxy上文中我们提及到，用Reactive处理过并返回的对象是一个proxy对象。 假设存在很多组件，或者在一个组件中被多次reactive，就会有很多对proxy对象和它代理的原对象。为了能把proxy对象和原对象建立关系，vue3.0采用了WeakMap去储存这些对象关系。WeakMaps 保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 12345const rawToReactive = new WeakMap&lt;any, any&gt;()const reactiveToRaw = new WeakMap&lt;any, any&gt;()const rawToReadonly = new WeakMap&lt;any, any&gt;() /* 只读的 */const readonlyToRaw = new WeakMap&lt;any, any&gt;() /* 只读的 */","tags":["前端","Vue2","Vue3"],"categories":["Vue"]},{"title":"ES6 proxy与reflection","path":"/2024/03/13/proxy/","content":"概念定义： 用于定义基本操作的自定义行为，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等） 本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(meta programming) 元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作 用法Proxy为 构造函数，用来生成 Proxy实例 1var proxy = new Proxy(target, handler) 参数参数 target表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理）） handler通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为 handler解析关于handler拦截属性，有如下： get(target,propKey,receiver)：拦截对象属性的读取 set(target,propKey,value,receiver)：拦截对象属性的设置 has(target,propKey)：拦截propKey in proxy的操作，返回一个布尔值 deleteProperty(target,propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值 ownKeys(target)：拦截Object.keys(proxy)、for...in等循环，返回一个数组 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc），返回一个布尔值 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作 Reflect若需要在Proxy内部调用对象的默认行为，建议使用Reflect，其是ES6中操作对象而提供的新 API 基本特点： 只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在 修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false） 让Object操作都变成函数行为 用法get()get接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选 1234567891011var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, propKey) &#123; return Reflect.get(target,propKey) &#125;&#125;);proxy.name // &quot;张三&quot; get能够对数组增删改查进行拦截，下面是使数组能够读取负数的索引的代码 123456789101112131415161718function createArray(...elements) &#123; let handler = &#123; get(target, propKey, receiver) &#123; let index = Number(propKey); if (index &lt; 0) &#123; propKey = String(target.length + index); &#125; return Reflect.get(target, propKey, receiver); &#125; &#125;; let target = []; target.push(...elements); return new Proxy(target, handler);&#125;let arr = createArray(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);arr[-1] // c 注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错 123456789101112131415161718const target = Object.defineProperties(&#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125;,&#125;);const handler = &#123; get(target, propKey) &#123; return &#x27;abc&#x27;; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo// TypeError: Invariant check failed set()set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求 1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === &#x27;age&#x27;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&#x27;The age is not an integer&#x27;); &#125; if (value &gt; 200) &#123; throw new RangeError(&#x27;The age seems invalid&#x27;); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = &#x27;young&#x27; // 报错person.age = 300 // 报错 如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用 123456789101112131415const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;foo&#x27;, &#123; value: &#x27;bar&#x27;, writable: false,&#125;);const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = &#x27;baz&#x27;; &#125;&#125;;const proxy = new Proxy(obj, handler);proxy.foo = &#x27;baz&#x27;;proxy.foo // &quot;bar&quot; 注意，严格模式下，set代理如果没有返回true，就会报错 1234567891011&#x27;use strict&#x27;;const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = receiver; // 无论有没有下面这一行，都会报错 return false; &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);proxy.foo = &#x27;bar&#x27;;// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;foo&#x27; deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除 1234567891011121314151617var handler = &#123; deleteProperty (target, key) &#123; invariant(key, &#x27;delete&#x27;); Reflect.deleteProperty(target,key) return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === &#x27;_&#x27;) &#123; throw new Error(`无法删除私有属性`); &#125;&#125;var target = &#123; _prop: &#x27;foo&#x27; &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: 无法删除私有属性 取消代理12Proxy.revocable(target, handler); 使用场景Proxy其功能非常类似于设计模式中的代理模式，常用功能如下： 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 使用 Proxy 保障数据类型的准确性 123456789101112131415let numericDataStore = &#123; count: 0, amount: 1234, total: 14 &#125;;numericDataStore = new Proxy(numericDataStore, &#123; set(target, key, value, proxy) &#123; if (typeof value !== &#x27;number&#x27;) &#123; throw Error(&quot;属性只能是number类型&quot;); &#125; return Reflect.set(target, key, value, proxy); &#125;&#125;);numericDataStore.count = &quot;foo&quot;// Error: 属性只能是number类型numericDataStore.count = 333// 赋值成功 声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey 1234567891011121314151617181920212223let api = &#123; _apiKey: &#x27;123abc456def&#x27;, getUsers: function()&#123; &#125;, getUser: function(userId)&#123; &#125;, setUser: function(userId, config)&#123; &#125;&#125;;const RESTRICTED = [&#x27;_apiKey&#x27;];api = new Proxy(api, &#123; get(target, key, proxy) &#123; if(RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error(`$&#123;key&#125; 不可访问.`); &#125; return Reflect.get(target, key, proxy); &#125;, set(target, key, value, proxy) &#123; if(RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error(`$&#123;key&#125; 不可修改`); &#125; return Reflect.get(target, key, value, proxy); &#125;&#125;);console.log(api._apiKey)api._apiKey = &#x27;987654321&#x27;// 上述都抛出错误 还能通过使用Proxy实现观察者模式 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行 observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125; 观察者函数都放进Set集合，当修改obj的值，在会set函数中拦截，自动执行Set所有的观察者","tags":["前端","Javascript","ES6"],"categories":["ES6"]},{"title":"Webpack 打包优化","path":"/2024/03/12/打包优化/","content":"提取css代码 要求：让 webpack 把 css 代码内容字符串单独提取到 dist 下的 css 文件中 需要：mini-css-extract-plugin 插件来实现 步骤： 下载 mini-css-extract-plugin 插件软件包到本地项目中 1npm i --save-dev mini-css-extract-plugin 配置 webpack.config.js 让 Webpack 拥有该插件功能 123456789101112131415161718const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/i, // use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], &#125;, ], &#125;, plugins: [ // ... new MiniCssExtractPlugin() ]&#125;; 注意：不能和 style-loader 一起使用 好处：css 文件可以被浏览器缓存，减少 JS 文件体积，让浏览器并行下载 css 和 js 文件 压缩 需求：把提出的 css 文件内样式代码压缩 需要：css-minimizer-webpack-plugin 插件来实现 步骤： 下载 mini-css-extract-plugin 插件软件包到本地项目中 1npm i css-minimizer-webpack-plugin --save-dev 配置 webpack.config.js 让 Webpack 拥有该插件功能 123456789101112131415const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);module.exports = &#123; // ... // 优化 optimization: &#123; // 最小化 minimizer: [ // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 // `terser-webpack-plugin`），将下一行取消注释（保证 JS 代码还能被压缩处理） `...`, new CssMinimizerPlugin(), ], &#125;&#125;; CDN使用 需求：开发模式使用本地第三方库，生产模式下使用 CDN 加载引入 CDN定义：内容分发网络，指的是一组分布在各个地区的服务器 作用：把静态资源文件&#x2F;第三方库放在 CDN 网络中各个服务器中，供用户就近请求获取 好处：减轻自己服务器请求压力，就近请求物理延迟低，配套缓存策略 实现需求的思路图： 使用： 在 html 中引入第三方库的 CDN 地址 并用模板语法判断 123&lt;% if(htmlWebpackPlugin.options.useCdn)&#123; %&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.3/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;% &#125; %&gt; 配置 webpack.config.js 中 externals 外部扩展选项（防止某些 import 的包被打包） 12345678910// 生产环境下使用相关配置 if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 外部扩展（让 webpack 防止 import 的包被打包进来） config.externals = &#123; // key：import from 语句后面的字符串 // value：留在原地的全局变量（最好和 cdn 在全局暴露的变量一致） &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;: &#x27;bootstrap&#x27;, &#x27;axios&#x27;: &#x27;axios&#x27; &#125; &#125; 123456789const config = &#123; plugins: [ new HtmlWebpackPlugin(&#123; // ... // 自定义属性，在 html 模板中 &lt;%=htmlWebpackPlugin.options.useCdn%&gt; 访问使用 useCdn: process.env.NODE_ENV === &#x27;production&#x27; &#125;) ] &#125; 分割公共代码需求：把 2 个以上页面引用的公共代码提取 步骤： 配置 webpack.config.js 的 splitChunks 分割功能 12345678910111213141516171819const config = &#123; // ... optimization: &#123; // ... splitChunks: &#123; chunks: &#x27;all&#x27;, // 所有模块动态非动态移入的都分割分析 cacheGroups: &#123; // 分隔组 commons: &#123; // 抽取公共模块 minSize: 0, // 抽取的chunk最小大小字节 minChunks: 2, // 最小引用数 reuseExistingChunk: true, // 当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用 name(module, chunks, cacheGroupKey) &#123; // 分离出模块文件名 const allChunksNames = chunks.map((item) =&gt; item.name).join(&#x27;~&#x27;) // 模块名1~模块名2 return `./js/$&#123;allChunksNames&#125;` // 输出到 dist 目录下位置 &#125; &#125; &#125; &#125; 按需加载很多时候我们不需要一次性加载所有的JS文件，而应该在不同阶段去加载所需要的代码。webpack内置了强大的分割代码的功能可以实现按需加载。 比如，我们在点击了某个按钮之后，才需要使用使用对应的JS文件中的代码，需要使用 import() 语法： 123document.getElementById(&#x27;btn&#x27;).onclick = function() &#123; import(&#x27;./handle&#x27;).then(fn =&gt; fn.default());&#125; import() 语法，需要 @babel/plugin-syntax-dynamic-import 的插件支持，但是因为当前 @babel/preset-env 预设中已经包含了 @babel/plugin-syntax-dynamic-import，因此我们不需要再单独安装和配置。 直接 npm run build 进行构建，构建结果如下： webpack 遇到 import(****) 这样的语法的时候，会这样处理： 以 为入口新生成一个 Chunk 当代码执行到 import 所在的语句时，才会加载该 Chunk 所对应的文件（如这里的1.bundle.8bf4dc.js） 大家可以在浏览器中的控制台中，在 Network 的 Tab页 查看文件加载的情况，只有点击之后，才会加载对应的 JS 。","tags":["前端","Webpack"],"categories":["Webpack"]},{"title":"Webpack 打包模式、注入环境变量和sourcemap","path":"/2024/03/12/打包模式/","content":"打包模式告知 Webpack 使用相应模式的内置优化 分类： 模式名称 模式名字 特点 场景 开发模式 development 调试代码，实时加载，模块热替换等 本地开发 生产模式 production 压缩代码，资源优化，更轻量等 打包上线 如何设置影响 Webpack呢？ 方式1：在 webpack.config.js 配置文件设置 mode 选项1234module.exports = &#123; // ... mode: &#x27;production&#x27;&#125; 方式2：在 package.json 命令行设置 mode 参数1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --mode=production&quot;, &quot;dev&quot;: &quot;webpack serve --mode=development&quot;&#125;, 区分不同环境的不同配置 需求：在开发模式下用 style-loader 内嵌更快，在生产模式下提取 css 代码 方案1：webpack.config.js 配置导出函数，但是局限性大（只接受 2 种模式） 方案2：借助 cross-env （跨平台通用）包命令，设置参数区分环境 方案3：配置不同的 webpack.config.js （适用多种模式差异性较大情况） 主要使用方案 2 尝试，其他方案可以结合点击跳转的官方文档查看尝试 步骤： 1.下载 cross-env 软件包到当前项目 1npm i cross-env --save-dev 2..配置自定义命令，传入参数名和值（会绑定到 process.env 对象下） &#x20;3.在 webpack.config.js 区分不同环境使用不同配置 123456789101112131415161718module: &#123; rules: [ &#123; test: /\\.css$/i, // use: [&#x27;style-loader&#x27;, &quot;css-loader&quot;], use: [process.env.NODE_ENV === &#x27;development&#x27; ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader, &quot;css-loader&quot;] &#125;, &#123; test: /\\.less$/i, use: [ // compiles Less to CSS process.env.NODE_ENV === &#x27;development&#x27; ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;, ], &#125; ], &#125;, 注入环境变量 需求：前端项目中，开发模式下打印语句生效，生产模式下打印语句失效 问题：cross-env 设置的只在 Node.js 环境生效，前端代码无法访问 process.env.NODE_ENV 解决：使用 Webpack 内置的 DefinePlugin 插件 作用：在编译时，将前端代码中匹配的变量名，替换为值或表达式 配置 webpack.config.js 中给前端注入环境变量 12345678910111213const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; // ... plugins: [ // ... new webpack.DefinePlugin(&#123; // key 是注入到打包后的前端 JS 代码中作为全局变量 // value 是变量对应的值（在 corss-env 注入在 node.js 中的环境变量字符串） &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(process.env.NODE_ENV) &#125;) ]&#125; 同时在index.js文件中 12345if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; console.log = function() &#123;&#125;&#125;console.log(&#x27;开发模式下好用，生产模式下失效&#x27;) 开发环境调试source map source map：sourceMap是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中debug问题会带来非常糟糕的体验，sourceMap可以帮助我们快速定位到源代码的位置，提高我们的开发效率。sourceMap其实并不是Webpack特有的功能，而是Webpack支持sourceMap，像JQuery也支持souceMap。 问题：代码被压缩和混淆，无法正确定位源代码位置（行数和列数） 设置：webpack.config.js 配置 devtool 选项 1234module.exports = &#123; // ... devtool: &#x27;inline-source-map&#x27;&#125; inline-source-map 选项：把源码的位置信息一起打包在 JS 文件内 4. 注意：source map 适用于开发环境，不要在生产环境使用（防止被轻易查看源码位置） 多页面打包 概念：单页面：单个 html 文件，切换 DOM 的方式实现不同业务逻辑展示，后续 Vue&#x2F;React 会学到 多页面：多个 html 文件，切换页面实现不同业务逻辑展示 需求：把黑马头条-数据管理平台-内容页面一起引入打包使用 步骤： 准备源码（html，css，js）放入相应位置，并改用模块化语法导出 下载 form-serialize 包并导入到核心代码中使用 配置 webpack.config.js 多入口和多页面的设置 12345678910111213141516171819202122const config = &#123; entry: &#123; &#x27;模块名1&#x27;: path.resolve(__dirname, &#x27;src/入口1.js&#x27;), &#x27;模块名2&#x27;: path.resolve(__dirname, &#x27;src/入口2.js&#x27;), &#125;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;./[name]/index.js&#x27; &#125; plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/页面2.html&#x27;, // 模板文件 filename: &#x27;./路径/index.html&#x27;, // 输出文件 chunks: [&#x27;模块名2&#x27;] &#125;) new HtmlWebpackPlugin(&#123; template: &#x27;./public/页面2.html&#x27;, // 模板文件 filename: &#x27;./路径/index.html&#x27;, // 输出文件 chunks: [&#x27;模块名2&#x27;] &#125;) ]&#125;","tags":["前端","Webpack"],"categories":["Webpack"]},{"title":"Webpack 组成与简单使用","path":"/2024/03/12/概念与使用/","content":"概念 Webpack 是一个静态模块打包工具，从入口构建依赖图，打包有关的模块，最后用于展示你的内容 静态模块：编写代码过程中的，html，css， js，图片等固定内容的文件 打包过程，注意：只有和入口有直接&#x2F;间接引入关系的模块，才会被打包 Webpack 的作用：把静态模块内容，压缩，整和，转译等（前端工程化） 把 less&#x2F;sass 转成 css 代码 把 ES6+ 降级成 ES5 等 支持多种模块文件类型，多种模块标准语 使用要求：封装 utils 包，校验手机号和验证码长度，在 src&#x2F;index.js 中使用，使用 Webpack 打包 步骤： 新建项目文件夹 Webpack_study，初始化包环境，得到 package.json 文件 1npm init -y 新建 src 源代码文件夹（书写代码）包括 utils&#x2F;check.js 封装用户名和密码长度函数，引入到 src&#x2F;index.js 进行使用 src&#x2F;utils&#x2F;check.js 123// 封装校验手机号长度和校验验证码长度的函数export const checkPhone = phone =&gt; phone.length === 11export const checkCode = code =&gt; code.length === 6 src&#x2F;index.js 123456789/** * 目标1：体验 webpack 打包过程 */// 1.1 准备项目和源代码import &#123; checkPhone, checkCode &#125; from &#x27;../utils/check.js&#x27;console.log(checkPhone(&#x27;13900002020&#x27;))console.log(checkCode(&#x27;123123123123&#x27;))// 1.2 准备 webpack 打包的环境// 1.3 运行自定义命令打包观察效果（npm run 自定义命令） 下载 webpack webpack-cli 到项目（版本独立） 1npm i webpack webpack-cli --save-dev 📌注意：虽然 webpack 是全局软件包，封装的是命令工具，但是为了保证项目之间版本分别独立，所以这次比较特殊，下载到某个项目环境下，但是需要把 webpack 命令配置到 package.json 的 scripts 自定义命令，作为局部命令使用 项目中运行工具命令，采用自定义命令的方式（局部命令） 1npm run build 自动产生 dist 分发文件夹（压缩和优化后，用于最终运行的代码） 搭建开发环境使用 每次改动代码，都要重新打包，很麻烦，所以这里给项目集成 webpack-dev-server 开发服务器 作用：启动 Web 服务，打包输出源码在内存，并会自动检测代码变化热更新到网页 步骤； 下载 webpack-dev-server 软件包到当前项目 配置自定义命令，并设置打包的模式为开发模式1234module.exports = &#123; // ... mode: &#x27;development&#x27;&#125; 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack serve --mode=development&quot; &#125;, 使用 npm run dev 来启动开发服务器，访问提示的域名+端口号，在浏览器访问打包后的项目网页，修改代码后试试热更新效果 注意： webpack-dev-server借助 http模块创建8080 默认 Web服务 默认以 public 文件夹作为服务器根目录 webpack-dev-server根据配置，打包相关代码在内存当中，以 output.path 的值作为服务器根目录（所以可以直接自己拼接访问dist目录下内容)| 热更新原理Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。 后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。 webpack的构建流程Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 简单说 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler 编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理 输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中 修改出入口 项目根目录，新建 Webpack.config.js 配置文件 导出配置对象，配置入口，出口文件路径（别忘了修改磁盘文件夹和文件的名字） 12345678910const path = require(&#x27;path&#x27;)module.exports = &#123; entry: path.resolve(__dirname, &#x27;src/login/index.js&#x27;), output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;./login/index.js&#x27;, clean: true //生成打包内容之前，清空输出目录 &#125;&#125; 重新打包 设置解析别名路径 解析别名：配置模块如何解析，创建 import 或 require 的别名，来确保模块引入变得更简单 例如： 原来路径如下：1import &#123; checkPhone, checkCode &#125; from &#x27;../src/utils/check.js&#x27; b. 配置解析别名：在 webpack.config.js 中设置12345678const config = &#123; // ... resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;) &#125; &#125;&#125; c. 这样我们以后，引入目标模块写的路径就更简单了1import &#123; checkPhone, checkCode &#125; from &#x27;@/utils/check.js&#x27; 引入插件（plugin） 插件 html-webpack-plugin 作用：在 Webpack 打包时生成 html 文件，并引入其他打包后的资源 步骤： 下载 html-webpack-plugin 本地软件包到项目中 1npm i html-webpack-plugin --save-dev 配置 webpack.config.js 让 Webpack 拥有插件功能 1234567891011const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/login.html&#x27;, // 模板文件 filename: &#x27;./login/index.html&#x27; // 输出文件 &#125;) ]&#125; 指定以 public&#x2F;login.html 为模板复制到 dist&#x2F;login&#x2F;index.html，并自动引入其他打包后资源 运行打包命令，观察打包后 dist 文件夹下内容并运行查看效果 加载器（loader）Webpack 默认只识别 JS 和 JSON 文件内容，所以想要让 Webpack 识别更多不同内容，需要使用加载器。 加载器 css-loader：解析 css 代码 加载器 style-loader：把解析后的 css 代码插入到 DOM（style 标签之间） 加载器 less-loader：把 less 代码编译为 css 代码，还需要依赖 less 软件包 步骤： 准备 css 文件引入到 src&#x2F;login&#x2F;index.js 中（压缩转译处理等） 123456789101112/** * 目标5：打包 css 代码 * 5.1 准备 css 代码，并引入到 js 中 * 5.2 下载 css-loader 和 style-loader 本地软件包 * 5.3 配置 webpack.config.js 让 Webpack 拥有该加载器功能 * 5.4 打包后观察效果 */// 5.1 准备 css 代码，并引入到 js 中import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;import &#x27;./index.css&#x27;import &#x27;./index.less&#x27; 注意：这里只是引入代码内容让 Webpack 处理，不需定义变量接收在 JS 代码中继续使用，所以没有定义变量接收 下载 css-loader 和 style-loader 本地软件包 123npm i css-loader style-loader --save-devnpm i less less-loader --save-dev 配置 webpack.config.js 让 Webpack 拥有该加载器功能 123456789101112131415module.exports = &#123; // ... module: &#123; // 加载器 rules: [ // 规则列表 &#123; test: /\\.css$/i, // 匹配 .css 结尾的文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], // 使用从后到前的加载器来解析 css 代码和插入到 DOM &#125;, &#123; test: /\\.less$/i, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;less-loader&quot;] &#125; ] &#125;&#125;; 打包后运行 dist&#x2F;login&#x2F;index.html 观察效果，看看准备好的样式是否作用在网页上 loader和plugin的区别Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。 Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。 Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。 打包图片 资源模块：Webpack 内置了资源模块的打包，无需下载额外 loader 步骤： 配置 webpack.config.js 让 Webpack 拥有打包图片功能 占位符 【hash】对模块内容做算法计算，得到映射的数字字母组合的字符串 占位符 【ext】使用当前模块原本的占位符，例如：.png &#x2F; .jpg 等字符串 占位符 【query】保留引入文件时代码中查询参数（只有 URL 下生效） 注意：判断临界值默认为 8KB 大于 8KB 文件：发送一个单独的文件并导出 URL 地址 小于 8KB 文件：导出一个 data URI（base64字符串） 在 src&#x2F;login&#x2F;index.js 中给 img 标签添加 logo 图片 1234567891011/** * 目标9：打包资源模块（图片处理） * 9.1 创建 img 标签并动态添加到页面，配置 webpack.config.js * 9.2 打包后观察效果和区别 */// 9.1 创建 img 标签并动态添加到页面，配置 webpack.config.js// 注意：js 中引入本地图片资源要用 import 方式（如果是网络图片http地址，字符串可以直接写）import imgObj from &#x27;./assets/logo.png&#x27;const theImg = document.createElement(&#x27;img&#x27;)theImg.src = imgObjdocument.querySelector(&#x27;.login-wrap&#x27;).appendChild(theImg) 配置 webpack.config.js 让 Webpack 拥有打包图片功能 123456789101112131415module.exports = &#123; // ... module: &#123; rules: [ // ... &#123; test: /\\.(png|jpg|jpeg|gif)$/i, type: &#x27;asset&#x27;, generator: &#123; filename: &#x27;assets/[hash][ext][query]&#x27; &#125; &#125; ] &#125;&#125;","tags":["前端","Webpack"],"categories":["Webpack"]},{"title":"Nodejs 模块化","path":"/2024/03/11/NodeJS模块化/","content":"模块化简介 在 Node.js 中每个文件都被当做是一个独立的模块，模块内定义的变量和函数都是独立作用域的，因为 Node.js 在执行模块代码时，将使用如下所示的函数封装器对其进行封装 而且项目是由多个模块组成的，每个模块之间都是独立的，而且提高模块代码复用性，按需加载，独立作用域 但是因为模块内的属性和函数都是私有的，如果对外使用，需要使用标准语法导出和导入才可以，而这个标准叫 CommonJS 标准，接下来我们在一个需求中，体验下模块化导出和导入语法的使用 需求：定义 utils.js 模块，封装基地址和求数组总和的函数，导入到 index.js 使用查看效果 导出语法： 123module.exports = &#123; 对外属性名: 模块内私有变量&#125; 导入语法： 123const 变量名 = require(&#x27;模块名或路径&#x27;)// Node.js 环境内置模块直接写模块名（例如：fs，path，http）// 自定义模块：写模块文件路径（例如：./utils.js) 变量名的值接收的就是目标模块导出的对象 代码实现 utils.js：导出 1234567891011/** * 目标：基于 CommonJS 标准语法，封装属性和方法并导出 */const baseURL = &#x27;http://hmajax.itheima.net&#x27;const getArraySum = arr =&gt; arr.reduce((sum, item) =&gt; sum += item, 0)// 导出module.exports = &#123; url: baseURL, arraySum: getArraySum&#125; index.js：导入使用 12345678/** * 目标：基于 CommonJS 标准语法，导入工具属性和方法使用 */// 导入const obj = require(&#x27;./utils.js&#x27;)console.log(obj)const result = obj.arraySum([5, 1, 2, 3])console.log(result) ECMAScript标准-默认导出和导入CommonJS 规范是 Node.js 环境中默认的，后来官方推出 ECMAScript 标准语法，我们接下来在一个需求中，体验下这个标准中默认导出和导入的语法要如何使用 需求：封装并导出基地址和求数组元素和的函数，导入到 index.js 使用查看效果 导出语法： 123export default &#123; 对外属性名: 模块内私有变量&#125; 导入语法： 1import 变量名 from &#x27;模块名或路径&#x27; 变量名的值接收的就是目标模块导出的对象 注意：Node.js 默认只支持 CommonJS 标准语法，如果想要在当前项目环境下使用 ECMAScript 标准语法，请新建 package.json 文件设置 type: ‘module’ 来进行设置 1&#123; “type”: &quot;module&quot; &#125; 代码实现： utils.js：导出 1234567891011/** * 目标：基于 ECMAScript 标准语法，封装属性和方法并&quot;默认&quot;导出 */const baseURL = &#x27;http://hmajax.itheima.net&#x27;const getArraySum = arr =&gt; arr.reduce((sum, item) =&gt; sum += item, 0)// 默认导出export default &#123; url: baseURL, arraySum: getArraySum&#125; index.js：导入 12345678/** * 目标：基于 ECMAScript 标准语法，&quot;默认&quot;导入，工具属性和方法使用 */// 默认导入import obj from &#x27;./utils.js&#x27;console.log(obj)const result = obj.arraySum([10, 20, 30])console.log(result) ECMAScript标准-命名导出和导入 ECMAScript 标准的语法有很多，常用的就是默认和命名导出和导入，现在来学习下命名导出和导入的使用 需求：封装并导出基地址和数组求和函数，导入到 index.js 使用查看效果 命名导出语法： 1export 修饰定义语句 命名导入语法： 1import &#123; 同名变量 &#125; from &#x27;模块名或路径&#x27; 代码示例： utils.js 导出 12345/** * 目标：基于 ECMAScript 标准语法，封装属性和方法并&quot;命名&quot;导出 */export const baseURL = &#x27;http://hmajax.itheima.net&#x27;export const getArraySum = arr =&gt; arr.reduce((sum, item) =&gt; sum += item, 0) index.js 导入 12345678910/** * 目标：基于 ECMAScript 标准语法，&quot;命名&quot;导入，工具属性和方法使用 */// 命名导入import &#123;baseURL, getArraySum&#125; from &#x27;./utils.js&#x27;console.log(obj)console.log(baseURL)console.log(getArraySum)const result = getArraySum([10, 21, 33])console.log(result) 与默认导出如何选择： 按需加载，使用命名导出和导入 全部加载，使用默认导出和导入","tags":["前端","Node.js"],"categories":["Node.js"]},{"title":"Nodejs npm","path":"/2024/03/11/npm/","content":"简介 npm 简介链接： 软件包管理器，用于下载和管理 Node.js 环境中的软件包 npm 使用步骤： 初始化清单文件： npm init -y （得到 package.json 文件，有则跳过此命令） 注意 -y 就是所有选项用默认值，所在文件夹不要有中文&#x2F;特殊符号，建议英文和数字组成，因为 npm 包名限制建议用英文和数字或者下划线中划线 下载软件包：npm i 软件包名称 使用软件包 需求：使用 npm 下载 dayjs 软件包到本地项目文件夹中，引入到 index.js 中格式化日期打印，运行观察效果 具体使用流程图： npm全局软件包-nodemon 软件包区别： 本地软件包：当前项目内使用，作用在当前项目，封装的属性&#x2F;方法，供项目调用编写业务需求，封装属性和方法，存在于 node_modules 全局软件包：本机所有项目使用，作用在所有项目，一般封装的命令&#x2F;工具，支撑项目运行，封装命令和工具，存在于系统设置的位置 nodemon 作用：替代 node 命令，检测代码更改，自动重启程序 使用： 安装：npm i nodemon -g （-g 代表安装到全局环境中） 运行：nodemon 待执行的目标 js 文件 需求：使用 nodemon 命令来启动素材里准备好的项目，然后修改代码保存后，观察终端重启应用程序","tags":["前端","Node.js","npm"],"categories":["Node.js"]},{"title":"Nodejs 压缩HTML","path":"/2024/03/11/压缩HTML/","content":"前端工程化：前端代码压缩，整合，转译，测试，自动部署等等工具的集成统称，为了提高前端开发项目的效率 需求：把准备好的 html 文件里的回车符（\\r）和换行符（ ）去掉进行压缩，写入到新 html 中 步骤： 读取源 html 文件内容 正则替换字符串 写入到新的 html 文件中，并运行查看是否能正常打开网页 代码如下： 1234567891011121314151617181920/** * 目标一：压缩 html 里代码 * 需求：把 public/index.html 里的，回车/换行符去掉，写入到 dist/index.html 中 * 1.1 读取 public/index.html 内容 * 1.2 使用正则替换内容字符串里的，回车符\\r 换行符 * 1.3 确认后，写入到 dist/index.html 内 */const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)// 1.1 读取 public/index.html 内容fs.readFile(path.join(__dirname, &#x27;public&#x27;, &#x27;index.html&#x27;), (err, data) =&gt; &#123; const htmlStr = data.toString() // 1.2 使用正则替换内容字符串里的，回车符\\r 换行符 const resultStr = htmlStr.replace(/[\\r ]/g, &#x27;&#x27;) // 1.3 确认后，写入到 dist/index.html 内 fs.writeFile(path.join(__dirname, &#x27;dist&#x27;, &#x27;index.html&#x27;), resultStr, err =&gt; &#123; if (err) console.log(err) else console.log(&#x27;压缩成功&#x27;) &#125;)&#125;)","tags":["前端","Node.js"],"categories":["Node.js"]},{"title":"Nodejs 创建web服务","path":"/2024/03/10/创建一个简单的web服务/","content":"基于 Web 服务，开发提供网页资源的功能，了解下后端的代码工作过程 步骤： 基于 http 模块，创建 Web 服务 使用 req.url 获取请求资源路径为 &#x2F;index.html 的时候，读取 index.html 文件内容字符串返回给请求方 其他路径，暂时返回不存在的提示 运行 Web 服务，用浏览器发起请求 1234567891011121314151617181920212223242526272829/** * 目标：编写 web 服务，监听请求的是 /index.html 路径的时候，返回 dist/index.html 时钟案例页面内容 * 步骤： * 1. 基于 http 模块，创建 Web 服务 * 2. 使用 req.url 获取请求资源路径，并读取 index.html 里字符串内容返回给请求方 * 3. 其他路径，暂时返回不存在提示 * 4. 运行 Web 服务，用浏览器发起请求 */const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)// 1. 基于 http 模块，创建 Web 服务const http = require(&#x27;http&#x27;)const server = http.createServer()server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // 2. 使用 req.url 获取请求资源路径，并读取 index.html 里字符串内容返回给请求方 if (req.url === &#x27;/index.html&#x27;) &#123; fs.readFile(path.join(__dirname, &#x27;dist/index.html&#x27;), (err, data) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;) res.end(data.toString()) &#125;) &#125; else &#123; // 3. 其他路径，暂时返回不存在提示 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;) res.end(&#x27;你要访问的资源路径不存在&#x27;) &#125;&#125;)server.listen(8080, () =&gt; &#123; console.log(&#x27;Web 服务启动了&#x27;)&#125;)","tags":["前端","Node.js"],"categories":["Node.js"]},{"title":"Nodejs 包的概念","path":"/2024/03/10/包/","content":"概念 包：将模块，代码，其他资料整合成一个文件夹，这个文件夹就叫包 包分类： 项目包：主要用于编写项目和业务逻辑 软件包：封装工具和方法进行使用 包要求：根目录中，必须有 package.json 文件（记录包的清单信息） 包使用：在引入一个包文件夹到代码中，默认引入的是包文件节下的 index.js 模块文件里导出的对象，如果没有 index.js 文件，则会引入 package.json 里 main 属性指定的文件模块导出的对象 需求：封装数组求和函数的模块，封装判断用户名和密码长度函数的模块，形成一个软件包，并导入到 index.js 中使用查看效果 代码示例： utils&#x2F;lib 相关代码在素材里准备好了，只需要自己在 utils&#x2F;index.js 统一出口进行导出 1234567891011121314/** * 本文件是，utils 工具包的唯一出口 * 作用：把所有工具模块方法集中起来，统一向外暴露 */const &#123; getArraySum &#125; = require(&#x27;./lib/arr.js&#x27;)const &#123; checkUser, checkPwd &#125; = require(&#x27;./lib/str.js&#x27;)// 统一导出所有函数module.exports = &#123; getArraySum, checkUser, checkPwd&#125; index.js 导入软件包文件夹使用（注意：这次导入的是包文件夹，不是模块文件） 1234567/** * 目标：导入 utils 软件包，使用里面封装的工具函数 */const obj = require(&#x27;./utils&#x27;)console.log(obj)const result = obj.getArraySum([10, 20, 30])console.log(result)","tags":["前端","Node.js"],"categories":["Node.js"]},{"title":"Nodejs 基础知识","path":"/2024/03/09/基础入门/","content":"概念 Node.js 是一个独立的 JavaScript 运行环境，能独立执行 JS 代码，因为这个特点，它可以用来编写服务器后端的应用程序 Node.js 作用除了编写后端应用程序，也可以对前端代码进行压缩，转译，整合等等，提高前端开发和运行效率 Node.js 基于Chrome V8 引擎封装，独立执行 JS 代码，但是语法和浏览器环境的 V8 有所不同，没有 document 和 window 但是都支持 ECMAScript 标准的代码语法 fs模块 fs 模块：封装了与本机文件系统进行交互的，方法和属性 fs 模块使用语法如下： 加载 fs 模块，得到 fs 对象 1const fs = require(&#x27;fs&#x27;) 写入文件内容语法： 123fs.writeFile(&#x27;文件路径&#x27;, &#x27;写入内容&#x27;, err =&gt; &#123; // 写入后的回调函数&#125;) 读取文件内容的语法： 1234fs.readFile(&#x27;文件路径&#x27;, (err, data) =&gt; &#123; // 读取后的回调函数 // data 是文件内容的 Buffer 数据流&#125;) 需求：向 test.txt 文件写入内容并读取打印 1234567891011121314151617181920/** * 目标：使用 fs 模块，读写文件内容 * 语法： * 1. 引入 fs 模块 * 2. 调用 writeFile 写入内容 * 3. 调用 readFile 读取内容 */// 1. 引入 fs 模块const fs = require(&#x27;fs&#x27;)// 2. 调用 writeFile 写入内容// 注意：建议写入字符串内容，会覆盖目标文件所有内容fs.writeFile(&#x27;./text.txt&#x27;, &#x27;欢迎使用 fs 模块读写文件内容&#x27;, err =&gt; &#123; if (err) console.log(err) else console.log(&#x27;写入成功&#x27;)&#125;)// 3. 调用 readFile 读取内容fs.readFile(&#x27;./text.txt&#x27;, (err, data) =&gt; &#123; if (err) console.log(err) else console.log(data.toString()) // 把 Buffer 数据流转成字符串类型&#125;) path模块 为什么在 Node.js 待执行的 JS 代码中要用绝对路径： Node.js 执行 JS 代码时，代码中的路径都是以终端所在文件夹出发查找相对路径，而不是以我们认为的从代码本身出发，会遇到问题，所以在 Node.js 要执行的代码中，访问其他文件，建议使用绝对路径 新建 03 文件夹编写待执行的 JS 代码，访问外层相对路径下的文件，然后在最外层终端路径来执行目标文件，造成问题 问题原因：就是从代码文件夹出发，使用../text.txt解析路径，找不到目标文件，报错了，在node.js里，相对路径是根据终端所在路径来查找的 解决方案：使用模块内置变量 __dirname配合 path.join() 来得到绝对路径使用 12345678910111213const fs = require(&#x27;fs&#x27;)console.log(__dirname) // D:\\备课代码\\2_node_3天\\Node_代码\\Day01_Node.js入门\\代码\\03// 1. 加载 path 模块const path = require(&#x27;path&#x27;)// 2. 使用 path.join() 来拼接路径const pathStr = path.join(__dirname, &#x27;..&#x27;, &#x27;text.txt&#x27;)console.log(pathStr)fs.readFile(pathStr, (err, data) =&gt; &#123; if (err) console.log(err) else console.log(data.toString())&#125;)","tags":["前端","Node.js"],"categories":["Node.js"]},{"title":"宏任务与微任务","path":"/2024/03/08/宏任务与微任务/","content":"JS执行机制同步任务同步任务都在主线程上执行，形成一个执行栈。 异步任务JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型: 1、普通事件，如 click、resize 等 2、资源加载，如 load、error 等 3、定时器，包括 setInterval、setTimeout 等 异步任务相关添加到任务队列中（任务队列也称为消息队列）。 事件循环 先执行执行栈中的同步任务。 异步任务放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 宏任务与微任务异步任务划分为了 宏任务：由浏览器环境执行的异步代码 微任务：由 JS 引擎环境执行的异步代码 宏任务和微任务具体划分： 事件循环模型 1234567891011121314/** * 阅读并回答打印的执行顺序*/console.log(1)setTimeout(() =&gt; &#123; console.log(2)&#125;, 0)const p = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;)p.then(res =&gt; &#123; console.log(res)&#125;)console.log(4) 注意：宏任务每次在执行同步代码时，产生微任务队列，清空微任务队列任务后，微任务队列空间释放！ 下一次宏任务执行时，遇到微任务代码，才会再次申请微任务队列空间放入回调函数消息排队 总结：一个宏任务包含微任务队列，他们之间是包含关系，不是并列关系 经典题目 1234567891011121314151617// 目标：回答代码执行顺序console.log(1)setTimeout(() =&gt; &#123; console.log(2) const p = new Promise(resolve =&gt; resolve(3)) p.then(result =&gt; console.log(result))&#125;, 0)const p = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(4) &#125;, 0) resolve(5)&#125;)p.then(result =&gt; console.log(result))const p2 = new Promise(resolve =&gt; resolve(6))p2.then(result =&gt; console.log(result))console.log(7) 结果：1 7 5 6 2 3 4 执行顺序： console.log(1) setTimeout()作为宏任务推入到宏任务队列中排队 const p &#x3D; new Promise放到调用栈执行，遇到里面的setTimeout（）放入宏任务队列中排队 p.then（）当promise为成功状态时作为微任务推入到微任务中排队 const p2 &#x3D; new Promise 成功 p2.then立刻作为微任务推入到微任务中排队 console.log(7) 从微任务队列中调度p.then(result &#x3D;&gt; console.log(result))，打印5&#x20; 从微任务队列中调度p2.then(result &#x3D;&gt; console.log(result))，打印6 从宏任务队列中调度setTimeout（），打印2，const p &#x3D; new Promise(resolve &#x3D;&gt;resolve(3))为成功状态，p.then(result &#x3D;&gt; console.log(result))立刻被推入到微任务队列中排队 从微任务队列中调度p.then(result &#x3D;&gt; console.log(result))，打印3 从宏任务队列中调度setTimeout(() &#x3D;&gt; {&#x20; console.log(4)&#x20; }, 0)，打印4","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"回调地狱及其解决方法","path":"/2024/03/07/回调地狱及其解决方法/","content":"同步与异步的概念 同步代码：逐行执行，需原地等待结果后，才继续向下执行 异步代码：调用后耗时，不阻塞代码继续执行（不必原地等待），在将来完成后触发回调函数传递结果 回答代码打印顺序：发现异步代码接收结果，使用的都是回调函数 12345678910const result = 0 + 1console.log(result)setTimeout(() =&gt; &#123; console.log(2)&#125;, 2000)document.querySelector(&#x27;.btn&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(3)&#125;)document.body.style.backgroundColor = &#x27;pink&#x27;console.log(4) 结果：1， 4， 2 按钮点击一次打印一次 3 回调地狱概念 需求：展示默认第一个省，第一个城市，第一个地区在下拉菜单中 概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调函数地狱 缺点：可读性差，异常无法捕获，耦合性严重，牵一发动全身 12345678910111213axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27; &#125;).then(result =&gt; &#123; const pname = result.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname // 获取第一个省份默认下属的第一个城市名字 axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125; &#125;).then(result =&gt; &#123; const cname = result.data.list[0] document.querySelector(&#x27;.city&#x27;).innerHTML = cname // 获取第一个城市默认下属第一个地区名字 axios(&#123; url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125; &#125;).then(result =&gt; &#123; document.querySelector(&#x27;.area&#x27;).innerHTML = result.data.list[0] &#125;) &#125;)&#125;) Promise链式调用 概念：依靠 then() 方法会返回一个新生成的 Promise 对象特性，继续串联下一环任务，直到结束 细节：then() 回调函数中的返回值，会影响新生成的 Promise 对象最终状态和结果 好处：通过链式调用，解决回调函数嵌套问题 1234567891011121314151617181920212223242526272829/** * 需求：把省市的嵌套结构，改成链式调用的线性结构*/// 1. 创建Promise对象-模拟请求省份名字const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;北京市&#x27;) &#125;, 2000)&#125;)// 2. 获取省份名字const p2 = p.then(result =&gt; &#123; console.log(result) // 3. 创建Promise对象-模拟请求城市名字 // return Promise对象最终状态和结果，影响到新的Promise对象 return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(result + &#x27;--- 北京&#x27;) &#125;, 2000) &#125;)&#125;)// 4. 获取城市名字p2.then(result =&gt; &#123; console.log(result)&#125;)// then()原地的结果是一个新的Promise对象console.log(p2 === p)//false 使用promise解决回调地狱 目标：使用 Promise 链式调用，解决回调函数地狱问题 做法：每个 Promise 对象中管理一个异步任务，用 then 返回 Promise 对象，串联起来 123456789101112131415161718192021/** * 目标：把回调函数嵌套代码，改成Promise链式调用结构 * 需求：获取默认第一个省，第一个市，第一个地区并展示在下拉菜单中*/let pname = &#x27;&#x27;// 1. 得到-获取省份Promise对象axios(&#123;url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(result =&gt; &#123; pname = result.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname // 2. 得到-获取城市Promise对象 return axios(&#123;url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;)&#125;).then(result =&gt; &#123; const cname = result.data.list[0] document.querySelector(&#x27;.city&#x27;).innerHTML = cname // 3. 得到-获取地区Promise对象 return axios(&#123;url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125;&#125;)&#125;).then(result =&gt; &#123; console.log(result) const areaName = result.data.list[0] document.querySelector(&#x27;.area&#x27;).innerHTML = areaName&#125;) 事实上，promise是callback风格的一个语法糖，它通过实现链式调用的方式来将回调函数的嵌套扁平化来达到解决回调地狱的目的。 往回调函数里按照成功和失败的类别分别传入两个回调函数，就可以分别处理成功和失败的结果。 12345678910111213function foo(handleSucceed, handleFailed) &#123; if(isMistake) &#123; return handleFailed(new Error(&#x27;It`s a mistake&#x27;)); &#125; else &#123; return handleSucceed(&#x27;You got it!&#x27;); &#125;&#125;foo(function (result) &#123; console.log(result);&#125;, function (error) &#123; console.error(error);&#125;); 与promise实现的版本进行对比： 1234567891011121314const pms = new Promise((resolve, reject) =&gt; &#123; // do sth. if(isMistake) &#123; return reject(new Error(&#x27;It`s a mistake&#x27;)); &#125; else &#123; return resolve(&#x27;You got it!&#x27;); &#125;&#125;);pms.then(result =&gt; &#123; console.log(result);&#125;).catch(error =&gt; &#123; console.error(error);&#125;); 会发现实质上，这里的resolve和reject正是两个回调函数，就如同前面一个例子里面的handleSucceed和handleFailed一样。而这两个回调函数的传入方式，从上一个例子的直接两个参数传入，变成了通过then方法和catch方法来进行传入。 相比而言，Promise的方式更加语义化，更容易理解——给主流程留下一个承诺，在之后可以通过该承诺获得子流程的执行结果。 async和await函数解决回调地狱 概念：在 async 函数内，使用 await 关键字取代 then 函数，等待获取 Promise 对象成功状态的结果值。 async关键字作为一个关键字放到申明函数前面，表示该函数为要给异步任务，不会阻塞后面函数的执行。async函数其实是一个返回值为Promise对象的函数。或者更准确地说：async关键字声明的函数被调用时，实质上是创建了一个Promise对象。 await则表示：执行后面的表达式——不论是异步还是同步的表达式——并获取到resolve的结果，如果执行出错，则抛出到外层async函数的catch回调中。await同时作为Promise中的resolve和reject工作了。 做法：使用 async 和 await 解决回调地狱问题 12345678910111213141516171819202122/** * 目标：掌握async和await语法，解决回调函数地狱 * 概念：在async函数内，使用await关键字，获取Promise对象&quot;成功状态&quot;结果值 * 注意：await必须用在async修饰的函数内（await会阻止&quot;异步函数内&quot;代码继续执行，原地等待结果）*/// 1. 定义async修饰函数async function getData() &#123; // 2. await等待Promise对象成功的结果 const pObj = await axios(&#123;url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;) const pname = pObj.data.list[0] const cObj = await axios(&#123;url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125;&#125;) const cname = cObj.data.list[0] const aObj = await axios(&#123;url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125;&#125;) const areaName = aObj.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname document.querySelector(&#x27;.city&#x27;).innerHTML = cname document.querySelector(&#x27;.area&#x27;).innerHTML = areaName&#125;getData() async 函数和 await 捕获错误try 和 catch 的作用：语句标记要尝试的语句块，并指定一个出现异常时抛出的响应 1234567try &#123; // 要执行的代码&#125; catch (error) &#123; // error 接收的是，错误消息 // try 里代码，如果有错误，直接进入这里执行&#125; 尝试把代码中 url 地址写错，观察 try catch 的捕获错误信息能力 123456789101112131415161718192021222324/** * 目标：async和await_错误捕获*/async function getData() &#123; // 1. try包裹可能产生错误的代码 try &#123; const pObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27; &#125;) const pname = pObj.data.list[0] const cObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname &#125; &#125;) const cname = cObj.data.list[0] const aObj = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname, cname &#125; &#125;) const areaName = aObj.data.list[0] document.querySelector(&#x27;.province&#x27;).innerHTML = pname document.querySelector(&#x27;.city&#x27;).innerHTML = cname document.querySelector(&#x27;.area&#x27;).innerHTML = areaName &#125; catch (error) &#123; // 2. 接着调用catch块，接收错误信息 // 如果try里某行代码报错后，try中剩余的代码不会执行了 console.dir(error) &#125;&#125;getData() async函数其实是Promise的语法糖。并且它通过形似同步编程的形式，达成了前述Promise的链式调用，并以此解决回调地狱的问题。","tags":["前端","Ajax"],"categories":["Ajax"]},{"title":"XMLHttpRequest","path":"/2024/03/07/XMLHttpRequest/","content":"基本使用1234567const xhr = new XMLHttpRequest()xhr.open(&#x27;请求方法&#x27;, &#x27;请求url网址&#x27;)xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; // 响应结果 console.log(xhr.response)&#125;)xhr.send() 以一个需求来体验下原生 XHR 语法，需求为获取所有省份列表并展示到页面上 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;XMLHttpRequest_基础使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;my-p&quot;&gt;&lt;/p&gt; &lt;script&gt; /** * 目标：使用XMLHttpRequest对象与服务器通信 * 1. 创建 XMLHttpRequest 对象 * 2. 配置请求方法和请求 url 地址 * 3. 监听 loadend 事件，接收响应结果 * 4. 发起请求 */ // 1. 创建 XMLHttpRequest 对象 const xhr = new XMLHttpRequest() // 2. 配置请求方法和请求 url 地址 xhr.open(&#x27;GET&#x27;, &#x27;http://hmajax.itheima.net/api/province&#x27;) // 3. 监听 loadend 事件，接收响应结果 xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; console.log(xhr.response) const data = JSON.parse(xhr.response) console.log(data.list.join(&#x27;&lt;br&gt;&#x27;)) document.querySelector(&#x27;.my-p&#x27;).innerHTML = data.list.join(&#x27;&lt;br&gt;&#x27;) &#125;) // 4. 发起请求 xhr.send() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 查询参数原生 XHR 需要自己在 url 后面携带查询参数字符串，没有 axios 帮助我们把 params 参数拼接到 url 字符串后面， 123456789101112/** * 目标：使用XHR携带查询参数，展示某个省下属的城市列表*/const xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;http://hmajax.itheima.net/api/city?pname=辽宁省&#x27;)xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; console.log(xhr.response) const data = JSON.parse(xhr.response) console.log(data) document.querySelector(&#x27;.city-p&#x27;).innerHTML = data.list.join(&#x27;&lt;br&gt;&#x27;)&#125;)xhr.send() 多个查询参数，如果自己拼接很麻烦，这里用 URLSearchParams 把参数对象转成“参数名&#x3D;值&amp;参数名&#x3D;值“格式的字符串，语法如下： 123456789// 1. 创建 URLSearchParams 对象const paramsObj = new URLSearchParams(&#123; 参数名1: 值1, 参数名2: 值2&#125;)// 2. 生成指定格式查询参数字符串const queryString = paramsObj.toString()// 结果：参数名1=值1&amp;参数名2=值2 提交数据1、需要自己设置请求头 Content-Type：application&#x2F;json，来告诉服务器端，我们发过去的内容类型是 JSON 字符串，让他转成对应数据结构取值使用 2、前端要传递的请求体数据，需要我们自己把 JS 对象转成 JSON 字符串。 3、原生 XHR 需要在 send 方法调用时，传入请求体携带 12345678910111213const xhr = new XMLHttpRequest()xhr.open(&#x27;请求方法&#x27;, &#x27;请求url网址&#x27;)xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; console.log(xhr.response)&#125;)// 1. 告诉服务器，我传递的内容类型，是 JSON 字符串xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)// 2. 准备数据并转成 JSON 字符串const user = &#123; username: &#x27;itheima007&#x27;, password: &#x27;7654321&#x27; &#125;const userStr = JSON.stringify(user)// 3. 发送请求体数据xhr.send(userStr)","tags":["前端","Ajax"],"categories":["Ajax"]},{"title":"模拟封装Axios","path":"/2024/03/07/模拟封装axios/","content":"简易版 需求：基于 Promise 和 XHR 封装 myAxios 函数，获取省份列表展示到页面 核心语法： 1234567891011121314function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; // XHR 请求 // 调用成功/失败的处理程序 &#125;)&#125;myAxios(&#123; url: &#x27;目标资源地址&#x27;&#125;).then(result =&gt; &#123; &#125;).catch(error =&gt; &#123; &#125;) 步骤： 定义 myAxios 函数，接收配置对象，返回 Promise 对象 发起 XHR 请求，默认请求方法为 GET 调用成功&#x2F;失败的处理程序 使用 myAxios 函数，获取省份列表展示 核心代码 1234567891011121314151617181920212223242526272829303132333435/** * 目标：封装_简易axios函数_获取省份列表 * 1. 定义myAxios函数，接收配置对象，返回Promise对象 * 2. 发起XHR请求，默认请求方法为GET * 3. 调用成功/失败的处理程序 * 4. 使用myAxios函数，获取省份列表展示*/// 1. 定义myAxios函数，接收配置对象，返回Promise对象function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; // 2. 发起XHR请求，默认请求方法为GET const xhr = new XMLHttpRequest() xhr.open(config.method || &#x27;GET&#x27;, config.url) xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; // 3. 调用成功/失败的处理程序 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(JSON.parse(xhr.response)) &#125; else &#123; reject(new Error(xhr.response)) &#125; &#125;) xhr.send() &#125;)&#125;// 4. 使用myAxios函数，获取省份列表展示myAxios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27;&#125;).then(result =&gt; &#123; console.log(result) document.querySelector(&#x27;.my-p&#x27;).innerHTML = result.list.join(&#x27;&lt;br&gt;&#x27;)&#125;).catch(error =&gt; &#123; console.log(error) document.querySelector(&#x27;.my-p&#x27;).innerHTML = error.message&#125;) 携带参数版修改步骤： myAxios 函数调用后，判断 params 选项 基于 URLSearchParams 转换查询参数字符串 使用自己封装的 myAxios 函数显示地区列表 1234567891011121314151617181920212223242526272829303132333435function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() // 1. 判断有params选项，携带查询参数 if (config.params) &#123; // 2. 使用URLSearchParams转换，并携带到url上 const paramsObj = new URLSearchParams(config.params) const queryString = paramsObj.toString() // 把查询参数字符串，拼接在url？后面 config.url += `?$&#123;queryString&#125;` &#125; xhr.open(config.method || &#x27;GET&#x27;, config.url) xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(JSON.parse(xhr.response)) &#125; else &#123; reject(new Error(xhr.response)) &#125; &#125;) xhr.send() &#125;)&#125;// 3. 使用myAxios函数，获取地区列表myAxios(&#123; url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname: &#x27;辽宁省&#x27;, cname: &#x27;大连市&#x27; &#125;&#125;).then(result =&gt; &#123; console.log(result) document.querySelector(&#x27;.my-p&#x27;).innerHTML = result.list.join(&#x27;&lt;br&gt;&#x27;)&#125;) 请求体携带数据版修改步骤： myAxios 函数调用后，判断 data 选项 转换数据类型，在 send 方法中发送 使用自己封装的 myAxios 函数完成注册用户功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function myAxios(config) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() if (config.params) &#123; const paramsObj = new URLSearchParams(config.params) const queryString = paramsObj.toString() config.url += `?$&#123;queryString&#125;` &#125; xhr.open(config.method || &#x27;GET&#x27;, config.url) xhr.addEventListener(&#x27;loadend&#x27;, () =&gt; &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; resolve(JSON.parse(xhr.response)) &#125; else &#123; reject(new Error(xhr.response)) &#125; &#125;) // 1. 判断有data选项，携带请求体 if (config.data) &#123; // 2. 转换数据类型，在send中发送 const jsonStr = JSON.stringify(config.data) xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;) xhr.send(jsonStr) &#125; else &#123; // 如果没有请求体数据，正常的发起请求 xhr.send() &#125; &#125;)&#125;document.querySelector(&#x27;.reg-btn&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 3. 使用myAxios函数，完成注册用户 myAxios(&#123; url: &#x27;http://hmajax.itheima.net/api/register&#x27;, method: &#x27;POST&#x27;, data: &#123; username: &#x27;itheima999&#x27;, password: &#x27;666666&#x27; &#125; &#125;).then(result =&gt; &#123; console.log(result) &#125;).catch(error =&gt; &#123; console.dir(error) &#125;)&#125;)","tags":["前端","Ajax","Axios"],"categories":["Axios"]},{"title":"防抖与节流","path":"/2024/03/05/防抖与节流/防抖与节流/","content":"防抖（debounce）所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 使用场景 搜索框搜索输入，需要等到用户最后一次输入完再发送请求 手机号、邮箱验证输入检测 实现底层简单的实现： 需求：当鼠标在box里滑动时，box里的数字就加一。但如果鼠标每移动1px就加1，数字变化会非常频繁，非常浪费性能。 123456const box=doucment.querySelector(&#x27;.box&#x27;)let i=1function mouseMove()&#123; box.innerHTML=i++&#125;box.addEventListener(&#x27;mousemove&#x27;,mouseMove) lodash库1_.debounce(func, [wait=0], [options=&#123;&#125;]) 使用说明： 创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。&#x20; debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。&#x20; 后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果。 1234567891011121314151617&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; // box.addEventListener(&#x27;mousemove&#x27;, mouseMove) // lodash 节流写法 // box.addEventListener(&#x27;mousemove&#x27;, _.throttle(mouseMove, 500)) // lodash 防抖的写法 box.addEventListener(&#x27;mousemove&#x27;, _.debounce(mouseMove, 500)) &lt;/script&gt; 手动实现核心思想是使用定时器（setTimeout）来实现。 1．声明定时器变量 2．每次鼠标移动(事件触发）的时候都要先判断是否有定时器，如果有先清除以前的定时器 3．如果没有定时器，则开启定时器，存入到定时器变量里面 4．定时器里面写函数调用 1234567891011121314151617181920212223242526&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; // 防抖函数 function debounce(fn, t) &#123; let timeId return function () &#123; // 如果有定时器就清除 let context = this; // 保存this指向 let args = arguments; // 拿到event对象 if (timeId) clearTimeout(timeId) // 开启定时器 200 timeId = setTimeout(function () &#123; func.apply(context, args) &#125;, t) &#125; &#125; // box.addEventListener(&#x27;mousemove&#x27;, mouseMove) box.addEventListener(&#x27;mousemove&#x27;, debounce(mouseMove, 200))&lt;/script&gt; 节流（throttle）所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 使用场景鼠标移动mousemove、页面尺寸缩放resize、滚动条滚动scroll等等 实现底层简单的实现： 需求：当鼠标在box里滑动时，不管移动多少次，box里的数字每隔500ms才加一。 lodash库1_.throttle(func, [wait=0], [options=]) 创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。&#x20; 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。&#x20; 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。&#x20; func 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 func 调用的结果。 12345678910&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; box.addEventListener(&#x27;mousemove&#x27;, _.throttle(mouseMove, 500)) &lt;/script&gt; 手动实现 声明一个定时器变量 当鼠标每次滑动，都先判断是否有定时器了，如果有定时器则不开启新定时器 如果没有定时器则开启定时器，记得存到变量里面-定时器里面调用执行的函数-定时器里面要把定时器清空 12345678910111213141516171819202122232425&lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 让这个变量++ // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = ++i // 如果里面存在大量操作 dom 的情况，可能会卡顿 &#125; // 防抖函数 function throttle(fn, t) &#123; let timeId return function () &#123; // 如果有定时器就清除 if (!timeId) // 开启定时器 200 timeId = setTimeout(function () &#123; fn() timeId=null; &#125;, t) &#125; &#125; // box.addEventListener(&#x27;mousemove&#x27;, mouseMove) box.addEventListener(&#x27;mousemove&#x27;, throttle(mouseMove, 500))&lt;/script&gt; 注意：这里清空定时器不能使用clearTimeout，而是将timeId设置为null。因为在setTimeoput中是无法清楚定时器的。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"this指向问题","path":"/2024/03/05/this指向/","content":"this 是 JavaScript 最容易迷糊的知识点，不同的应用场合 this 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 this 默认的取值】情况进行归纳和总结。 普通函数普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】，如下代码所示： 12345678910111213141516171819202122232425262728&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this) &#125; // 函数表达式 const sayHello = function () &#123; console.log(this) &#125; // 函数的调用方式决定了 this 的值 sayHi() // window window.sayHi() // 普通对象 const user = &#123; name: &#x27;小明&#x27;, walk: function () &#123; console.log(this) &#125; &#125; // 动态为 user 添加方法 user.sayHi = sayHi uesr.sayHello = sayHello // 函数调用方式，决定了 this 的值 user.sayHi() user.sayHello()&lt;/script&gt; 注： 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined。 箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！箭头函数中访问的 this 不过是箭头函数所在作用域的 this 变量。 12345678910111213141516171819202122232425262728293031&lt;script&gt; console.log(this) // 此处为 window // 箭头函数 const sayHi = function() &#123; console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致 &#125; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, // 该箭头函数中的 this 为函数声明环境中 this 一致 walk: () =&gt; &#123; console.log(this) &#125;, sleep: function () &#123; let str = &#x27;hello&#x27; console.log(this) let fn = () =&gt; &#123; console.log(str) console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致 &#125; // 调用箭头函数 fn(); &#125; &#125; // 动态添加方法 user.sayHi = sayHi // 函数调用 user.sayHi() user.sleep() user.walk()&lt;/script&gt; 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示： 123456789101112&lt;script&gt; // DOM 节点 const btn = document.querySelector(&#x27;.btn&#x27;) // 箭头函数 此时 this 指向了 window btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(this) &#125;) // 普通函数 此时 this 指向了 DOM 对象 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(this) &#125;)&lt;/script&gt; 同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数，如下代码所示： 1234567891011&lt;script&gt; function Person() &#123; &#125; // 原型对像上添加了箭头函数 Person.prototype.walk = () =&gt; &#123; console.log(&#x27;人都要走路...&#x27;) console.log(this); // window &#125; const p1 = new Person() p1.walk()&lt;/script&gt; 改变this指向以上归纳了普通函数和箭头函数中关于 this 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向： call使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 12345678910111213141516171819202122232425&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this); &#125; let user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; let student = &#123; name: &#x27;小红&#x27;, age: 16 &#125; // 调用函数并指定 this 的值 sayHi.call(user); // this 值为 user sayHi.call(student); // this 值为 student // 求和函数 function counter(x, y) &#123; return x + y; &#125; // 调用 counter 函数，并传入参数 let result = counter.call(null, 5, 10); console.log(result);&lt;/script&gt; apply使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示： 12345678910111213141516171819202122232425262728&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this) &#125; let user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; let student = &#123; name: &#x27;小红&#x27;, age: 16 &#125; // 调用函数并指定 this 的值 sayHi.apply(user) // this 值为 user sayHi.apply(student) // this 值为 student // 求和函数 function counter(x, y) &#123; return x + y &#125; // 调用 counter 函数，并传入参数 let result = counter.apply(null, [5, 10]) console.log(result)&lt;/script&gt; 总结： apply 方法能够在调用函数的同时指定 this 的值 使用 apply 方法调用函数时，第1个参数为 this 指定的值 apply 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数 bindbind 方法并不会调用函数，而是创建一个指定了 this 值的新函数，使用方法如下代码所示： 1234567891011121314&lt;script&gt; // 普通函数 function sayHi() &#123; console.log(this) &#125; let user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; // 调用 bind 指定 this 的值 let sayHello = sayHi.bind(user); // 调用使用 bind 创建的新函数 sayHello()&lt;/script&gt; 注：bind 方法创建新的函数，与原函数的唯一的变化是改变了 this 的值，使用场景是修改定时器内this的指向。 比如，点击一个按钮这个按钮就禁用，2s后重新开启。 123456789const fun =fn.bind(obj)fun()const btn = document.querySelector(&#x27;button&#x27;)btn.addEventListener(&#x27;click&#x27;,function()&#123; this.disabled=true; window.setTimeout(function()&#123; this.disabled=false //如果不改变，this指向的是window，可以改完箭头函数或者使用bind函数 &#125;.bind(btn),2000)&#125;)","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Promise","path":"/2024/03/03/Promise/","content":"概述 什么是 Promise ？ Promise 对象用于表示一个异步操作的最终完成（或失败）及其结构值 Promise 的好处是什么？ 逻辑更清晰（成功或失败会关联后续的处理函数） 了解 axios 函数内部运作的机制 解决回调函数地狱问题 123456789101112131415161718/** * 目标：使用Promise管理异步任务*/// 1. 创建Promise对象const p = new Promise((resolve, reject) =&gt; &#123; // 2. 执行异步代码 setTimeout(() =&gt; &#123; // resolve(&#x27;模拟AJAX请求-成功结果&#x27;) reject(new Error(&#x27;模拟AJAX请求-失败结果&#x27;)) &#125;, 2000)&#125;)// 3. 获取结果p.then(result =&gt; &#123; console.log(result)&#125;).catch(error =&gt; &#123; console.log(error)&#125;) promise的状态Promise 有哪三种状态？ 每个 Promise 对象必定处于以下三种状态之一 待定（pending）：初始状态，既没有被兑现，也没有被拒绝 已兑现（fulfilled）：操作成功完成 已拒绝（rejected）：操作失败 Promise 的状态改变有什么用？ 调用对应函数，改变 Promise 对象状态后，内部触发对应回调函数传参并执行 注意：每个 Promise 对象一旦被兑现&#x2F;拒绝，那就是已敲定了，状态无法再被改变 创建promise实例一般情况下都会使用new Promise()来创建promise对象，但是也可以使用promise.resolve和promise.reject这两个方法： Promise.resolve Promise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下： 1234Promise.resolve(11).then(function(value)&#123; console.log(value); // 打印出11&#125;); Promise.reject Promise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下 12Promise.reject(new Error(“我错了！！”)); Promise的实例方法和静态方法实例方法then then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。 then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 catch 该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。 finally finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 123456server.listen(port) .then(function () &#123; // ... &#125;) .finally(server.stop); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 静态方法all all方法可以完成并发任务， 它接收一个数组，数组的每一项都是一个promise对象，返回一个Promise实例。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。 race race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。 any 它接收一个数组，数组的每一项都是一个promise对象，该方法会返回一个新的 promise，数组内的任意一个 promise 变成了resolved状态，那么由该方法所返回的 promise 就会变成resolved状态。如果数组内的 promise 状态都是rejected，那么该方法所返回的 promise 就会变成rejected状态， resolve、reject 用来生成对应状态的Promise实例 Promise.all、Promise.race、Promise.any的区别all： 成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。 race： 哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 any： 返回最快的成功结果，如果全部失败就返回失败结果","tags":["前端","Javascript","ES6"],"categories":["ES6"]},{"title":"异常处理","path":"/2024/03/01/异常处理/","content":"throw异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行 总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 1234567891011121314&lt;script&gt; function counter(x, y) &#123; if(!x || !y) &#123; // throw &#x27;参数不能为空!&#x27;; throw new Error(&#x27;参数不能为空!&#x27;) &#125; return x + y &#125; counter()&lt;/script&gt; 总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 try … catch123456789101112131415161718192021&lt;script&gt; function foo() &#123; try &#123; // 查找 DOM 节点 const p = document.querySelector(&#x27;.p&#x27;) p.style.color = &#x27;red&#x27; &#125; catch (error) &#123; // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息 console.log(error.message) // 终止代码继续执行 return &#125; finally &#123; alert(&#x27;执行&#x27;) &#125; console.log(&#x27;如果出现错误，我的语句不会执行&#x27;) &#125; foo()&lt;/script&gt; 总结： try...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 debugger相当于断点调试","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"深浅拷贝及其实现方式","path":"/2024/02/29/深浅拷贝/","content":"浅拷贝首先浅拷贝和深拷贝只针对引用类型 浅拷贝：拷贝的是地址 常见方法： 拷贝对象1.Object.assgin()object.assign 是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并。我们可以使用它来实现浅拷贝。 该方法的参数 target 指的是目标对象，sources指的是源对象。使用形式如下： 1Object.assign(target, ...sources) 注： 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性； 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回； 因为null 和 undefined 不能转化为对象，所以第一个参数不能为null或 undefined，否则会报错； 它不会拷贝对象的继承属性，不会拷贝对象的不可枚举的属性，可以拷贝 Symbol 类型的属性。 实际上，Object.assign 会循环遍历原对象的可枚举属性，通过复制的方式将其赋值给目标对象的相应属性。 2. 扩展运算符使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。使用形式如下： 1let cloneObj = &#123; ...obj &#125;; 拷贝数组（1）Array.prototype.slice()slice()方法是JavaScript数组方法，该方法可以从已有数组中返回选定的元素，不会改变原始数组。使用方式如下： 1array.slice(start, end) slice 方法不会修改原数组，只会返回一个浅拷贝了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说，slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。 （2）Array.prototype.concat()concat() 方法用于合并两个或多个数组，此方法不会更改原始数组，而是返回一个新数组。使用方式如下： 1arrayObject.concat(arrayX,arrayX,......,arrayX) concat方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（参数是数组）或参数本身（参数不是数组）。它不会递归到嵌套数组参数中。&#x20; concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中，如下所示： 对象引用（而不是实际对象）：concat将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。 数据类型如字符串，数字和布尔值：concat将字符串和数字的值复制到新数组中。 手动实现浅拷贝根据以上对浅拷贝的理解，实现浅拷贝的思路： 对基础类型做最基本的拷贝； 对引用类型开辟新的存储，并且拷贝一层对象属性。 1234567891011121314// 浅拷贝的实现;function shallowCopy(object) &#123; // 只拷贝对象 if (!object || typeof object !== &quot;object&quot;) return; // 根据 object 的类型判断是新建一个数组还是对象 let newObject = Array.isArray(object) ? [] : &#123;&#125;; // 遍历 object，并且判断是 object 的属性才拷贝 for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = object[key]; &#125; &#125; return newObject;&#125; 这里用到了 hasOwnProperty() 方法，该方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。所有继承了 Object 的对象都会继承到 hasOwnProperty() 方法。这个方法可以用来检测一个对象是否是自身属性。 可以看到，所有的浅拷贝都只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝就无能为力了。深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。 深拷贝首先浅拷贝和深拷贝只针对引用类型 深拷贝：拷贝的是对象，不是地址 常见方法： 通过递归实现深拷贝 lodash&#x2F;cloneDeep 通过JSON.stringify()实现 1.递归实现函数递归： 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 简单理解: 函数内部自己调用自己, 这个函数就是递归函数 递归函数的作用和循环效果类似 由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt; &lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小宝&#x27; &#125; &#125; const o = &#123;&#125; // 拷贝函数 function deepCopy(newObj, oldObj) &#123; debugger for (let k in oldObj) &#123; // 处理数组的问题 一定先写数组 在写 对象 不能颠倒 if (oldObj[k] instanceof Array) &#123; newObj[k] = [] // newObj[k] 接收 [] hobby // oldObj[k] [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] deepCopy(newObj[k], oldObj[k]) &#125; else if (oldObj[k] instanceof Object) &#123; newObj[k] = &#123;&#125; deepCopy(newObj[k], oldObj[k]) &#125; else &#123; // k 属性名 uname age oldObj[k] 属性值 18 // newObj[k] === o.uname 给新对象添加属性 newObj[k] = oldObj[k] &#125; &#125; &#125; deepCopy(o, obj) // 函数调用 两个参数 o 新对象 obj 旧对象 console.log(o) o.age = 20 o.hobby[0] = &#x27;篮球&#x27; o.family.baby = &#x27;老宝&#x27; console.log(obj) console.log([1, 23] instanceof Object) // 复习 // const obj = &#123; // uname: &#x27;pink&#x27;, // age: 18, // hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] // &#125; // function deepCopy(&#123; &#125;, oldObj) &#123; // // k 属性名 oldObj[k] 属性值 // for (let k in oldObj) &#123; // // 处理数组的问题 k 变量 // newObj[k] = oldObj[k] // // o.uname = &#x27;pink&#x27; // // newObj.k = &#x27;pink&#x27; // &#125; // &#125; &lt;/script&gt;&lt;/body&gt; 这样虽然实现了深拷贝，但也存在一些问题： 不能复制不可枚举属性以及 Symbol 类型； 只能对普通引用类型的值做递归复制，对于 Date、RegExp、Function 等引用类型不能正确拷贝； 可能存在循环引用问题。 优化递归实现上面只是实现了一个基础版的深拷贝，对于上面存在的几个问题，可以尝试去解决一下： 使用 Reflect.ownKeys() 方法来解决不能复制不可枚举属性以及 Symbol 类型的问题。 Reflect.ownKeys() 方法会返回一个由目标对象自身的属性键组成的数组。它的返回值等同于: Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)); 当参数值为 Date、RegExp 类型时，直接生成一个新的实例并返回； 利用 Object.getOwnPropertyDescriptors() 方以获得对象的所有属性以及对应的特性。简单来说，这个方法返回给定对象的所有属性的信息，包括有关getter和setter的信息。它允许创建对象的副本并在复制所有属性（包括getter和setter）时克隆它。 使用 Object.create() 方法创建一个新对象，并继承传入原对象的原型链。Object.create()方法会创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 使用 WeakMap 类型作为 Hash 表，WeakMap 是弱引用类型，可以防止内存泄漏，所以可以用来检测循环引用，如果存在循环，则引用直接返回 WeakMap 存储的值。WeakMap的特性就是，保存在其中的对象不会影响垃圾回收，如果WeakMap保存的节点，在其他地方都没有被引用了，那么即使它还在WeakMap中也会被垃圾回收回收掉了。在深拷贝的过程当中，里面所有的引用对象都是被引用的，为了解决循环引用的问题，在深拷贝的过程中，希望有个数据结构能够记录每个引用对象有没有被使用过，但是深拷贝结束之后这个数据能自动被垃圾回收，避免内存泄漏。 12345678910111213141516171819202122232425262728function deepClone (obj, hash = new WeakMap()) &#123; // 日期对象直接返回一个新的日期对象 if (obj instanceof Date)&#123; return new Date(obj); &#125; //正则对象直接返回一个新的正则对象 if (obj instanceof RegExp)&#123; return new RegExp(obj); &#125; //如果循环引用,就用 weakMap 来解决 if (hash.has(obj))&#123; return hash.get(obj); &#125; // 获取对象所有自身属性的描述 let allDesc = Object.getOwnPropertyDescriptors(obj); // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc) hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; if(typeof obj[key] === &#x27;object&#x27; &amp;&amp; obj[key] !== null)&#123; cloneObj[key] = deepClone(obj[key], hash); &#125; else &#123; cloneObj[key] = obj[key]; &#125; &#125; return cloneObj&#125; 测试数据： 12345678910111213141516171819202122let obj = &#123; num: 1, str: &#x27;str&#x27;, boolean: true, und: undefined, nul: null, obj: &#123; name: &#x27;对象&#x27;, id: 1 &#125;, arr: [0, 1, 2], func: function () &#123; console.log(&#x27;函数&#x27;) &#125;, date: new Date(1), reg: new RegExp(&#x27;/正则/ig&#x27;), [Symbol(&#x27;1&#x27;)]: 1,&#125;;Object.defineProperty(obj, &#x27;innumerable&#x27;, &#123; enumerable: false, value: &#x27;不可枚举属性&#x27; &#125;);obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))obj.loop = obj // 将loop设置成循环引用的属性let cloneObj = deepClone(obj)console.log(&#x27;obj&#x27;, obj)console.log(&#x27;cloneObj&#x27;, cloneObj) 这样基本就实现了多数数据类型的深拷贝，不过也还存在一些缺陷，比如Map和Set结构在这个方法中无法进行拷贝。 2.lodash库cloneDeep123456789101112131415161718&lt;body&gt; &lt;!-- 先引用 --&gt; &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小宝&#x27; &#125; &#125; const o = _.cloneDeep(obj) console.log(o) o.family.baby = &#x27;老宝&#x27; console.log(obj) &lt;/script&gt;&lt;/body&gt; lodash中深拷贝的源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*** value：需要拷贝的对象* bitmask：位掩码，其中 1 是深拷贝，2 拷贝原型链上的属性，4 是拷贝 Symbols 属性* customizer：定制的 clone 函数* key：传入 value 值的 key* object：传入 value 值的父对象* stack：Stack 栈，用来处理循环引用*/function baseClone(value, bitmask, customizer, key, object, stack) &#123; let result // 标志位 const isDeep = bitmask &amp; CLONE_DEEP_FLAG // 深拷贝，true const isFlat = bitmask &amp; CLONE_FLAT_FLAG // 拷贝原型链，false const isFull = bitmask &amp; CLONE_SYMBOLS_FLAG // 拷贝 Symbol，true // 自定义 clone 函数 if (customizer) &#123; result = object ? customizer(value, key, object, stack) : customizer(value) &#125; if (result !== undefined) &#123; return result &#125; // 非对象 if (!isObject(value)) &#123; return value &#125; const isArr = Array.isArray(value) const tag = getTag(value) if (isArr) &#123; // 数组 result = initCloneArray(value) if (!isDeep) &#123; return copyArray(value, result) &#125; &#125; else &#123; // 对象 const isFunc = typeof value == &#x27;function&#x27; if (isBuffer(value)) &#123; return cloneBuffer(value, isDeep) &#125; if (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123; result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value) if (!isDeep) &#123; return isFlat ? copySymbolsIn(value, copyObject(value, keysIn(value), result)) : copySymbols(value, Object.assign(result, value)) &#125; &#125; else &#123; if (isFunc || !cloneableTags[tag]) &#123; return object ? value : &#123;&#125; &#125; result = initCloneByTag(value, tag, isDeep) &#125; &#125; // 循环引用 stack || (stack = new Stack) const stacked = stack.get(value) if (stacked) &#123; return stacked &#125; stack.set(value, result) // Map if (tag == mapTag) &#123; value.forEach((subValue, key) =&gt; &#123; result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack)) &#125;) return result &#125; // Set if (tag == setTag) &#123; value.forEach((subValue) =&gt; &#123; result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack)) &#125;) return result &#125; // TypedArray if (isTypedArray(value)) &#123; return result &#125; // Symbol &amp; 原型链 const keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys) const props = isArr ? undefined : keysFunc(value) // 遍历赋值 arrayEach(props || value, (subValue, key) =&gt; &#123; if (props) &#123; key = subValue subValue = value[key] &#125; assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack)) &#125;) // 返回结果 return result&#125; 3.JSON序列化JSON.parse(JSON.stringify(obj))是比较常用的深拷贝方法之一，它的原理就是利用JSON.stringify 将JavaScript对象序列化成为JSON字符串），并将对象里面的内容转换成字符串，再使用JSON.parse来反序列化，将字符串生成一个新的JavaScript对象。&#x20; 123456789101112131415161718&lt;body&gt; &lt;script&gt; const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小宝&#x27; &#125; &#125; // 把对象转换为 JSON 字符串 // console.log(JSON.stringify(obj)) const o = JSON.parse(JSON.stringify(obj)) console.log(o) o.family.baby = &#x27;123&#x27; console.log(obj) &lt;/script&gt;&lt;/body&gt; 这个方法虽然简单粗暴，但也存在一些问题，在使用该方法时需要注意： 拷贝的对象中如果有函数，undefined，symbol，当使用过JSON.stringify()进行处理之后，都会消失。 无法拷贝不可枚举的属性； 无法拷贝对象的原型链； 拷贝 Date 引用类型会变成字符串； 拷贝 RegExp 引用类型会变成空对象； 对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null； 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 面向对象","path":"/2024/02/22/面向对象的思想/","content":"原型对象构造函数通过原型分配的函数是所有对象所 共享的。 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 构造函数和原型对象中的this 都指向 实例化的对象 1234567891011121314&lt;script&gt; function Person() &#123; // 此处未定义任何方法 &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; // 实例化 let p1 = new Person(); p1.sayHi(); // 输出结果为 Hi~&lt;/script&gt; 构造函数 Person 中未定义任何方法，这时实例对象调用了原型对象中的方法 sayHi，接下来改动一下代码： 12345678910111213141516&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27;); &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27;); &#125; let p1 = new Person(); p1.sayHi(); // 输出结果为 嗨!&lt;/script&gt; 构造函数 Person 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 sayHi。 通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。 123456789101112131415161718192021&lt;script&gt; function Person() &#123; // 此处定义同名方法 sayHi this.sayHi = function () &#123; console.log(&#x27;嗨!&#x27; + this.name) &#125; &#125; // 为构造函数的原型对象添加方法 Person.prototype.sayHi = function () &#123; console.log(&#x27;Hi~&#x27; + this.name) &#125; // 在构造函数的原型对象上添加属性 Person.prototype.name = &#x27;小明&#x27; let p1 = new Person() p1.sayHi(); // 输出结果为 嗨! let p2 = new Person() p2.sayHi()&lt;/script&gt; 总结：结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。 constructor 属性每个原型对象里面都有个constructor 属性（constructor 构造函数） 作用：该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子 使用场景： 如果有多个对象的方法，我们可以给原型对象采取对象形式赋值. 但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了 此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 对象原型对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。 注意： &#x20;__proto__ 是JS非标准属性 [[prototype]]和 __proto__意义相同 用来表明当前实例对象指向哪个原型对象 __proto__ &#x20;__proto__对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数 原型继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;script&gt; // 继续抽取 公共的部分放到原型上 // const Person1 = &#123; // eyes: 2, // head: 1 // &#125; // const Person2 = &#123; // eyes: 2, // head: 1 // &#125; // 构造函数 new 出来的对象 结构一样，但是对象不一样 function Person() &#123; this.eyes = 2 this.head = 1 &#125; // console.log(new Person) // 女人 构造函数 继承 想要 继承 Person function Woman() &#123; &#125; // Woman 通过原型来继承 Person // 父构造函数（父类） 子构造函数（子类） // 子类的原型 = new 父类 Woman.prototype = new Person() // &#123;eyes: 2, head: 1&#125; // 指回原来的构造函数 Woman.prototype.constructor = Woman // 给女人添加一个方法 生孩子 Woman.prototype.baby = function () &#123; console.log(&#x27;宝贝&#x27;) &#125; const red = new Woman() console.log(red) // console.log(Woman.prototype) // 男人 构造函数 继承 想要 继承 Person function Man() &#123; &#125; // 通过 原型继承 Person Man.prototype = new Person() Man.prototype.constructor = Man const pink = new Man() console.log(pink) &lt;/script&gt;&lt;/body&gt; 原型链基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链 12345678910111213141516171819&lt;body&gt; &lt;script&gt; // function Objetc() &#123;&#125; console.log(Object.prototype) console.log(Object.prototype.__proto__) function Person() &#123; &#125; const ldh = new Person() // console.log(ldh.__proto__ === Person.prototype) // console.log(Person.prototype.__proto__ === Object.prototype) console.log(ldh instanceof Person) console.log(ldh instanceof Object) console.log(ldh instanceof Array) console.log([1, 2, 3] instanceof Array) console.log(Array instanceof Object) &lt;/script&gt;&lt;/body&gt; ① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 ② 如果没有就查找它的原型（也就是 proto指向的 prototype 原型对象） ③ 如果还没有就查找原型对象的原型（Object的原型对象） ④ 依此类推一直找到 Object 为止（null） ⑤ proto对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 ⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 构造函数","path":"/2024/02/13/深入对象/","content":"构造函数构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。 12345678&lt;script&gt; // 定义函数 function foo() &#123; console.log(&#x27;通过 new 也能调用函数...&#x27;); &#125; // 调用函数 new foo;&lt;/script&gt; 总结： 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 () 构造函数的返回值即为新创建的对象 构造函数内部的 return 返回的值无效！ 注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。 实例成员通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 总结： 构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 注：构造函数创建的实例对象彼此独立互不影响 静态成员在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 总结： 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数 掌握各引用类型和包装类型对象属性和方法的使用。 在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。 在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。 包装类型在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例： 1234567891011&lt;script&gt; // 字符串类型 const str = &#x27;hello world!&#x27; // 统计字符的长度（字符数量） console.log(str.length) // 数值类型 const price = 12.345 // 保留两位小数 price.toFixed(2) // 12.34&lt;/script&gt; 之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。 ObjectObject 是内置的构造函数，用于创建普通对象。 12345678910111213141516171819202122&lt;script&gt; // 通过构造函数创建普通对象 const user = new Object(&#123;name: &#x27;小明&#x27;, age: 15&#125;) // 这种方式声明的变量称为【字面量】 let student = &#123;name: &#x27;杜子腾&#x27;, age: 21&#125; // 对象语法简写 let name = &#x27;小红&#x27;; let people = &#123; // 相当于 name: name name, // 相当于 walk: function () &#123;&#125; walk () &#123; console.log(&#x27;人都要走路...&#x27;); &#125; &#125; console.log(student.constructor); console.log(user.constructor); console.log(student instanceof Object);&lt;/script&gt; 总结： 推荐使用字面量方式声明对象，而不是 Object 构造函数 Object.assign 静态方法创建新的对象 Object.keys 静态方法获取对象中所有属性 Object.values 表态方法获取对象中所有属性值 ArrayArray 是内置的构造函数，用于创建数组。 12345678&lt;script&gt; // 构造函数创建数组 let arr = new Array(5, 7, 8); // 字面量方式创建数组 let list = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]&lt;/script&gt; 数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 实例方法 reduce 返回函数累计处理的结果 StringString 是内置的构造函数，用于创建字符串。 1234567891011&lt;script&gt; // 使用构造函数创建字符串 let str = new String(&#x27;hello world!&#x27;); // 字面量创建字符串 let str2 = &#x27;你好，世界！&#x27;; // 检测是否属于同一个构造函数 console.log(str.constructor === str2.constructor); // true console.log(str instanceof String); // false&lt;/script&gt; 总结： 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 NumberNumber 是内置的构造函数，用于创建数值。 123456789&lt;script&gt; // 使用构造函数创建数值 let x = new Number(&#x27;10&#x27;) let y = new Number(5) // 字面量创建数值 let z = 20&lt;/script&gt; 总结： 推荐使用字面量方式声明数值，而不是 Number 构造函数 实例方法 toFixed 用于设置保留小数位的长度","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 解构赋值","path":"/2024/01/31/解构赋值/","content":"解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。 1. 数组解构数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示： 12345678910111213&lt;script&gt; // 普通的数组 let arr = [1, 2, 3] // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 let a=1 let b=2;//此处必须加分号 [b,a]=[a,b]&lt;/script&gt; 总结： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析。 需要加分号的两种情况： （1）立即执行函数需要加 （2）数组解构需要加 2. 对象解构对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示： 12345678910111213&lt;script&gt; // 普通对象 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125;; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const &#123;name, age&#125; = user console.log(name) // 小明 console.log(age) // 18&lt;/script&gt; 总结： 赋值运算符 = 左侧的 &#123;&#125; 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 注：支持多维解构赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;script&gt; // 1. 这是后台传递过来的数据 const msg = &#123; &quot;code&quot;: 200, &quot;msg&quot;: &quot;获取新闻列表成功&quot;, &quot;data&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;5G商用自己，三大运用商收入下降&quot;, &quot;count&quot;: 58 &#125;, &#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;国际媒体头条速览&quot;, &quot;count&quot;: 56 &#125;, &#123; &quot;id&quot;: 3, &quot;title&quot;: &quot;乌克兰和俄罗斯持续冲突&quot;, &quot;count&quot;: 1669 &#125;, ] &#125; // 需求1： 请将以上msg对象 采用对象解构的方式 只选出 data 方面后面使用渲染页面 // const &#123; data &#125; = msg // console.log(data) // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数 // const &#123; data &#125; = msg // msg 虽然很多属性，但是我们利用解构只要 data值 function render(&#123; data &#125;) &#123; // const &#123; data &#125; = arr // 我们只要 data 数据 // 内部处理 console.log(data) &#125; render(msg) // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData function render(&#123; data: myData &#125;) &#123; // 要求将 获取过来的 data数据 更名为 myData // 内部处理 console.log(myData) &#125; render(msg) &lt;/script&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 函数提升与参数、箭头函数","path":"/2024/01/24/函数进阶/","content":"1. 函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 1234567891011121314&lt;script&gt; // 调用函数 foo() // 声明函数 function foo() &#123; console.log(&#x27;声明之前即被调用...&#x27;) &#125; // 不存在提升现象 bar() // 错误 var bar = function () &#123; console.log(&#x27;函数表达式不存在提升现象...&#x27;) &#125;&lt;/script&gt; 总结： 函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域当中 2. 函数参数函数参数的使用细节，能够提升函数应用的灵活度。 2.1 默认值12345678910&lt;script&gt; // 设置参数默认值 function sayHi(name=&quot;小明&quot;, age=18) &#123; document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`); &#125; // 调用函数 sayHi(); sayHi(&#x27;小红&#x27;); sayHi(&#x27;小刚&#x27;, 21);&lt;/script&gt; 总结： 声明函数时为形参赋值即为参数的默认值 如果参数未自定义默认值时，参数的默认值为 undefined 调用函数时没有传入对应实参时，参数的默认值被当做实参传入 2.2 动态参数arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。 1234567891011121314&lt;script&gt; // 求生函数，计算所有参数的和 function sum() &#123; // console.log(arguments) let s = 0 for(let i = 0; i &lt; arguments.length; i++) &#123; s += arguments[i] &#125; console.log(s) &#125; // 调用求和函数 sum(5, 10)// 两个参数 sum(1, 2, 4) // 两个参数&lt;/script&gt; 总结： arguments 是一个伪数组 arguments 的作用是动态获取函数的实参 2.3剩余参数12345678&lt;script&gt; function config(baseURL, ...other) &#123; console.log(baseURL) // 得到 &#x27;http://baidu.com&#x27; console.log(other) // other 得到 [&#x27;get&#x27;, &#x27;json&#x27;] &#125; // 调用函数 config(&#x27;http://baidu.com&#x27;, &#x27;get&#x27;, &#x27;json&#x27;);&lt;/script&gt; 总结： ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 2.4 展开运算符 与剩余参数相比剩余参数：函数参数使用，得到真数组 展开运算符：数组中使用，数组展开 3. 箭头函数目的：引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁使用场景:箭头函数更适用于那些本来需要匿名函数的地方 箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;script&gt; // const fn = function () &#123; // console.log(123) // &#125; // 1. 箭头函数 基本语法 // const fn = () =&gt; &#123; // console.log(123) // &#125; // fn() // const fn = (x) =&gt; &#123; // console.log(x) // &#125; // fn(1) // 2. 只有一个形参的时候，可以省略小括号 // const fn = x =&gt; &#123; // console.log(x) // &#125; // fn(1) // // 3. 只有一行代码的时候，我们可以省略大括号 // const fn = x =&gt; console.log(x) // fn(1) // 4. 只有一行代码的时候，可以省略return // const fn = x =&gt; x + x // console.log(fn(1)) // 5. 箭头函数可以直接返回一个对象 // const fn = (uname) =&gt; (&#123; uname: uname &#125;) // console.log(fn(&#x27;刘德华&#x27;)) &lt;/script&gt;&lt;/body&gt; 总结： 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 &#123;&#125;，并自动做为返回值被返回 3.1 箭头函数参数箭头函数中没有 arguments，只能使用 ... 动态获取实参 12345678910111213&lt;body&gt; &lt;script&gt; // 1. 利用箭头函数来求和 const getSum = (...arr) =&gt; &#123; let sum = 0 for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum &#125; const result = getSum(2, 3, 4) console.log(result) // 9 &lt;/script&gt; 3.2 箭头函数 this箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; // 以前this的指向： 谁调用的这个函数，this 就指向谁 // console.log(this) // window // // 普通函数 // function fn() &#123; // console.log(this) // window // &#125; // window.fn() // // 对象方法里面的this // const obj = &#123; // name: &#x27;andy&#x27;, // sayHi: function () &#123; // console.log(this) // obj // &#125; // &#125; // obj.sayHi() // 2. 箭头函数的this 是上一层作用域的this 指向 // const fn = () =&gt; &#123; // console.log(this) // window // &#125; // fn() // 对象方法箭头函数 this // const obj = &#123; // uname: &#x27;pink老师&#x27;, // sayHi: () =&gt; &#123; // console.log(this) // this 指向谁？ window // &#125; // &#125; // obj.sayHi() const obj = &#123; uname: &#x27;pink老师&#x27;, sayHi: function () &#123; console.log(this) // obj let i = 10 const count = () =&gt; &#123; console.log(this) // obj &#125; count() &#125; &#125; obj.sayHi() &lt;/script&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 作用域和作用域链","path":"/2024/01/24/作用域和作用域链/","content":"作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。 1. 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。 123456789101112&lt;script&gt; // 声明 counter 函数 function counter(x, y) &#123; // 函数内部声明的变量 const s = x + y console.log(s) // 18 &#125; // 设用 counter 函数 counter(10, 8) // 访问变量 s console.log(s)// 报错&lt;/script&gt; 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部变量 不同函数内部声明的变量无法互相访问 函数执行完毕后，函数内部的变量实际被清空了 块作用域在 JavaScript 中使用 &#123;&#125; 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。 12345678910111213141516171819202122232425262728&lt;script&gt; &#123; // age 只能在该代码块中被访问 let age = 18; console.log(age); // 正常 &#125; // 超出了 age 的作用域 console.log(age) // 报错 let flag = true; if(flag) &#123; // str 只能在该代码块中被访问 let str = &#x27;hello world!&#x27; console.log(str); // 正常 &#125; // 超出了 age 的作用域 console.log(str); // 报错 for(let t = 1; t &lt;= 6; t++) &#123; // t 只能在该代码块中被访问 console.log(t); // 正常 &#125; // 超出了 t 的作用域 console.log(t); // 报错&lt;/script&gt; JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。 1234567891011121314151617181920&lt;script&gt; // 必须要有值 const version = &#x27;1.0.0&#x27;; // 不能重新赋值 // version = &#x27;1.0.1&#x27;; // 常量值为对象类型 const user = &#123; name: &#x27;小明&#x27;, age: 18 &#125; // 不能重新赋值 user = &#123;&#125;; // 属性和方法允许被修改 user.name = &#x27;小小明&#x27;; user.gender = &#x27;男&#x27;;&lt;/script&gt; 总结： let 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 推荐使用 let 或 const 注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。 2. 全局作用域&lt;script&gt; 标签和 .js 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。 123456789&lt;script&gt; // 此处是全局 function sayHi() &#123; // 此处为局部 &#125; // 此处为全局&lt;/script&gt; 全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示： 1234567891011121314151617181920&lt;script&gt; // 全局变量 name const name = &#x27;小明&#x27; // 函数作用域中访问全局 function sayHi() &#123; // 此处为局部 console.log(&#x27;你好&#x27; + name) &#125; // 全局变量 flag 和 x const flag = true let x = 10 // 块作用域中访问全局 if(flag) &#123; let y = 5 console.log(x + y) // x 是全局的 &#125;&lt;/script&gt; 总结： 为 window 对象动态添加的属性默认也是全局的，不推荐！ 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ 尽可能少的声明全局变量，防止全局变量被污染 JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。 3. 作用域链在解释什么是作用域链前先来看一段代码： 12345678910111213&lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; &#125; &#125;&lt;/script&gt; 函数内部允许创建新的函数，f 函数内部创建的新函数 g，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。 如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。 作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示： 12345678910111213141516171819202122232425262728&lt;script&gt; // 全局作用域 let a = 1 let b = 2 // 局部作用域 function f() &#123; let c // let a = 10; console.log(a) // 1 或 10 console.log(d) // 报错 // 局部作用域 function g() &#123; let d = &#x27;yo&#x27; // let b = 20; console.log(b) // 2 或 20 &#125; // 调用 g 函数 g() &#125; console.log(c) // 报错 console.log(d) // 报错 f();&lt;/script&gt; 总结： 嵌套关系的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父作用域，父级作用域无法访问子级作用域 4. 垃圾回收机制概念垃圾回收机制(Garbage Collection) 简称 GCJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况不再用到的内存，没有及时释放，就叫做内存泄漏 内存的生命周期JS环境中分配的内存, 一般有如下生命周期： 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 说明： &#x20;全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 堆栈空间分配区别1、栈(操作系统)︰由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。2．堆(操作系统)︰一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。下面介绍两种常见的浏览器垃圾回收算法：引用计数法和标记清除法。 引用计数法引用计数 IE采用的引用计数算法，定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象算法: 跟踪记录被引用的次数 如果被引用了一次，那么就记录次数1，多次引用会累加 如果减少一个引用就减1 如果引用次数是0，则释放内存 但它却存在一个致命的问题:嵌套引用（循环引用)。 如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 123456789function fn() &#123; let o1 = &#123;&#125; let o2 = &#123;&#125; o1.a = o2 o2.a = o1 return &#x27;引用计数无法回收&#x27;&#125;fn() 标记清除法现代的浏览器已经不再使用引用计数算法了。 现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心: 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 5. 闭包闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数，如下代码所示： 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;script&gt; // 1. 闭包 : 内层函数 + 外层函数变量 // function outer() &#123; // const a = 1 // function f() &#123; // console.log(a) // &#125; // f() // &#125; // outer() // 2. 闭包的应用： 实现数据的私有。统计函数的调用次数 // let count = 1 // function fn() &#123; // count++ // console.log(`函数被调用$&#123;count&#125;次`) // &#125; // 3. 闭包的写法 统计函数的调用次数 function outer() &#123; let count = 1 function fn() &#123; count++ console.log(`函数被调用$&#123;count&#125;次`) &#125; return fn &#125; const re = outer() // const re = function fn() &#123; // count++ // console.log(`函数被调用$&#123;count&#125;次`) // &#125; re() re() // const fn = function() &#123; &#125; 函数表达式 // 4. 闭包存在的问题： 可能会造成内存泄漏 &lt;/script&gt;&lt;/body&gt; 总结： 1.怎么理解闭包？ 闭包 &#x3D; 内层函数 + 外层函数的变量 2.闭包的作用？ 封闭数据，实现数据私有，外部也可以访问函数内部的变量 闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来 3.闭包可能引起的问题？ 内存泄漏 6. 变量提升变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问， 1234567&lt;script&gt; // 访问变量 str console.log(str + &#x27;world!&#x27;); // 声明变量 str var str = &#x27;hello &#x27;;&lt;/script&gt; 总结： 变量在未声明即被访问时会报语法错误 变量在声明之前即被访问，变量的值为 undefined let 声明的变量不存在变量提升，推荐使用 let 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 let 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可查阅资料。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"hexo使用笔记","path":"/2024/01/23/hexo使用记录/","content":"1、文章内加图片（stellar主题）_config.yml里配置post_asset_folder。 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 在_posts文件夹下新建一个与markdown文件同名的文件夹，放置图片资源。 在markdown文件内，使用’&#x2F;test01.jpg’的路径引入。 2、配色方案https://www.colorhunt.co/ 提供赏心悦目的色彩搭配方案，可以直接复制十六进制。 3、文章的toc（stellar主题）默认从H2开始，分级要严格按照2→3→4→5这样降级，否则会显示错误。 4、配置文章的默认信息如果是手动把已经写好的markdown文件拖入post文件夹上传，需要在markdown文件开始的地方配置默认YAML信息，快捷键为三个➖加换行。本博客使用的配置信息格式为： 12345title: hexo使用笔记categories: blog搭建tags: [blog,踩坑记录]cover: /picture/blog.jpgdate: 2024-01-23 14:52","tags":["blog","踩坑记录"],"categories":["blog搭建"]},{"title":"Javascript 正则表达式","path":"/2024/01/22/正则表达式/","content":"概念定义正则表达式（Regular Expression）是一种字符串匹配的模式（规则）。 使用场景 例如验证表单：手机号表单要求用户只能输入11位的数字 (匹配) 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 正则基本使用 定义规则1const reg = /表达式/ 其中/ /是正则表达式字面量 正则表达式也是对象 使用正则 test()方法 用来查看正则表达式与指定的字符串是否匹配 如果正则表达式与指定的字符串匹配 ，返回true，否则false 123456789101112&lt;body&gt; &lt;script&gt; // 正则表达式的基本使用 const str = &#x27;web前端开发&#x27; // 1. 定义规则 const reg = /web/ // 2. 使用正则 test() console.log(reg.test(str)) // true 如果符合规则匹配上则返回true console.log(reg.test(&#x27;java开发&#x27;)) // false 如果不符合规则匹配上则返回 false &lt;/script&gt;&lt;/body&gt; 元字符普通字符: 大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。 普通字符只能够匹配字符串中与它们相同的字符。 &#x20; 比如，规定用户只能输入英文26个英文字母，普通字符的话 &#x2F;[abcdefghijklmnopqrstuvwxyz]&#x2F; 元字符(特殊字符） 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，换成元字符写法： &#x2F;[a-z]&#x2F; 1. 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 如果 ^ 和 $ 在一起，表示必须是精确匹配 123456789101112131415161718192021222324252627&lt;body&gt; &lt;script&gt; // 元字符之边界符 // 1. 匹配开头的位置 ^ const reg = /^web/ console.log(reg.test(&#x27;web前端&#x27;)) // true console.log(reg.test(&#x27;前端web&#x27;)) // false console.log(reg.test(&#x27;前端web学习&#x27;)) // false console.log(reg.test(&#x27;we&#x27;)) // false // 2. 匹配结束的位置 $ const reg1 = /web$/ console.log(reg1.test(&#x27;web前端&#x27;)) // false console.log(reg1.test(&#x27;前端web&#x27;)) // true console.log(reg1.test(&#x27;前端web学习&#x27;)) // false console.log(reg1.test(&#x27;we&#x27;)) // false // 3. 精确匹配 ^ $ const reg2 = /^web$/ console.log(reg2.test(&#x27;web前端&#x27;)) // false console.log(reg2.test(&#x27;前端web&#x27;)) // false console.log(reg2.test(&#x27;前端web学习&#x27;)) // false console.log(reg2.test(&#x27;we&#x27;)) // false console.log(reg2.test(&#x27;web&#x27;)) // true console.log(reg2.test(&#x27;webweb&#x27;)) // flase &lt;/script&gt;&lt;/body&gt; 2. 量词量词用来设定某个模式重复次数 📌注意： 逗号左右两侧千万不要出现空格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;script&gt; // 元字符之量词 // 1. * 重复次数 &gt;= 0 次 const reg1 = /^w*$/ console.log(reg1.test(&#x27;&#x27;)) // true console.log(reg1.test(&#x27;w&#x27;)) // true console.log(reg1.test(&#x27;ww&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 2. + 重复次数 &gt;= 1 次 const reg2 = /^w+$/ console.log(reg2.test(&#x27;&#x27;)) // false console.log(reg2.test(&#x27;w&#x27;)) // true console.log(reg2.test(&#x27;ww&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 3. ? 重复次数 0 || 1 const reg3 = /^w?$/ console.log(reg3.test(&#x27;&#x27;)) // true console.log(reg3.test(&#x27;w&#x27;)) // true console.log(reg3.test(&#x27;ww&#x27;)) // false console.log(&#x27;-----------------------&#x27;) // 4. &#123;n&#125; 重复 n 次 const reg4 = /^w&#123;3&#125;$/ console.log(reg4.test(&#x27;&#x27;)) // false console.log(reg4.test(&#x27;w&#x27;)) // flase console.log(reg4.test(&#x27;ww&#x27;)) // false console.log(reg4.test(&#x27;www&#x27;)) // true console.log(reg4.test(&#x27;wwww&#x27;)) // false console.log(&#x27;-----------------------&#x27;) // 5. &#123;n,&#125; 重复次数 &gt;= n const reg5 = /^w&#123;2,&#125;$/ console.log(reg5.test(&#x27;&#x27;)) // false console.log(reg5.test(&#x27;w&#x27;)) // false console.log(reg5.test(&#x27;ww&#x27;)) // true console.log(reg5.test(&#x27;www&#x27;)) // true console.log(&#x27;-----------------------&#x27;) // 6. &#123;n,m&#125; n =&lt; 重复次数 &lt;= m const reg6 = /^w&#123;2,4&#125;$/ console.log(reg6.test(&#x27;w&#x27;)) // false console.log(reg6.test(&#x27;ww&#x27;)) // true console.log(reg6.test(&#x27;www&#x27;)) // true console.log(reg6.test(&#x27;wwww&#x27;)) // true console.log(reg6.test(&#x27;wwwww&#x27;)) // false // 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败 &lt;/script&gt; 3. 范围表示字符的范围，定义的规则限定在某个范围，比如只能是英文字母，或者数字等等，用表示范围 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;script&gt; // 元字符之范围 [] // 1. [abc] 匹配包含的单个字符， 多选1 const reg1 = /^[abc]$/ console.log(reg1.test(&#x27;a&#x27;)) // true console.log(reg1.test(&#x27;b&#x27;)) // true console.log(reg1.test(&#x27;c&#x27;)) // true console.log(reg1.test(&#x27;d&#x27;)) // false console.log(reg1.test(&#x27;ab&#x27;)) // false // 2. [a-z] 连字符 单个 const reg2 = /^[a-z]$/ console.log(reg2.test(&#x27;a&#x27;)) // true console.log(reg2.test(&#x27;p&#x27;)) // true console.log(reg2.test(&#x27;0&#x27;)) // false console.log(reg2.test(&#x27;A&#x27;)) // false // 想要包含小写字母，大写字母 ，数字 const reg3 = /^[a-zA-Z0-9]$/ console.log(reg3.test(&#x27;B&#x27;)) // true console.log(reg3.test(&#x27;b&#x27;)) // true console.log(reg3.test(9)) // true console.log(reg3.test(&#x27;,&#x27;)) // flase // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位 const reg4 = /^[a-zA-Z0-9_]&#123;6,16&#125;$/ console.log(reg4.test(&#x27;abcd1&#x27;)) // false console.log(reg4.test(&#x27;abcd12&#x27;)) // true console.log(reg4.test(&#x27;ABcd12&#x27;)) // true console.log(reg4.test(&#x27;ABcd12_&#x27;)) // true // 3. [^a-z] 取反符 const reg5 = /^[^a-z]$/ console.log(reg5.test(&#x27;a&#x27;)) // false console.log(reg5.test(&#x27;A&#x27;)) // true console.log(reg5.test(8)) // true &lt;/script&gt;&lt;/body&gt; 4. 字符类某些常见模式的简写方式，区分字母和数字 替换和修饰符replace 替换方法，可以完成字符的替换 123456789&lt;body&gt; &lt;script&gt; // 替换和修饰符 const str = &#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个 &lt;/script&gt;&lt;/body&gt; 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 i 是单词 ignore 的缩写，正则匹配时字母不区分大小写 g 是单词 global 的缩写，匹配所有满足正则表达式的结果 12345678910111213&lt;body&gt; &lt;script&gt; // 替换和修饰符 const str = &#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27; // 1. 替换 replace 需求：把前端替换为 web // 1.1 replace 返回值是替换完毕的字符串 // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个 // 2. 修饰符 g 全部替换 const strEnd = str.replace(/前端/g, &#x27;web&#x27;) console.log(strEnd) &lt;/script&gt;&lt;/body&gt; change 事件给input注册 change 事件，值被修改并且失去焦点后触发 判断是否有类 元素.classList.contains() 看看有没有包含某个类，如果有则返回true，么有则返回false","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript 本地存储","path":"/2024/01/22/本地存储/","content":"本地存储：将数据存储在本地浏览器中 常见的使用场景： https://todomvc.com/examples/vanilla-es6/ 页面刷新数据不丢失 好处： 1、页面刷新或者关闭不丢失数据，实现数据持久化 2、容量较大，sessionStorage和 localStorage 约 5M 左右 localStorage（重点）作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失 特性：以键值对的形式存储，并且存储的是字符串， 省略了window 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;本地存储-localstorage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 本地存储 - localstorage 存储的是字符串 // 1. 存储 localStorage.setItem(&#x27;age&#x27;, 18) // 2. 获取 console.log(typeof localStorage.getItem(&#x27;age&#x27;)) // 3. 删除 localStorage.removeItem(&#x27;age&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; sessionStorage（了解）特性： 用法跟localStorage基本相同 区别是：当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除 存储：sessionStorage.setItem(key,value) 获取：sessionStorage.getItem(key) 删除：sessionStorage.removeItem(key) localStorage 存储复杂数据类型问题：本地只能存储字符串,无法存储复杂数据类型. 解决：需要将复杂数据类型转换成 JSON字符串,在存储到本地 语法：JSON.stringify(复杂数据类型) JSON字符串： 首先是1个字符串 属性名使用双引号引起来，不能单引号 属性值如果是字符串型也必须双引号 12345678910111213141516&lt;body&gt; &lt;script&gt; // 本地存储复杂数据类型 const goods = &#123; name: &#x27;小米&#x27;, price: 1999 &#125; // localStorage.setItem(&#x27;goods&#x27;, goods) // console.log(localStorage.getItem(&#x27;goods&#x27;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(&#x27;goods&#x27;)) &lt;/script&gt;&lt;/body&gt; 问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用 解决： 把取出来的字符串转换为对象 语法：JSON.parse(JSON字符串) 123456789&lt;body&gt; &lt;script&gt; // 本地存储复杂数据类型 const goods = &#123; name: &#x27;小米&#x27;, price: 1999 &#125; // localStorage.setItem(&#x27;goods&#x27;, goods) // console.log(localStorage.getItem(&#x27;goods&#x27;)) // 1. 把对象转换为JSON字符串 JSON.stringify localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods)) // console.log(typeof localStorage.getItem(&#x27;goods&#x27;)) // 2. 把JSON字符串转换为对象 JSON.parse console.log(JSON.parse(localStorage.getItem(&#x27;goods&#x27;))) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"hexo+stellar+github actions实现自动部署","path":"/2024/01/16/hexo+stellar+github actions实现自动部署/","content":"博客的持续部署抛开定义，直观上，持续部署，顾名思义，就是持续不断地去部署，部署自动紧跟代码改变：你的提交了源码修改，部署上就自动更新了。对于我们的博客系统，也就是新建&#x2F;修改&#x2F;删除了文章，博客站点就自动更新、修改对应内容。从效果上来说，就是我们不用再去手动 hexo g -d 生成、部署了。 用持续部署，首先提交源码，然后在云端就自动生成(编译)、部署，这个生成、部署的工作是不需要在本地完成的，由github提供的 CI&#x2F;CD 服务的服务器自动来完成。GitHub 免费提供的这项服务叫做 GitHub Actions。 1. 前提工作本教程在以下环境搭建。 12345hexo: 6.3.0hexo-cli: 4.3.0os: win32 10.0.19042node: 16.17.1hexo-deployer-git: 4.0.0 1.1创建所需仓库 创建 blog 仓库用来存放 Hexo 项目 创建 your.github.io 仓库用来存放静态博客页面 1.2生成部署密钥12$ ssh-keygen -f github-deploy-key 一路按回车直到生成成功 当前目录下会有 github-deploy-key 和 github-deploy-key.pub 两个文件。 1.3 配置部署密钥复制 github-deploy-key 文件内容，在 blog 仓库 Settings -&gt; Secrets and variables -&gt; Actions 页面上添加。 在 Name 输入框填写 HEXO_DEPLOY_PRI。 在 Value 输入框填写 github-deploy-key 文件内容。 复制 github-deploy-key.pub 文件内容，在 your.github.io 仓库 Settings -&gt; Deploy keys -&gt; Add deploy key 页面上添加。 在 Title 输入框填写 HEXO_DEPLOY_PUB。 在 Key 输入框填写 github-deploy-key.pub 文件内容。 勾选 Allow write access 选项。 2. 配置workflow在 blog 仓库根目录下创建 .github/workflows/deploy.yml 文件。 在 deploy.yml 文件中粘贴以下内容。 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667name: CIon: push: branches: - mainenv: GIT_USER: YYYutang GIT_EMAIL: email@email.com THEME_REPO: YYYutang/hexo-theme-stellar THEME_BRANCH: main DEPLOY_REPO: YYYutang/YYYutang.github.io DEPLOY_BRANCH: mainjobs: build: name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125; runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v2 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.THEME_REPO &#125;&#125; ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125; path: themes/stellar - name: Checkout deploy repo uses: actions/checkout@v2 with: repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125; ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125; path: .deploy_git - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node_version &#125;&#125; - name: Configuration environment env: HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125; run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL cp _config.theme.yml themes/stellar/_config.yml - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 模版参数说明 name 为此 Action 的名字 on 触发条件，当满足条件时会触发此任务，这里的 on.push.branches.$.master 是指当 master 分支收到 push 后执行任务。 env 为环境变量对象 env.GIT_USER 为 Hexo 编译后使用此 git 用户部署到仓库。 env.GIT_EMAIL 为 Hexo 编译后使用此 git 邮箱部署到仓库。 env.THEME_REPO 为您的 Hexo 所使用的主题的仓库，这里为 sanonz/hexo-theme-concise。 env.THEME_BRANCH 为您的 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA。 env.DEPLOY_REPO 为 Hexo 编译后要部署的仓库，例如：sanonz/sanonz.github.io。 env.DEPLOY_BRANCH 为 Hexo 编译后要部署到的分支，例如：master。 jobs 为此 Action 下的任务列表 jobs.{job}.name 任务名称 jobs.{job}.runs-on 任务所需容器，可选值：ubuntu-latest、windows-latest、macos-latest。 jobs.{job}.strategy 策略下可以写 array 格式，此 job 会遍历此数组执行。 jobs.{job}.steps 一个步骤数组，可以把所要干的事分步骤放到这里。 jobs.{job}.steps.$.name 步骤名，编译时会会以 LOG 形式输出。 jobs.{job}.steps.$.uses 所要调用的 Action，可以到 https://github.com/actions 查看更多。 jobs.{job}.steps.$.with 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。 这里踩的坑有： 1、path: themes&#x2F;stellar的主题地址忘记换成自己的，导致部署上去之后，所有的html文件均为空文件，并且页面加载不出来。 2、部署成功，但在workflow里deploy那一步有大量报错，说找不到avatar属性，一开始以为是部署流程只识别了_config.theme.yml,所以没有识别_config.yml里设置的avatar，遂修改_config.theme.yml，但没有起作用。 仔细检查发现主题是通过THEME_REPO设置的github连接引入的，而我github上fork的是一个比较早的版本的stellar，本地使用的_config.theme.yml是最新版本的stellar里提供的配置文件。将github上的主题仓库更新至最新版，问题解决。 3、报大量的语法错误 是指定的node_version过低的问题，最新版的stellar不适配12.x的版本，修改为15.x以上即可。 4、报错ERROR Deployer not found: git，需要安装 hexo-deployer-git。 1npm install hexo-deployer-git --save 3. 修改_config.yml里的deploy配置1234567# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: &#x27;git&#x27; repo: git@github.com:yyyutang/YYYutang.github.io.git branch: main message: $&#123;&#123; github.event.head_commit.message &#125;&#125; 4. 配置theme的_config文件复制一份 使用的theme根目录下的_config.yml，放到 blog 根目录下，名为 _config.theme.yml，如果您已经配置过此文件，只需要把您的复制过来就行。 这里注意需要把网站的基础信息，如头像Avatar、标题Title等设置好。 5.执行任务写一篇文章，push 到 blog 仓库的 main 分支，在此仓库 Actions 页面查看当前 task。 当任务完成后查看您的博客 https://your.github.io，如果不出意外的话已经可以看到新添加的文章了。","tags":["blog","踩坑记录"],"categories":["blog搭建"]},{"title":"Javascript Windows对象","path":"/2024/01/16/Window对象/","content":"JavaScript的组成 ECMAScript: 规定了js基础语法核心知识。 比如：变量、分支语句、循环语句、对象等等 Web APIs : DOM 文档对象模型， 定义了一套操作HTML文档的API BOM 浏览器对象模型，定义了一套操作浏览器窗口的API JS执行机制同步任务同步任务都在主线程上执行，形成一个执行栈。 异步任务JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型: 1、普通事件，如 click、resize 等 2、资源加载，如 load、error 等 3、定时器，包括 setInterval、setTimeout 等 异步任务相关添加到任务队列中（任务队列也称为消息队列）。 事件循环 先执行执行栈中的同步任务。 异步任务放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 BOM对象BOM (Browser Object Model ) 是浏览器对象模型 window对象是一个全局对象，也可以说是JavaScript中的顶级对象 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window 定时器-延迟函数JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout 语法： 1setTimeout(回调函数, 延迟时间) setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window 间歇函数 setInterval : 每隔一段时间就执行一次, 平时省略window 清除延时函数： 1clearTimeout(timerId) 注意点1. 延时函数需要等待,所以后面的代码先执行2. 返回值是一个正整数，表示定时器的编号 12345678910111213141516171819&lt;body&gt; &lt;script&gt; // 定时器之延迟函数 // 1. 开启延迟函数 let timerId = setTimeout(function () &#123; console.log(&#x27;我只执行一次&#x27;) &#125;, 3000) // 1.1 延迟函数返回的还是一个正整数数字，表示延迟函数的编号 console.log(timerId) // 1.2 延迟函数需要等待时间，所以下面的代码优先执行 // 2. 关闭延迟函数 clearTimeout(timerId) &lt;/script&gt;&lt;/body&gt; location对象location (地址) 它拆分并保存了 URL 地址的各个组成部分， 它是一个对象 属性&#x2F;方法 说明 href 属性，获取完整的 URL 地址，赋值时用于地址的跳转 search 属性，获取地址中携带的参数，符号 ？后面部分 hash 属性，获取地址中的哈希值，符号 # 后面部分 reload() 方法，用来刷新当前页面，传入参数 true 时表示强制刷新 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;search&quot;&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;a href=&quot;#/music&quot;&gt;音乐&lt;/a&gt; &lt;a href=&quot;#/download&quot;&gt;下载&lt;/a&gt; &lt;button class=&quot;reload&quot;&gt;刷新页面&lt;/button&gt; &lt;script&gt; // location 对象 // 1. href属性 （重点） 得到完整地址，赋值则是跳转到新地址 console.log(location.href) // location.href = &#x27;http://www.itcast.cn&#x27; // 2. search属性 得到 ? 后面的地址 console.log(location.search) // ?search=笔记本 // 3. hash属性 得到 # 后面的地址 console.log(location.hash) // 4. reload 方法 刷新页面 const btn = document.querySelector(&#x27;.reload&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // location.reload() // 页面刷新 location.reload(true) // 强制页面刷新 ctrl+f5 &#125;) &lt;/script&gt;&lt;/body&gt; navigator对象navigator是对象，该对象下记录了浏览器自身的相关信息 常用属性和方法： 通过 userAgent 检测浏览器的版本及平台 12345678910// 检测 userAgent（浏览器信息）(function () &#123; const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) &#123; location.href = &#x27;http://m.itcast.cn&#x27; &#125;&#125;)(); histroy对象history (历史)是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退等 使用场景 history对象一般在实际开发中比较少用，但是会在一些OA 办公系统中见到。 常见方法： 123456789101112131415161718192021&lt;body&gt; &lt;button class=&quot;back&quot;&gt;←后退&lt;/button&gt; &lt;button class=&quot;forward&quot;&gt;前进→&lt;/button&gt; &lt;script&gt; // histroy对象 // 1.前进 const forward = document.querySelector(&#x27;.forward&#x27;) forward.addEventListener(&#x27;click&#x27;, function () &#123; // history.forward() history.go(1) &#125;) // 2.后退 const back = document.querySelector(&#x27;.back&#x27;) back.addEventListener(&#x27;click&#x27;, function () &#123; // history.back() history.go(-1) &#125;) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript M端事件","path":"/2024/01/16/M端事件/","content":"移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。 touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 常见的触屏事件如下：","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM节点","path":"/2024/01/16/DOM节点/","content":"回顾之前 DOM 的操作都是针对元素节点的属性或文本的，除此之外也有专门针对元素节点本身的操作，如插入、复制、删除、替换等。 插入节点在已有的 DOM 节点中插入新的 DOM 节点时，需要关注两个关键因素：首先要得到新的 DOM 节点，其次在哪个位置插入这个节点。 如下代码演示： 123456789101112131415161718192021222324252627&lt;body&gt; &lt;h3&gt;插入节点&lt;/h3&gt; &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt; &lt;hr&gt; &lt;!-- 普通盒子 --&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!-- 点击按钮向 box 盒子插入节点 --&gt; &lt;button class=&quot;btn&quot;&gt;插入节点&lt;/button&gt; &lt;script&gt; // 点击按钮，在网页中插入节点 const btn = document.querySelector(&#x27;.btn&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // 1. 获得一个 DOM 元素节点 const p = document.createElement(&#x27;p&#x27;) p.innerText = &#x27;创建的新的p标签&#x27; p.className = &#x27;info&#x27; // 复制原有的 DOM 节点 const p2 = document.querySelector(&#x27;p&#x27;).cloneNode(true) p2.style.color = &#x27;red&#x27; // 2. 插入盒子 box 盒子 document.querySelector(&#x27;.box&#x27;).appendChild(p) document.querySelector(&#x27;.box&#x27;).appendChild(p2) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： createElement 动态创建任意 DOM 节点 cloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点 appendChild 在末尾（结束标签前）插入节点 再来看另一种情形的代码演示： 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;h3&gt;插入节点&lt;/h3&gt; &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt; &lt;hr&gt; &lt;button class=&quot;btn1&quot;&gt;在任意节点前插入&lt;/button&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 点击按钮，在已有 DOM 中插入新节点 const btn1 = document.querySelector(&#x27;.btn1&#x27;) btn1.addEventListener(&#x27;click&#x27;, function () &#123; // 第 2 个 li 元素 const relative = document.querySelector(&#x27;li:nth-child(2)&#x27;) // 1. 动态创建新的节点 const li1 = document.createElement(&#x27;li&#x27;) li1.style.color = &#x27;red&#x27; li1.innerText = &#x27;Web APIs&#x27; // 复制现有的节点 const li2 = document.querySelector(&#x27;li:first-child&#x27;).cloneNode(true) li2.style.color = &#x27;blue&#x27; // 2. 在 relative 节点前插入 document.querySelector(&#x27;ul&#x27;).insertBefore(li1, relative) document.querySelector(&#x27;ul&#x27;).insertBefore(li2, relative) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： createElement 动态创建任意 DOM 节点 cloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点 insertBefore 在父节点中任意子节点之前插入新节点 删除节点删除现有的 DOM 节点，也需要关注两个因素：首先由父节点删除子节点，其次是要删除哪个子节点。 12345678910111213141516171819202122&lt;body&gt; &lt;!-- 点击按钮删除节点 --&gt; &lt;button&gt;删除节点&lt;/button&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const btn = document.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // 获取 ul 父节点 let ul = document.querySelector(&#x27;ul&#x27;) // 待删除的子节点 let lis = document.querySelectorAll(&#x27;li&#x27;) // 删除节点 ul.removeChild(lis[0]) &#125;) &lt;/script&gt;&lt;/body&gt; 结论：removeChild 删除节点时一定是由父子关系。 查找节点DOM 树中的任意节点都不是孤立存在的，它们要么是父子关系，要么是兄弟关系，不仅如此，我们可以依据节点之间的关系查找节点。 父子关系12345678910111213141516171819202122&lt;body&gt; &lt;button class=&quot;btn1&quot;&gt;所有的子节点&lt;/button&gt; &lt;!-- 获取 ul 的子节点 --&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript 基础&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const btn1 = document.querySelector(&#x27;.btn1&#x27;) btn1.addEventListener(&#x27;click&#x27;, function () &#123; // 父节点 const ul = document.querySelector(&#x27;ul&#x27;) // 所有的子节点 console.log(ul.childNodes) // 只包含元素子节点 console.log(ul.children) &#125;) &lt;/script&gt;&lt;/body&gt; 结论： childNodes 获取全部的子节点，回车换行会被认为是空白文本节点 children 只获取元素类型节点 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td width=&quot;60&quot;&gt;序号&lt;/td&gt; &lt;td&gt;课程名&lt;/td&gt; &lt;td&gt;难度&lt;/td&gt; &lt;td width=&quot;80&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;/td&gt; &lt;td&gt;初级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;/td&gt; &lt;td&gt;初级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;&lt;span&gt;Web APIs&lt;/span&gt;&lt;/td&gt; &lt;td&gt;中级&lt;/td&gt; &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script&gt; // 获取所有 button 节点，并添加事件监听 const buttons = document.querySelectorAll(&#x27;table button&#x27;) for(let i = 0; i &lt; buttons.length; i++) &#123; buttons[i].addEventListener(&#x27;click&#x27;, function () &#123; // console.log(this.parentNode); // 父节点 td // console.log(this.parentNode.parentNode); // 爷爷节点 tr this.parentNode.parentNode.style.color = &#x27;red&#x27; &#125;) &#125; &lt;/script&gt;&lt;/body&gt; 结论：parentNode 获取父节点，以相对位置查找节点，实际应用中非常灵活。 兄弟关系12345678910111213141516171819202122&lt;body&gt; &lt;ul&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript 基础&lt;/li&gt; &lt;li&gt;Web APIs&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 获取所有 li 节点 const lis = document.querySelectorAll(&#x27;ul li&#x27;) // 对所有的 li 节点添加事件监听 for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].addEventListener(&#x27;click&#x27;, function () &#123; // 前一个节点 console.log(this.previousSibling) // 下一下节点 console.log(this.nextSibling) &#125;) &#125; &lt;/script&gt;&lt;/body&gt; 12345678910111213141516&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // const ul = document.querySelector(&#x27;ul&#x27;) // ul // console.log(ul.children) // 得到伪数组 选择的是 亲儿子 const li2 = document.querySelector(&#x27;ul li:nth-child(2)&#x27;) console.log(li2.previousElementSibling) // 上一个兄弟 console.log(li2.nextElementSibling) // 下一个兄弟 &lt;/script&gt;&lt;/body&gt; 结论： previousSibling 获取前一个节点，回车换行会被认为是空白文本节点 nextSibling 获取后一个节点，回车换行会被认为是空白文本节点 previousElementSibling 获取前一个节点，以相对位置查找节点，实际应用中非常灵活。 nextElementSibling 获取后一个节点，以相对位置查找节点，实际应用中非常灵活。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM事件基础","path":"/2024/01/16/DOM事件基础/","content":"事件监听结合 DOM 使用事件时，需要为 DOM 对象添加事件监听，等待事件发生（触发）时，便立即调用一个函数。 addEventListener 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为【事件类型】和【事件回调】。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;事件监听&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;事件监听&lt;/h3&gt; &lt;p id=&quot;text&quot;&gt;为 DOM 元素添加事件监听，等待事件发生，便立即执行一个函数。&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;点击改变文字颜色&lt;/button&gt; &lt;script&gt; // 1. 获取 button 对应的 DOM 对象 const btn = document.querySelector(&#x27;#btn&#x27;) // 2. 添加事件监听 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;等待事件被触发...&#x27;) // 改变 p 标签的文字颜色 let text = document.getElementById(&#x27;text&#x27;) text.style.color = &#x27;red&#x27; &#125;) // 3. 只要用户点击了按钮，事件便触发了！！！ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 完成事件监听分成3个步骤： 获取 DOM 元素 通过 addEventListener 方法为 DOM 节点添加事件监听 等待事件触发，如用户点击了某个按钮时便会触发 click 事件类型 事件触发后，相对应的回调函数会被执行 大白话描述：所谓的事件无非就是找个机会（事件触发）调用一个函数（回调函数）。&#x20; 事件类型将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等，我们逐一展开学习。 鼠标事件鼠标事件是指跟鼠标操作相关的事件，如单击、双击、移动等。 `mouseenter 监听鼠标是否移入 DOM 元素 123456789101112131415161718&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移入当前 DOM 元素 box.addEventListener(&#x27;mouseenter&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移入了...&#x27;; // 修改光标的风格 this.style.cursor = &#x27;move&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; 2.`mouseleave 监听鼠标是否移出 DOM 元素 12345678910111213141516&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移出当前 DOM 元素 box.addEventListener(&#x27;mouseleave&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移出了...&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; 键盘事件keydown 键盘按下触发keyup 键盘抬起触发 焦点事件focus 获得焦点 blur 失去焦点 文本框输入事件input 事件对象任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。 123456789101112131415161718&lt;body&gt; &lt;h3&gt;事件对象&lt;/h3&gt; &lt;p&gt;任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取 .box 元素 const box = document.querySelector(&#x27;.box&#x27;) // 添加事件监听 box.addEventListener(&#x27;click&#x27;, function (e) &#123; console.log(&#x27;任意事件类型被触发后，相关信息会以对象形式被记录下来...&#x27;); // 事件回调函数的第1个参数即所谓的事件对象 console.log(e) &#125;) &lt;/script&gt;&lt;/body&gt; 事件回调函数的【第1个参数】即所谓的事件对象，通常习惯性的将这个对数命名为 event、ev 、ev 。 接下来简单看一下事件对象中包含了哪些有用的信息： ev.type 当前事件的类型 ev.clientX/Y 光标相对浏览器窗口的位置 ev.offsetX/Y 光标相于当前 DOM 元素的位置 注：在事件回调函数内部通过 window.event 同样可以获取事件对象。 环境对象 能够分析判断函数运行在不同环境中 this 所指代的对象。 环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境。 123456789101112131415161718192021222324252627&lt;script&gt; // 声明函数 function sayHi() &#123; // this 是一个变量 console.log(this); &#125; // 声明一个对象 let user = &#123; name: &#x27;张三&#x27;, sayHi: sayHi // 此处把 sayHi 函数，赋值给 sayHi 属性 &#125; let person = &#123; name: &#x27;李四&#x27;, sayHi: sayHi &#125; // 直接调用 sayHi() // window window.sayHi() // window // 做为对象方法调用 user.sayHi()// user person.sayHi()// person&lt;/script&gt; 结论： this 本质上是一个变量，数据类型为对象 函数的调用方式不同 this 变量的值也不同 【谁调用 this 就是谁】是判断 this 值的粗略规则 函数直接调用时实际上 window.sayHi() 所以 this 的值为 window 回调函数如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数。 1234567891011121314151617&lt;script&gt; // 声明 foo 函数 function foo(arg) &#123; console.log(arg); &#125; // 普通的值做为参数 foo(10); foo(&#x27;hello world!&#x27;); foo([&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]); function bar() &#123; console.log(&#x27;函数也能当参数...&#x27;); &#125; // 函数也可以做为参数！！！！ foo(bar);&lt;/script&gt; 结论： 回调函数本质还是函数，只不过把它当成参数使用 使用匿名函数做为回调函数比较常见","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM事件进阶","path":"/2024/01/16/DOM事件进阶/","content":"事件流事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。 如上图所示，任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。 简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。 捕获和冒泡了解了什么是事件流之后，我们来看事件流是如何影响事件执行的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;); const inner = document.querySelector(&#x27;.inner&#x27;); const child = document.querySelector(&#x27;.child&#x27;); // html 元素添加事件 document.documentElement.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;html...&#x27;) &#125;) // body 元素添加事件 document.body.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;body...&#x27;) &#125;) // 外层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;) // 内层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;child...&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？ 结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。 再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。 如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。 如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。 12345678910111213141516171819202122&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;, true) // true 表示在捕获阶段执行事件 // 中间的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;, true) &lt;/script&gt;&lt;/body&gt; 结论： addEventListener 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发 addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false 事件流只会在父子元素具有相同事件类型时才会产生影响 绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获） 如果使用onclick方法，则只有冒泡阶段，没有捕获。 阻止冒泡1、阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;h3&gt;阻止冒泡&lt;/h3&gt; &lt;p&gt;阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) const child = document.querySelector(&#x27;.child&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子 inner.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;inner...&#x27;) // 阻止事件冒泡 ev.stopPropagation() &#125;) // 内层的盒子 child.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;child...&#x27;) // 借助事件对象，阻止事件向上冒泡 ev.stopPropagation() &#125;) &lt;/script&gt;&lt;/body&gt; 结论：事件对象中的 ev.stopPropagation 方法，专门用来阻止事件冒泡。 鼠标经过事件：mouseover 和 mouseout 会有冒泡效果mouseenter 和 mouseleave 没有冒泡效果 (推荐) 123456789101112131415&lt;body&gt; &lt;div class=&quot;dad&quot;&gt; &lt;div class=&quot;baby&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const dad = document.querySelector(&#x27;.dad&#x27;) const baby = document.querySelector(&#x27;.baby&#x27;) dad.addEventListener(&#x27;mouseover&#x27;, function () &#123; console.log(&#x27;鼠标经过&#x27;) &#125;) dad.addEventListener(&#x27;mouseout&#x27;, function () &#123; console.log(&#x27;鼠标离开&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 鼠标经过dad进入baby时，会打印三行 因为经过baby的时候，虽然baby没有绑定事件，但依然会冒泡至dad的mouseover方法。 2、我们某些情况下需要阻止元素的默认行为的发生，比如 阻止链接的跳转，表单域跳转。 e.preventDefault() 事件解绑onclick的解绑方法： 12345btn.onclick=function()&#123;alert(&#x27;点击了&#x27;)&#125;btn.onclick=null addeventlistener的解绑方法： 1234567function fn()&#123;alert(&#x27;点击了&#x27;)&#125;btn.addEventListener(&#x27;click&#x27;,fn)btn.removeEventListener(&#x27;click&#x27;,fn) 注：匿名函数无法被解绑 事件委托事件委托是利用事件流的特征解决一些现实开发需求的知识技巧，主要的作用是提升程序效率。 大量的事件监听是比较耗费性能的，如下代码所示 1234567891011&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;); for(let i = 0; i &lt;= buttons.length; i++) &#123; // 为 10000 个 button 元素添加了事件 buttons.addEventListener(&#x27;click&#x27;, function () &#123; // 省略具体执行逻辑... &#125;) &#125;&lt;/script&gt; 利用事件流的特征，可以对上述的代码进行优化，事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化，如下代码所示： 12345678910&lt;script&gt; // 假设页面中有 10000 个 button 元素 let buttons = document.querySelectorAll(&#x27;table button&#x27;); // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table let parents = document.querySelector(&#x27;table&#x27;); parents.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;点击任意子元素都会触发事件...&#x27;); &#125;)&lt;/script&gt; 我们的最终目的是保证只有点击 button 子元素才去执行事件的回调函数，如何判断用户点击是哪一个子元素呢？ 事件对象中的属性 target 或 srcElement属性表示真正触发事件的元素，它是一个元素类型的节点。 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul&gt; &lt;li&gt;第1个孩子&lt;/li&gt; &lt;li&gt;第2个孩子&lt;/li&gt; &lt;li&gt;第3个孩子&lt;/li&gt; &lt;li&gt;第4个孩子&lt;/li&gt; &lt;li&gt;第5个孩子&lt;/li&gt; &lt;p&gt;我不需要变色&lt;/p&gt; &lt;/ul&gt;&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;) // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table const parents = document.querySelector(&#x27;table&#x27;) parents.addEventListener(&#x27;click&#x27;, function (ev) &#123; // console.log(ev.target); // 只有 button 元素才会真正去执行逻辑 e.target.style.color=&#x27;red&#x27;//这么实现点击&lt;P&gt;标签时仍然会变色，无法实现只点击li才变色 if(ev.target.tagName === &#x27;BUTTON&#x27;) &#123; // 执行的逻辑 &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 优化过的代码只对祖先元素添加事件监听，相比对 10000 个元素添加事件监听执行效率要高许多！！！ tab切换的案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;tab栏切换&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .tab &#123; width: 590px; height: 340px; margin: 20px; border: 1px solid #e4e4e4; &#125; .tab-nav &#123; width: 100%; height: 60px; line-height: 60px; display: flex; justify-content: space-between; &#125; .tab-nav h3 &#123; font-size: 24px; font-weight: normal; margin-left: 20px; &#125; .tab-nav ul &#123; list-style: none; display: flex; justify-content: flex-end; &#125; .tab-nav ul li &#123; margin: 0 20px; font-size: 14px; &#125; .tab-nav ul li a &#123; text-decoration: none; border-bottom: 2px solid transparent; color: #333; &#125; .tab-nav ul li a.active &#123; border-color: #e1251b; color: #e1251b; &#125; .tab-content &#123; padding: 0 16px; &#125; .tab-content .item &#123; display: none; &#125; .tab-content .item.active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tab&quot;&gt; &lt;div class=&quot;tab-nav&quot;&gt; &lt;h3&gt;每日特价&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;javascript:;&quot; data-id=&quot;0&quot;&gt;精选&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;1&quot;&gt;美食&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;2&quot;&gt;百货&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;3&quot;&gt;个护&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; data-id=&quot;4&quot;&gt;预告&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;tab-content&quot;&gt; &lt;div class=&quot;item active&quot;&gt;&lt;img src=&quot;./assets/tab00.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab01.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab02.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab03.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src=&quot;./assets/tab04.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //遍历 // const as=document.querySelectorAll(&#x27;.tab-nav a&#x27;) // for(let i=0;i&lt;as.length;i++)&#123; // as[i].addEventListener(&#x27;mouseenter&#x27;,function()&#123; // document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) // as[i].classList.add(&#x27;active&#x27;) // document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) // document.querySelector(`.tab-content .item:nth-child($&#123;i+1&#125;)`).classList.add(&#x27;active&#x27;) // &#125;) // &#125; //事件委托 const ul=document.querySelector(&#x27;.tab-nav ul&#x27;) ul.addEventListener(&#x27;click&#x27;,function(e)&#123; if(e.target.tagName===&#x27;A&#x27;)&#123; document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) e.target.classList.add(&#x27;active&#x27;) const id=+e.target.dataset.id document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) document.querySelector(`.tab-content .item:nth-child($&#123;id+1&#125;)`).classList.add(&#x27;active&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其他事件1. 页面加载事件加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 有些时候需要等页面资源全部处理完了做一些事情 事件名：load监听页面所有资源加载完毕： 123window.addEventListener(&#x27;load&#x27;, function() &#123; // xxxxx&#125;) 事件名：DOMContentLoaded监听页面DOM加载完毕， 无需等待样式表、图像等完全加载。 12document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;&#125;) 2. 元素滚动事件滚动条在滚动的时候持续触发的事件 123window.addEventListener(&#x27;scroll&#x27;, function() &#123; // xxxxx&#125;) 3. 获取位置开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素。 document.documentElement.scrollTop 12345window.addEventListener(&#x27;scroll&#x27;, function() &#123; // xxxxx const n=document.documentElement.scrollTop console.log(n)&#125;) 4. 页面尺寸事件会在窗口尺寸改变的时候触发事件： 123window.addEventListener(&#x27;resize&#x27;, function() &#123; // xxxxx&#125;) 5. 元素尺寸与位置获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 事件名：load 获取元素的可见部分宽高获取元素的可见部分宽高（不包含边框，margin，滚动条等）&#x20; clientWidth和clientHeight rem基准值 flexible.js的源码分析 获取元素的自身宽高获取宽高： 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 获取位置： 获取元素距离自己定位父级元素的左、上距离 offsetLeft和offsetTop 注意是只读属性 获取元素相对于当前视口的宽高element.getBoundingClientRect() 滚动导航栏123456789101112131415161718192021222324&lt;body&gt; &lt;div class=&quot;header&quot;&gt;我是顶部导航栏&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;sk&quot;&gt;秒杀模块&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;backtop&quot;&gt; &lt;img src=&quot;./images/close2.png&quot; alt=&quot;&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; window.addEventListener(&#x27;scroll&#x27;, function () &#123; const n = document.documentElement.scrollTop const sk = document.querySelector(&#x27;.sk&#x27;) const header=document.querySelector(&#x27;.header&#x27;) console.log(n) if (n &gt;= sk.offsetTop) &#123; header.style.top = 0 &#125; else &#123; header.style.top = &#x27;-80px&#x27;//这里一定要加单位 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript DOM操作","path":"/2024/01/16/DOM操作/","content":"DOM（Document Object Model）是将整个 HTML 文档的每一个标签元素视为一个对象，这个对象下包含了许多的属性和方法，通过操作这些属性或者调用这些方法实现对 HTML 的动态更新，为实现网页特效以及用户交互提供技术支撑。 简言之 DOM 是用来动态修改 HTML 的，其目的是开发网页特效及用户交互。 概念DOM 树 DOM 节点节点是文档树的组成部分，每一个节点都是一个 DOM 对象，主要分为元素节点、属性节点、文本节点等。 【元素节点】其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点。 【属性节点】是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性。 【文本节点】是指 HTML 标签的文字内容，如 title 标签中的文字。 【根节点】特指 html 标签。 其它… documentdocument 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，document 是学习 DOM 的核心。 1234567891011&lt;script&gt; // document 是内置的对象 // console.log(typeof document); // 1. 通过 document 获取根节点 console.log(document.documentElement); // 对应 html 标签 // 2. 通过 document 节取 body 节点 console.log(document.body); // 对应 body 标签 // 3. 通过 document.write 方法向网页输出内容 document.write(&#x27;Hello World!&#x27;); &lt;/script&gt; 上述列举了 document 对象的部分属性和方法，我们先对 document 有一个整体的认识 获取dom对象 querySelector 满足条件的第一个元素 querySelectorAll 满足条件的元素集合 返回伪数组 了解其他方式 getElementById getElementsByTagName 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;DOM - 查找节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;查找元素类型节点&lt;/h3&gt; &lt;p&gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const p = document.querySelector(&#x27;p&#x27;) // 获取第一个p元素 const lis = document.querySelectorAll(&#x27;li&#x27;) // 获取第一个p元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结： document.getElementById 专门获取元素类型节点，根据标签的 id 属性查找 任意 DOM 对象都包含 nodeType 属性，用来检检测节点类型 操作元素内容操作元素内容通过修改 DOM 的文本内容，动态改变网页的内容。 innerText 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签不会被解析。1234567&lt;script&gt;// innerText 将文本内容添加/更新到任意标签位置const intro = document.querySelector(&#x27;.intro&#x27;)// intro.innerText = &#x27;嗨~ 我叫李雷！&#x27;// intro.innerText = &#x27;&lt;h4&gt;嗨~ 我叫李雷！&lt;/h4&gt;&#x27;&lt;/script&gt; innerHTML 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签会被解析。12345678&lt;script&gt;// innerHTML 将文本内容添加/更新到任意标签位置const intro = document.querySelector(&#x27;.intro&#x27;)intro.innerHTML = &#x27;嗨~ 我叫韩梅梅！&#x27;intro.innerHTML = &#x27;&lt;h4&gt;嗨~ 我叫韩梅梅！&lt;/h4&gt;&#x27;&lt;/script&gt; 总结：如果文本内容中包含 html 标签时推荐使用 innerHTML，否则建议使用 innerText 属性。 操作元素属性 有3种方式可以实现对属性的修改： 常用属性修改 直接能过属性名修改，最简洁的语法12345678910&lt;script&gt;// 1. 获取 img 对应的 DOM 元素const pic = document.querySelector(&#x27;.pic&#x27;)// 2. 修改属性pic.src = &#x27;./images/lion.webp&#x27;pic.width = 400;pic.alt = &#x27;图片不见了...&#x27;&lt;/script&gt; 控制样式属性 应用【修改样式】，通过修改行内样式 style 属性，实现对样式的动态修改。 通过元素节点获得的 style 属性本身的数据类型也是对象，如 box.style.color、box.style.width 分别用来获取元素节点 CSS 样式的 color 和 width 的值。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.style.color = &#x27;red&#x27; box.style.width = &#x27;300px&#x27; // css 属性的 - 连接符与 JavaScript 的 减运算符 // 冲突，所以要改成驼峰法 box.style.backgroundColor = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 css 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，如 background-color 要写成 box.style.backgroundColor 操作类名(className) 操作CSS 如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt; &lt;style&gt; .pink &#123; background: pink; color: hotpink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.className = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 1.由于class是关键字, 所以使用className去代替 2.className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名 通过 classList 操作类控制CSS 为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 200px; background-color: pink; &#125; .active &#123; width: 300px; height: 300px; background-color: hotpink; margin-left: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;script&gt; // 1.获取元素 // let box = document.querySelector(&#x27;css选择器 let box = document.querySelector(&#x27;div&#x27;) // add是个方法 添加 追加 // box.classList.add(&#x27;active&#x27;) // remove() 移除 类 // box.classList.remove(&#x27;one&#x27;) // 切换类，有就删掉，没有就加上 box.classList.toggle(&#x27;one&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作表单元素属性表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 正常的有属性有取值的跟其他的标签属性没有任何区别 获取:DOM对象.属性名 设置:DOM对象.属性名&#x3D; 新值 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;请输入&quot;&gt; &lt;button disabled&gt;按钮&lt;/button&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;agree&quot;&gt; &lt;script&gt; // 1. 获取元素 let input = document.querySelector(&#x27;input&#x27;) // 2. 取值或者设置值 得到input里面的值可以用 value // console.log(input.value) input.value = &#x27;小米手机&#x27; input.type = &#x27;password&#x27; // 2. 启用按钮 let btn = document.querySelector(&#x27;button&#x27;) // disabled 不可用 = false 这样可以让按钮启用 btn.disabled = false // 3. 勾选复选框 let checkbox = document.querySelector(&#x27;.agree&#x27;) checkbox.checked = false &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 自定义属性标准属性: 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作比如： disabled、checked、selected 自定义属性： 在html5中推出来了专门的data-自定义属性 &#x20; 在标签上一律以data-开头 在DOM对象上一律以dataset对象方式获取 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div data-id=&quot;1&quot;&gt; 自定义属性 &lt;/div&gt; &lt;script&gt; // 1. 获取元素 let div = document.querySelector(&#x27;div&#x27;) // 2. 获取自定义属性值 console.log([div.dataset.id](http://div.dataset.id)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定时器间歇函数知道间歇函数的作用，利用间歇函数创建定时任务。 setInterval 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数。 12345678910&lt;script&gt; // 1. 定义一个普通函数 function repeat() &#123; console.log(&#x27;不知疲倦的执行下去....&#x27;) &#125; // 2. 使用 setInterval 调用 repeat 函数 // 间隔 1000 毫秒，重复调用 repeat setInterval(repeat, 1000) clearInterval(repeat)//关闭定时器&lt;/script&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript对象","path":"/2024/01/16/对象/","content":"遍历对象for 遍历对象的问题： 对象没有像数组一样的length属性,所以无法确定长度 对象里面是无序的键值对, 没有规律. 不像数组里面有规律的下标 forin: 123456789101112131415// 1. 遍历对象 for in let obj = &#123; uname: &#x27;pink老师&#x27;, age: 18, gender: &#x27;男&#x27; &#125; // 2. 遍历对象 for (let k in obj) &#123; console.log(k) // 属性名 &#x27;uname&#x27; &#x27;age&#x27; // console.log(obj.uname) // console.log(obj.k) // console.log(obj.&#x27;uname&#x27;) // console.log(obj[&#x27;uname&#x27;]) &#x27;uname&#x27; === k console.log(obj[k]) // 输出属性值 obj[k] &#125; 内置对象回想一下我们曾经使用过的 console.log，console其实就是 JavaScript 中内置的对象，该对象中存在一个方法叫 log，然后调用 log 这个方法，即 console.log()。 除了 console 对象外，JavaScritp 还有其它的内置的对象 MathMath 是 JavaScript 中内置的对象，称为数学对象，这个对象下即包含了属性，也包含了许多的方法。 属性 Math.PI，获取圆周率 &#x2F;&#x2F; 圆周率 &#x20; console.log(Math.PI); 方法 Math.random，生成 0 到 1 间的随机数 &#x2F;&#x2F; 0 ~ 1 之间的随机数, 包含 0 不包含 1 &#x20; Math.random() Math.ceil，数字向上取整 &#x2F;&#x2F; 舍弃小数部分，整数部分加1 &#x20; Math.ceil(3.4) Math.floor，数字向下取整 &#x2F;&#x2F; 舍弃小数部分，整数部分不变 &#x20; Math.floor(4.68) Math.round，四舍五入取整 &#x2F;&#x2F; 取整，四舍五入原则 &#x20; Math.round(5.46539) &#x20; Math.round(4.849) Math.round(-1.5) -1 Math.max，在一组数中找出最大的 &#x2F;&#x2F; 找出最大值 &#x20; Math.max(10, 21, 7, 24, 13) Math.min，在一组数中找出最小的 &#x2F;&#x2F; 找出最小值 &#x20; Math.min(24, 18, 6, 19, 21) Math.pow，幂方法 &#x2F;&#x2F; 求某个数的多少次方 &#x20; Math.pow(4, 2) &#x2F;&#x2F; 求 4 的 2 次方 &#x20; Math.pow(2, 3) &#x2F;&#x2F; 求 2 的 3 次方 Math.sqrt，平方根 &#x2F;&#x2F; 求某数的平方根 &#x20; Math.sqrt(16) DateECMAScript 中内置了获取系统时间的对象 Date，使用 Date 时与之前学习的内置对象 console 和 Math 不同，它需要借助 new 关键字才能使用。 实例化123456// 1. 实例化// const date = new Date(); // 系统默认时间const date = new Date(&#x27;2020-05-01&#x27;) // 指定时间// date 变量即所谓的时间对象console.log(typeof date) 方法123456// 1. 实例化 const date = new Date(); // 2. 调用时间对象方法 // 通过方法分别获取年、月、日，时、分、秒 const year = date.getFullYear(); // 四位年份 const month = date.getMonth(); // 0 ~ 11 getFullYear 获取四位年份 getMonth 获取月份，取值为 0 ~ 11 getDate 获取月份中的每一天，不同月份取值也不相同 getDay 获取星期，取值为 0 ~ 6 getHours 获取小时，取值为 0 ~ 23 getMinutes 获取分钟，取值为 0 ~ 59 getSeconds 获取秒，取值为 0 ~ 59 时间戳时间戳是指1970年01月01日00时00分00秒起至现在的总秒数或毫秒数，它是一种特殊的计量时间的方式。 注：ECMAScript 中时间戳是以毫秒计的。 12345678 // 1. 实例化 const date = new Date() // 2. 获取时间戳 console.log(date.getTime())// 还有一种获取时间戳的方法 console.log(+new Date()) // 还有一种获取时间戳的方法,这个方法只能获得当前的时间戳 console.log(Date.now()) 获取时间戳的方法，分别为 getTime 和 Date.now 和 +new Date()","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript函数","path":"/2024/01/16/函数/","content":"作用域作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件 处于全局作用域内的变量，称为全局变量 局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。 处于局部作用域内的变量称为局部变量 如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐 但是有一种情况，函数内部的形参可以看做是局部变量。 具名函数声明：function fn() {} 调用：fn() 匿名函数函数可以分为具名函数和匿名函数 匿名函数：没有名字的函数,无法直接使用。可以通过函数表达式和立即执行函数来使用。 函数表达式&#x2F;&#x2F; 声明 &#x20; let fn &#x3D; function() { &#x20; console.log(‘函数表达式’) &#x20; } &#x20; &#x2F;&#x2F; 调用 &#x20; fn() 立即执行函数用于避免全局变量之间的污染 (function(){ xxx })(); &#x20; (function(){xxxx}()); 无需调用，立即执行，其实本质已经调用了 多个立即执行函数之间用分号隔开 逻辑中断短路：只存在于 &amp;&amp; 和 || 中，当满足一定条件会让右边代码不执行 原因：通过左边能得到整个式子的结果，因此没必要再判断右边 运算结果：无论 &amp;&amp; 还是 || ，运算结果都是最后被执行的表达式值，一般用在变量赋值","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript数组","path":"/2024/01/16/数组/","content":"常用api增加元素arr.push push() 方法将指定的元素添加到数组的末尾，并返回新的数组长度。会修改原有数组。 arr.concat([v1,v2]) concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 arr.unshift（v1,v2） unshift() 方法将指定元素添加到数组的开头，并返回数组的新长度。 删除元素arr.splice(start, deleteCount, item1, item2, itemN) splice() 方法通过移除或者替换已存在的元素和&#x2F;或添加新元素就地改变一个数组的内容。 arr.toSpliced() Array 实例的 toSpliced() 方法是 splice() 方法的复制版本。它返回一个新数组，并在给定的索引处删除和&#x2F;或替换了一些元素。 arr.pop() pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。 arr.shift() shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 复制arr.copyWithin(target, start, end) copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。 123456789const array1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];// Copy to index 0 the element at index 3console.log(array1.copyWithin(0, 3, 4));// Expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]// Copy to index 1 all elements from index 3 to the endconsole.log(array1.copyWithin(1, 3));// Expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;] 填充arr.fill(value,start,end) fill() 方法用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组。 反转arr.reverse() reverse() 方法就地反转数组中的元素，并返回同一数组的引用。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。换句话说，数组中的元素顺序将被翻转，变为与之前相反的方向。 arr.toReversed() Array 实例的 toReversed() 方法是 reverse() 方法对应的复制版本。它返回一个元素顺序相反的新数组。 排序arr.sort() sort() 方法就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。 arr.toSorted() Array 实例的 toSorted() 方法是 sort() 方法的复制方法版本。它返回一个新数组，其元素按升序排列。 数组map 方法使用场景： map 可以遍历数组处理数据，并且返回新的数组 语法： 123456789101112&lt;body&gt; &lt;script&gt; const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) &#123; // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + &#x27;颜色&#x27; &#125;)console.log(newArr)&lt;/script&gt;&lt;/body&gt; map 也称为映射。映射是个术语，指两个元素的集之间元素相互“对应”的关系。 map重点在于有返回值，forEach没有返回值（undefined） 数组join方法作用： join() 方法用于把数组中的所有元素转换一个字符串 语法： 1234567891011121314151617181920&lt;body&gt; &lt;script&gt; const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;] // 1. 数组 map方法 处理数据并且 返回一个数组 const newArr = arr.map(function (ele, index) &#123; // console.log(ele) // 数组元素 // console.log(index) // 索引号 return ele + &#x27;颜色&#x27; &#125;) console.log(newArr) // 2. 数组join方法 把数组转换为字符串 // 小括号为空则逗号分割 console.log(newArr.join()) // red颜色,blue颜色,pink颜色 // 小括号是空字符串，则元素之间没有分隔符 console.log(newArr.join(&#x27;&#x27;)) //red颜色blue颜色pink颜色 console.log(newArr.join(&#x27;|&#x27;)) //red颜色|blue颜色|pink颜色 &lt;/script&gt;&lt;/body&gt; forEach遍历数组forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 注意： 1.forEach 主要是遍历数组 2.参数当前数组元素是必须要写的， 索引号可选。 1234567891011&lt;body&gt; &lt;script&gt; // forEach 就是遍历 加强版的for循环 适合于遍历数组对象 const arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;] const result = arr.forEach(function (item, index) &#123; console.log(item) // 数组元素 red green pink console.log(index) // 索引号 &#125;) // console.log(result) &lt;/script&gt;&lt;/body&gt; filter筛选数组filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组 1234567891011121314&lt;body&gt; &lt;script&gt; const arr = [10, 20, 30] // const newArr = arr.filter(function (item, index) &#123; // // console.log(item) // // console.log(index) // return item &gt;= 20 // &#125;) // 返回的符合条件的新数组 const newArr = arr.filter(item =&gt; item &gt;= 20) console.log(newArr) &lt;/script&gt;&lt;/body&gt;","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"Javascript运算","path":"/2024/01/16/运算/","content":"模板字符串document.write(大家好，我叫$&#123;uname&#125;， 我今年贵庚$&#123;age&#125;岁了) 比较运算符如果相等操作符两边的操作数，不包含 null 或者 undefined，且两个操作数不全是对象，在执行相等比较之前，会先调用 Number() 将两个操作数强制转为 Number 类型，然后进行比较。 转换规则：在比较运算符时会优先转换操作数（强制转换），然后再进行比较。 &#x20;第一步：如果有一个操作数类型为布尔值，则在比较相等之前将其转换为数值类型，即 false &#x3D;&gt; 0, true &#x3D;&gt; 1; &#x20;第二步：如果一个操作数是字符串，另一个是数值，在比较前先将字符串转换成数值 &#x20;第三步：在双等号对比时，左右类型相等的情况下，采用三等号的方式进行比较，严格的运算符判定规则 基本数据类型： 如果有一个操作数是（number，string，Boolean），则在比较相等性之前，将其转换为数值; 在比较相等性之前，不能将 null 和 undefined 转成其他值，且null 和 undefined 是相等的。 如果有一个操作数是 NaN，则都返回 false；（NaN不与任何相等，包括NaN） 123456&#x27;55&#x27; == 55; //true （ Number(&#x27;55&#x27;) -&gt; 55 ）&#x27;1.232&#x27;==1.232; //truefalse == 0; //true （ Number(false ) -&gt; 0 ）&quot;wise&quot; == 3; //false （ Number(&quot;wise&quot;) -&gt; NaN ）[] == 0; //true （ Number([]) -&gt; 0 ） 复杂数据类型： 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；&#x20; 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true； 123456NaN == NaN; //false （参考第4条规则）[] == []; //false[] == ![]; //true&#123;&#125; == &#123;&#125;; //false&#123;&#125; == !&#123;&#125;; //false [] &#x3D;&#x3D; [] 和 {} &#x3D;&#x3D; {}在 JavaScript 中，Object、Array、Function、RegExp、Date 都是引用类型。声明引用类型的时候，变量名保存在 js 的栈内存里面，而对应的值保存在堆内存里面。而这个变量在栈内存中实际保存的是：这个值在堆内存中的地址，也就是指针。 12345678var a = &#123;&#125;;var b = &#123;&#125;;var c = b;a == b; //false（变量a,b保存的分别是a,b的指针，它们指向不同的对象）b == c; //true（变量c保存的是b的指针，它们指向同一个对象）注意：如果两个对象指向同一个对象，相等操作符返回 true，否则则为false [] &#x3D;&#x3D; ![] 和 {} &#x3D;&#x3D; !{}逻辑非 (!) 的优先级高于相等操作符 ( &#x3D;&#x3D; ) 1234567891011121314151617181920[] == ![] //![] == false -&gt;Number([]) == Number(false) -&gt; 0 == 0 -&gt; true&#123;&#125; == !&#123;&#125; //!&#123;&#125; == false -&gt; Number(&#123;&#125;) == Number(false) -&gt; NaN == 0 -&gt; false注意：转布尔值==》Boolean() 代表空、否定的值会被转换为 false ，如 &#x27;&#x27;、0、NaN、null、undefined转数字类型：Number(false) // 0;Number(true) // 1;Number(&#x27;&#x27;) // 0;Number(&#x27;12&#x27;) // 12;Number(&#x27;sda&#x27;) // NaN;Number([1,2]) // NaN;Number(&#123;&#125;) // NaN; 转换对象都是NaNNumber(NaN) // NaN;Number(!NaN) // 1;Number(null) // 0;Number(!null) // 1;Number(!undefined) // 1;Number(undefined) // NaN; 数组与数值数组会先通过调用toString()转换为字符串后再转换为数值，比如[true]转换为字符串后为”true”，然后再转换为数值是NaN，所以[true]&#x3D;&#x3D;1返回false。 12345678console.log([]==0); // trueconsole.log([1]==1); // trueconsole.log([&quot;1&quot;]==1); // trueconsole.log([1,2]==1); // falseconsole.log([true]==1); // falseNumber([&#x27;a&#x27;]) // NaN;[&#x27;1&#x27;] == 1 // true; null &#x3D;&#x3D; 0 、null &gt;&#x3D; 0 、null &gt; 01.关系运算符知 和 相等运算符 并不是一个类别的.2.关系运算符，在设计上总是需要运算元道尝试转为一个number，而相等运算符在设计上，则没有这方面的考虑. 12345678910null==0 //false//解释：null在设计上，对比等于的时候不尝试转型. null和0不转型的话，是不会相等的, 所以null == 0结果为false.（在JavaScript旧版源代码中，没有相匹配的项，最后返回末尾的false。）null &gt; 0 // false// 对比大于或小于的时候, null 会尝试转型为number , 转化之后null为0, 0&gt;0是错误的,所以结果为 false.null&gt;=0 // truenull&lt;=0 // true//对比 大于等于 或 小于等于 的时候, 会先判断大于或小于,转型为number,0&gt;0是错误的,但是0=0是正确的, 这是 “或” 的判断, 所以结果为 true 特殊情况： NAN&#x3D;&#x3D;&#x3D;NAN（false） 0.1+0.2&#x3D;&#x3D;&#x3D;0.3（false）js的小数加法存在精度问题 null&#x3D;&#x3D;undefined(true) null&#x3D;&#x3D;&#x3D;undefined(false) []&#x3D;&#x3D;[](false) []&#x3D;&#x3D;&#x3D;[] (false) undefined进行比较时，是作为对象，转化为NaN来处理。","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"BFC","path":"/2024/01/16/9.BFC/","content":"9.1 BFC的定义W3C 上对 BFC 的定义： 译文：浮动、绝对定位元素、不是块盒子的块容器（如 inline-blocks 、 table-cells 和table-captions ），以及 overflow 属性的值除 visible 以外的块盒，将为其内容建立新的块格式化上下文。 MDN 上对 BFC 的描述： 块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 更加通俗的描述： BFC 是 Block Formatting Context （块级格式上下文），可以理解成元素的一个“特异功能”。 &#x20;该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活。 所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）。 9.2 开启了BFC能解决什么问题 元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题。 元素开启 BFC 后，自己不会被其他浮动元素所覆盖。 元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷。 9.3 如何开启BFC 根元素 浮动元素 绝对定位、固定定位的元素 行内块元素 表格单元格： table 、 thead 、 tbody 、 tfoot 、 th 、 td 、 tr 、 caption overflow 的值不为 visible 的块元素 伸缩项目 多列容器 column-span 为 all 的元素（即使该元素没有包裹在多列容器中） display 的值，设置为 flow-root 例子1：解决margin塌陷问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_BFC_演示1&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; /* display: flex; */ &#125; .outer &#123; width: 400px; background-color: #888; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ /* display: flow-root; */ &#125; .inner &#123; width: 100px; height: 100px; margin: 20px; &#125; .inner1 &#123; background-color: orange; &#125; .inner2 &#123; background-color: green; &#125; .inner3 &#123; background-color: deepskyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;hr style=&quot;height: 50px; background-color: red;&quot;&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 例子2：解决float元素遮挡问题 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_BFC_演示2&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; &#125; .box1 &#123; background-color: orange; float: left; &#125; .box2 &#123; background-color: green; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ /* display: flow-root; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 例子3：解决子元素浮动，父元素高度塌陷问题 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_BFC_演示3&lt;/title&gt; &lt;style&gt; .outer &#123; width: 400px; background-color: #888; /* float: left; */ /* position: absolute; */ /* display: inline-block; */ /* display: table; */ /* overflow: auto; */ /* column-count: 1; */ display: flow-root; &#125; .inner &#123; width: 100px; height: 100px; float: left; &#125; .inner1 &#123; background-color: orange; &#125; .inner2 &#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner inner1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner inner2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"响应式布局","path":"/2024/01/16/8.响应式布局/","content":"8.1 媒体查询1.媒体类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_媒体查询_媒体类型&lt;/title&gt; &lt;style&gt; h1 &#123; width: 600px; height: 400px; line-height: 400px; background-image: linear-gradient(30deg,red,yellow,green); margin: 0 auto; text-align: center; font-size: 100px; color: white; text-shadow: 0 0 10px black; &#125; /* 只有在打印机或打印预览才应用的样式 */ @media print &#123; h1 &#123; background: transparent; &#125; &#125; /* 只有在屏幕上才应用的样式 */ @media screen &#123; h1 &#123; font-family: &quot;翩翩体-简&quot;; &#125; &#125; /* 一直都应用的样式 */ @media all &#123; h1 &#123; color: red; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;新年快乐&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.媒体特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_媒体查询_媒体特性&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; h1 &#123; height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; &#125; /* 检测到视口的宽度为800px时，应用如下样式 */ @media (width:800px) &#123; h1 &#123; background-color: green; &#125; &#125; /* 检测到视口的宽度小于等于700px时，应用如下样式 */ @media (max-width:700px) &#123; h1 &#123; background-color: orange; &#125; &#125; /* 检测到视口的宽度大于等于900px时，应用如下样式 */ @media (min-width:900px) &#123; h1 &#123; background-color: deepskyblue; &#125; &#125; /* 检测到视口的高度等于800px时，应用如下样式 */ /* @media (height:800px)&#123; h1 &#123; background-color: yellow; &#125; &#125; */ /* 检测到屏幕的宽度等于1536px时，应用如下样式 */ /* @media (device-width:1536px) &#123; h1 &#123; color: white; &#125; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好啊&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3.运算符 only为了处理ie的兼容性问题。让ie直接不认识。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_媒体查询_运算符&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; h1 &#123; height: 200px; background-color: gray; text-align: center; line-height: 200px; font-size: 100px; &#125; /* 且运算符 */ /* @media (min-width:700px) and (max-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* @media screen and (min-width:700px) and (max-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 或运算符 */ /* @media screen and (max-width:700px) or (min-width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 否定运算符 */ /* @media not screen &#123; h1 &#123; background-color: orange; &#125; &#125; */ /* 肯定运算符 */ @media only screen and (width:800px) &#123; h1 &#123; background-color: orange; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好啊&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 4.常用阈值 5.结合外部样式的写法用法一： 1&lt;link rel=&quot;stylesheet&quot; media=&quot;具体的媒体查询&quot; href=&quot;mystylesheet.css&quot;&gt; 用法二： 123@media screen and (max-width:768px) &#123;/CSS-Code;/&#125;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"伸缩盒模型","path":"/2024/01/16/7.伸缩盒模型/","content":"传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float属性。 flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上 1.伸缩容器、伸缩项目 伸缩容器： 开启了 flex 的元素，就是：伸缩容器。 给元素设置： display:flex 或 display:inline-flex ，该元素就变为了伸缩容器。 display:inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器。 一个元素可以同时是：伸缩容器、伸缩项目。 伸缩项目：伸缩容器所有子元素自动成为了：伸缩项目。 仅伸缩容器的子元素成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目。 无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”。 2.主轴与侧轴主轴： 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）。 侧轴： 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）。 3.主轴方向属性名： flex-direction 常用值如下： row ：主轴方向水平从左到右 —— 默认值 row-reverse ：主轴方向水平从右到左。 column ：主轴方向垂直从上到下。 column-reverse ：主轴方向垂直从下到上 注意：改变了主轴的方向，侧轴方向也随之改变。 4.主轴换行方式属性名： flex-wrap 常用值如下： nowrap ：默认值，不换行。 wrap ：自动换行，伸缩容器不够自动换行。 wrap-reverse ：反向换行。 5.flex-flowflex-flow 是一个复合属性，复合了 flex-direction 和 flex-wrap 两个属性。 值没有顺序要求。 flex-flow: row wrap; 6.主轴对齐方式属性名： justify-content 常用值如下： flex-start ：主轴起点对齐。—— 默认值 flex-end ：主轴终点对齐。 center ：居中对齐 space-between ：均匀分布，两端对齐（最常用）。 space-around ：均匀分布，两端距离是中间距离的一半。 space-evenly ：均匀分布，两端距离与中间距离一致。 7.侧轴对齐方式7.1 一行的情况所需属性： align-items 常用值如下： flex-start ：侧轴的起点对齐。 flex-end ：侧轴的终点对齐。 center ：侧轴的中点对齐。 baseline : 伸缩项目的第一行文字的基线对齐。 stretch ：如果伸缩项目未设置高度，将占满整个容器的高度。—— （默认值） 7.2 多行的情况所需属性： align-content 常用值如下： flex-start ：与侧轴的起点对齐。 flex-end ：与侧轴的终点对齐。 center ：与侧轴的中点对齐。 space-between ：与侧轴两端对齐，中间平均分布。 space-around ：伸缩项目间的距离相等，比距边缘大一倍。 space-evenly : 在侧轴上完全平分。 stretch ：占满整个侧轴。—— 默认值 flex-start 8.伸缩性8.1 flex-basis 概念： flex-basis 设置的是主轴方向的基准长度，会让宽度或高度失效。 备注：主轴横向：宽度失效；主轴纵向：高度失效 作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值 auto ，即：伸缩项目的宽或高。 8.2 flex-grow（伸） 概念： flex-grow 定义伸缩项目的放大比例，默认为 0 ，即：纵使主轴存在剩余空间，也不拉伸（放大）。 规则： 若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）。 若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1&#x2F;6 、 2&#x2F;6 、3&#x2F;6 的空间。 8.3 flex-shrink（缩） 概念： flex-shrink 定义了项目的压缩比例，默认为 1 ，即：如果空间不足，该项目将会缩小。 收缩项目的计算，略微复杂一点，我们拿一个场景举例： 例如： 三个收缩项目，宽度分别为： 200px 、 300px 、 200px ，它们的 flex-shrink 值分别 为： 1 、 2 、 3 若想刚好容纳下三个项目，需要总宽度为 700px ，但目前容器只有 400px ，还差300px 所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算： 计算分母： (200×1) + (300×2) + (200×3) &#x3D; 1400 计算比例： 项目一： (200×1) &#x2F; 1400 &#x3D; 比例值1 项目二： (300×2) &#x2F; 1400 &#x3D; 比例值2 计算最终收缩大小： 项目一需要收缩： 比例值1 × 300 项目二需要收缩： 比例值2 × 300 项目三需要收缩： 比例值3 × 300 9. flex复合属性flex 是复合属性，复合了： flex-grow 、 flex-shrink 、 flex-basis 三个属性，默认值为 0 1 auto 。 如果写 flex:1 1 auto ，则可简写为： flex:auto 如果写 flex:1 1 0 ，则可简写为： flex:1 如果写 flex:0 0 auto ，则可简写为： flex:none 如果写 flex:0 1 auto ，则可简写为： flex:0 auto —— 即 flex 初始值。 10. 项目排序order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 。 11. 单独对齐通过 align-self 属性，可以单独调整某个伸缩项目的对齐方式 默认值为 auto ，表示继承父元素的 align-items 属性。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"多列布局","path":"/2024/01/16/6.多列布局/","content":"作用：专门用于实现类似于报纸的布局。 常用属性如下： column-count ：指定列数，值是数字。 column-width ：指定列宽，值是长度。 columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求。 column-gap ：设置列边距，值是长度。 column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致。 column-rule-width ：设置列与列之间边框的宽度，值是长度。 column-rule-color ：设置列与列之间边框的颜色。 coumn-rule ：设置列边框，复合属性。 column-span 指定是否跨列；值: none 、 all 。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"动画","path":"/2024/01/16/5.动画/","content":"5.1 基本使用第一步：定义关键帧（定义动画） 简单方式定义： 12345678910/*写法一*/@keyframes 动画名 &#123;from &#123;/*property1:value1*//*property2:value2*/&#125;to &#123;/*property1:value1*/&#125;&#125; 完整方式定义： 1234567891011121314151617181920@keyframes 动画名 &#123;0% &#123;/*property1:value1*/&#125;20% &#123;/*property1:value1*/&#125;40% &#123;/*property1:value1*/&#125;60% &#123;/*property1:value1*/&#125;80% &#123;/*property1:value1*/&#125;100% &#123;/*property1:value1*/&#125;&#125; 第二步：给元素应用动画，用到的属性如下： animation-name ：给元素指定具体的动画（具体的关键帧） animation-duration ：设置动画所需时间 animation-delay ：设置动画延迟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_基本使用&lt;/title&gt; &lt;style&gt; .outer &#123; width: 1000px; height: 100px; border: 1px solid black; &#125; /* 定义一个动画（定义一组关键帧）—— 第一种方式 */ @keyframes wangyoudong &#123; /* 第一帧 */ from &#123; &#125; /* 最后一帧 */ to &#123; transform: translate(900px); background-color: red; &#125; &#125; /* 定义一个动画（定义一组关键帧）—— 第二种方式 */ @keyframes wangyoudong2 &#123; /* 第一帧 */ 0% &#123; &#125; /* 29% &#123; background-color: red; &#125; */ /* 48% &#123; background-color: orange; &#125; */ /* 88% &#123; background-color: yellow; &#125; */ /* 最后一帧 */ 100% &#123; transform: translate(900px) rotate(360deg); background-color: purple; border-radius: 50%; &#125; &#125; .inner &#123; width: 100px; height: 100px; background-color: deepskyblue; /* 应用动画到元素 */ animation-name: wangyoudong2; /* 动画持续的时间 */ animation-duration: 3s; /* 动画延迟时间 */ animation-delay: 0.2s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.2 动画的其他属性 animation-timing-function ，设置动画的类型，常用值如下： ease ： 平滑动画 —— 默认值 linear ： 线性过渡 ease-in ： 慢 → 快 ease-out ： 快 → 慢 ease-in-out ： 慢 → 快 → 慢 step-start ： 等同于 steps(1, start) step-end ： 等同于 steps(1, end) steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。 cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。 animation-iteration-count ，指定动画的播放次数，常用值如下： number ：动画循环次数 infinite ： 无限循环 animation-direction ，指定动画方向，常用值如下： normal ： 正常方向 (默认) reverse ： 反方向运行 alternate ： 动画先正常运行再反方向运行，并持续交替运行 alternate-reverse ： 动画先反运行再正方向运行，并持续交替运行 animation-fill-mode ，设置动画之外的状态 forwards ： 设置对象状态为动画结束时的状态 backwards ： 设置对象状态为动画开始时的状态 animation-play-state ，设置动画的播放状态，常用值如下： running ： 运动 (默认) paused ： 暂停 5.3动画复合属性只设置一个时间表示 duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求。 备注： animation-play-state 一般单独使用。 123.inner &#123;animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards;&#125;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"过渡","path":"/2024/01/16/4.过渡/","content":"4.1. transition-property作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会以有过渡 效果。 常用值： none ：不过渡任何属性。 all ：过渡所有能过渡的属性。 具体某个属性名 ，例如： width 、 heigth ，若有多个以逗号分隔。 不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。 常见的支持过渡的属性有：颜色、长度值、百分比、 z-index 、 opacity 、 2D 变换属性、 3D 变换属性、阴影。 4.2. transition-duration作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久。 常用值： 0 ：没有任何过渡时间 —— 默认值。 s 或 ms ：秒或毫秒。 列表 ： 如果想让所有属性都持续一个时间，那就写一个值。 如果想让每个属性持续不同的时间那就写一个时间的列表。 4.3. transition-delay作用：指定开始过渡的延迟时间，单位： s 或 ms 4.4. transition-timing-function作用：设置过渡的类型 常用值： ease ： 平滑过渡 —— 默认值 linear ： 线性过渡 ease-in ： 慢 → 快 ease-out ： 快 → 慢 ease-in-out ： 慢 → 快 → 慢 step-start ： 等同于 steps(1, start) step-end ： 等同于 steps(1, end) steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。 cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。 在线制作贝赛尔曲线：https://cubic-bezier.com 4.5. transition 复合属性如果设置了一个时间，表示 duration ；如果设置了两个时间，第一是 duration ，第二个是delay ；其他值没有顺序要求。 1transition:1s 1s linear all; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_过渡案例&lt;/title&gt; &lt;style&gt; .outer &#123; width: 400px; height: 224px; position: relative; overflow: hidden; &#125; .mask &#123; width: 400px; height: 224px; background-color: black; color: white; position: absolute; top: 0; left: 0; text-align: center; line-height: 224px; font-size: 100px; opacity: 0; transition: 1s linear; cursor: pointer; &#125; img &#123; transition: 0.5s linear; &#125; .outer:hover .mask &#123; opacity: 0.5; &#125; .outer:hover img &#123; transform: scale(1.6) rotate(20deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;img src=&quot;../images/shanghai.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mask&quot;&gt;上海&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot;&gt; &lt;img src=&quot;../images/shanghai.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mask&quot;&gt;上海&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"变换","path":"/2024/01/16/3.变换/","content":"3.1 2D变换3.1.1 2D位移2D 位移可以改变元素的位置，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注意点： 位移与相对定位很相似，都不脱离文档流，不会影响到其它元素。 与相对定位的区别：相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是其自身。 浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高。 transform 可以链式编写，如：transform: translateX(30px) translateY(40px); 位移对行内元素无效。 位移配合定位，可实现元素水平垂直居中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_位移&lt;/title&gt; &lt;style&gt; .outer &#123; width: 200px; height: 200px; border: 2px solid black; margin: 0 auto; margin-top: 100px; position: relative; &#125; .inner &#123; width: 200px; height: 200px; background-color: deepskyblue; /* 水平位移 */ /* transform: translateX(50px); */ /* 垂直位移 */ /* transform: translateY(50px); */ /* 水平+垂直位移 */ /* transform: translate(50px,50px); */ &#125; .inner2 &#123; width: 60px; height: 60px; background-color: orange; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;你好啊&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner2&quot;&gt;你好啊&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.1.2 2D缩放2D 缩放是指：让元素放大或缩小，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注：借助缩放，可实现小于 12px 的文字。 3.1.3 2D旋转2D 旋转是指：让元素在二维平面内，顺时针旋转或逆时针旋转，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 注意： rotateZ(20deg) 相当于 rotate(20deg) ， 在平面上实现旋转应用rotateZ 3.1.4 2D扭曲2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可，具体使用方式如下： 先给元素添加 转换属性 transform 编写transform的具体值 3.1.5 多重变换多个变换，可以同时使用一个 transform 来编写。 transform: translate(-50%, -50%) rotate(45deg); 一般都要把旋转放在最后来写，因为旋转后轴的方向会发生变化。 3.1.5 变换原点 元素变换时，默认的原点是元素的中心，使用 transform-origin 可以设置变换的原点。 修改变换原点对位移没有影响， 对旋转和缩放会产生影响。 如果提供两个值，第一个用于横坐标，第二个用于纵坐标。 如果只提供一个，若是像素值，表示横坐标，纵坐标取 50% ；若是关键词，则另一个坐标取 50% 注： transform-origin: 50% 50% ， 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值 transform-origin: left top ，变换原点在元素的左上角 。 transform-origin: 50px 50px ， 变换原点距离元素左上角 50px 50px 的位置。 transform-origin: 0 ，只写一个值的时候，第二个值默认为 50% 。 3.2 3D变换3.2.1 开启3D空间重要原则：元素进行 3D 变换的首要操作：父元素必须开启 3D 空间！ 使用 transform-style 开启 3D 空间，可选值如下： flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值 preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间） 3.2.2 设置景深何为景深？—— 指定观察者与 z&#x3D;0 平面的距离，能让发生 3D 变换的元素，产生透视效果，看来更加立体。 使用 perspective 设置景深，可选值如下： none ： 不指定透视 ——（默认值） 长度值 ： 指定观察者距离 z&#x3D;0 平面的距离，不允许负值。 注意： perspective 设置给发生 3D 变换元素的父元素！ 3.2.3 透视点位置实质上是camera位置。 所谓透视点位置，就是观察者位置；默认的透视点在元素的中心。 使用 perspective-origin 设置观察者位置（透视点的位置），例如： 注意：通常情况下，我们不需要调整透视点位置。 3.2.4 3D 位移3D 位移是在 2D 位移的基础上，可以让元素沿 z 轴位移，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.5 3D 旋转3D 旋转是在 2D 旋转的基础上，可以让元素沿 x 轴和 y 轴旋转，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.6 3D缩放3D 缩放是在 2D 缩放的基础上，可以让元素沿 z 轴缩放，但html元素没有厚度，所以会在景深上做调整，具体使用方式如下： 先给元素添加 转换属性 transform 编写 transform 的具体值， 3D 相关可选值如下： 3.2.7 多重变换多个变换，可以同时使用一个 transform 来编写。 transform: translateZ(100px) scaleZ(3) rotateY(40deg); 注意点：多重变换时，建议最后旋转。 3.2.8 背部可见性使用 backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下： visible ： 指定元素背面可见，允许显示正面的镜像。—— 默认值 hidden ： 指定元素背面不可见 注意： backface-visibility 需要加在发生 3D 变换元素的自身上。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"CSS3新增内容","path":"/2024/01/16/新增内容/","content":"2.1 新增长度单位 rem 根元素字体大小的倍数，只与根元素字体大小有关。 vw 视口宽度的百分之多少 10vw 就是视口宽度的 10% 。 vh 视口高度的百分之多少 10vh 就是视口高度的 10% 。 vmax 视口宽高中大的那个的百分之多少。（了解即可） vmin 视口宽高中小的那个的百分之多少。（了解即可） 2.2 新增选择器CSS3 新增的选择器有：动态伪类、目标伪类、语言伪类、 UI 伪类、结构伪类、否定伪类、伪元素 2.3 新增盒模型相关属性2.3.1 BOX-SIZING怪异盒模型 2.3.2 resize调整盒子大小使用时要加上overflow，值任意。 2.4.2 box-shadow盒子阴影使用 box-shadow 属性为盒子添加阴影。 语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 2.4.3 opacityopacity 属性能为整个元素添加透明效果， 值是 0 到 1 之间的小数， 0 是完全透明， 1 表示完 全不透明。 opacity 与 rgba 的区别在于 opacity 是一个属性，设置的是整个元素（包括元素里的内容）的不透明度。 rgba 是颜色的设置方式，用于设置颜色，它的透明度，仅仅是调整颜色的透明度 3.新增背景属性3.1 background-origin作用：设置背景图的原点。 语法 padding-box ：从 padding 区域开始显示背景图像。—— 默认值 border-box ： 从 border 区域开始显示背景图像。 content-box ： 从 content 区域开始显示背景图像。 3.2 background-clip作用：设置背景图的向外裁剪的区域。 语法 border-box ： 从 border 区域开始向外裁剪背景。 —— 默认值 padding-box ： 从 padding 区域开始向外裁剪背景。 content-box ： 从 content 区域开始向外裁剪背景。 text ：背景图只呈现在文字上。 注意：若值为 text ，那么 backgroun-clip 要加上 -webkit- 前缀。 3.3 background-size作用：设置背景图的尺寸。 语法： 用长度值指定背景图片大小，不允许负值。 用百分比指定背景图片大小，不允许负值。 auto ： 背景图片的真实大小。 —— 默认值 contain ： 将背景图片等比缩放，使背景图片的宽或高，与容器的宽或高相等，再将完整 背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片。 cover ：将背景图片等比缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要 注意：背景图片有可能显示不完整。—— 相对比较好的选择 3.4. backgorund 复合属性语法： 注意： origin 和 clip 的值如果一样，如果只写一个值，则 origin 和 clip 都设置；如 果设置了两个值，前面的是 origin ，后面的 clip 。 size 的值必须写在 position 值的后面，并且用 &#x2F; 分开。 3.5 多背景图CSS3 允许元素设置多个背景图片 12345/* 添加多个背景图 */background: url(../images/bg-lt.png) no-repeat,url(../images/bg-rt.png) no-repeat right top,url(../images/bg-lb.png) no-repeat left bottom,url(../images/bg-rb.png) no-repeat right bottom; 4. 新增边框属性4.1 边框圆角在 CSS3 中，使用 border-radius 属性可以将盒子变为圆角。 border-radius:10px; border-raidus: 左上角x 右上角x 右下角x 左下角x &#x2F; 左上y 右上y 右下y 左下y 4.2 边框外轮廓outline-width ：外轮廓的宽度。 outline-color ：外轮廓的颜色。 outline-style ：外轮廓的风格。 none ： 无轮廓 dotted ： 点状轮廓 dashed ： 虚线轮廓 solid ： 实线轮廓 double ： 双线轮廓 outline-offset 设置外轮廓与边框的距离，正负值都可以设置。 注意： outline-offset 不是 outline 的子属性，是一个独立的属性。 outline 复合属性 1outline:50px solid blue; 5.新增文本属性5.1文本阴影语法： 默认值： text-shadow:none 表示没有阴影。 5.2 文本换行在 CSS3 中，我们可以使用 white-space 属性设置文本换行方式。 5.3 文本溢出在 CSS3 中，我们可以使用 text-overflow 属性设置文本内容溢出时的呈现模式。 注意：要使得 text-overflow 属性生效，块容器必须显式定义 overflow 为非 visible 值， white-space 为 nowrap 值。 5.4 文本修饰CSS3 升级了 text-decoration 属性，让其变成了复合属性。 子属性及其含义： text-decoration-line 设置文本装饰线的位置 none ： 指定文字无装饰 （默认值） underline ： 指定文字的装饰是下划线 overline ： 指定文字的装饰是上划线 line-through ： 指定文字的装饰是贯穿线 text-decoration-style 文本装饰线条的形状 solid ： 实线 （默认） double ： 双线 dotted ： 点状线条 dashed ： 虚线 wavy ： 波浪线 text-decoration-color 文本装饰线条的颜色 5.5 文本描边注意：文字描边功能仅 webkit 内核浏览器支持。 -webkit-text-stroke-width ：设置文字描边的宽度，写长度值。 -webkit-text-stroke-color ：设置文字描边的颜色，写颜色值。 -webkit-text-stroke ：复合属性，设置文字描边宽度和颜色。 6.新增渐变6.1 线性渐变多个颜色之间的渐变， 默认从上到下渐变。 使用关键词设置线性渐变的方向。 使用角度设置线性渐变的方向。 调整开始渐变的位置 12345background-image: linear-gradient(to top,red,yellow,green);background-image: linear-gradient(to right top,red,yellow,green);background-image: linear-gradient(30deg,red,yellow,green);background-image: linear-gradient(red 50px,yellow 100px ,green 150px); 6.2 径向渐变多个颜色之间的渐变， 默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比） 使用关键词调整渐变圆的圆心位置 使用像素值调整渐变圆的圆心位置。 调整渐变形状为正圆 调整形状的半径 。 调整开始渐变的位置。 1234567background-image: radial-gradient(at right top,red,yellow,green);/*使用关键词调整渐变圆的圆心位置*/background-image: radial-gradient(at 100px 50px,red,yellow,green); /*使用像素值调整渐变圆的圆心位置*/background-image: radial-gradient(circle,red,yellow,green);/*调整渐变形状为正圆*/background-image: radial-gradient(100px,red,yellow,green);/*调整形状的半径*/background-image: radial-gradient(50px 100px,red,yellow,green);background-image: radial-gradient(red 50px,yellow 100px,green 150px)；/*调整开始渐变的位置*/ 6.3 重复渐变无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变。 使用 repeating-linear-gradient 进行重复线性渐变，具体参数同 linear-gradient 。 使用 repeating-radial-gradient 进行重复径向渐变，具体参数同 radial-gradient 。 7.web字体7.1基本用法12345678910111213141516@font-face &#123; font-family: &quot;atguigu&quot;; font-display: swap; src: url(&#x27;webfont.eot&#x27;); /* IE9 */ src: url(&#x27;webfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;webfont.woff2&#x27;) format(&#x27;woff2&#x27;), url(&#x27;webfont.woff&#x27;) format(&#x27;woff&#x27;), /* chrome、firefox */ url(&#x27;webfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* chrome、firefox、opera、Safari, Android*/ url(&#x27;webfont.svg#webfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */&#125;@font-face &#123; font-family: &quot;情书字体&quot;; src: url(&#x27;./方正手迹.ttf&#x27;);&#125; 7.2 字体图标相比图片更加清晰。 灵活性高，更方便改变大小、颜色、风格等。 兼容性好， IE 也能支持。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"CSS3概述","path":"/2024/01/16/1.简介/","content":"1.1 CSS3 的新特性新增了更加实用的选择器，例如：动态伪类选择器、目标伪类选择器、伪元素选择器等等。 新增了更好的视觉效果，例如：圆角、阴影、渐变等。 新增了丰富的背景效果，例如：支持多个背景图片，同时新增了若干个背景相关的属性。 新增了全新的布局方案 —— 弹性盒子。 新增了 Web 字体，可以显示用户电脑上没有安装的字体。 增强了颜色，例如： HSL 、 HSLA 、 RGBA 几种新的颜色模式，新增 opacity 属性来控制 透明度。 增加了 2D 和 3D 变换，例如：旋转、扭曲、缩放、位移等。 增加动画与过渡效果，让效果的变换更具流线性、平滑性。 1.2 CSS3的私有前缀1.2.1 什么是私有前缀如下代码中的 -webkit- 就是私有前缀 12345div &#123; width:400px; height:400px; -webkit-border-radius: 20px;&#125; 1.2.2 为什么要有私有前缀W3C 标准所提出的某个 CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核， 使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了。 举个例子： 12345-webkit-border-radius: 20px;-moz-border-radius: 20px;-ms-border-radius: 20px;-o-border-radius: 20px;border-radius: 20px; 查询 CSS3 兼容性的网站：https://caniuse.com/ 1.2.3 常见浏览器私有前缀Chrome 浏览器： -webkit- Safari 浏览器： -webkit- Firefox 浏览器： -moz- Edge 浏览器： -webkit- 旧 Opera 浏览器： -o- 旧 IE 浏览器： -ms- 注意： 我们在编码时，不用过于关注浏览器私有前缀，不用绞尽脑汁的去记忆，也不用每个都去查询，因 为常用的 CSS3 新特性，主流浏览器都是支持的，即便是为了老浏览器而加前缀，我们也可以借助 现代的构建工具，去帮我们添加私有前缀。","tags":["CSS","前端","CSS3"],"categories":["CSS"]},{"title":"浮动","path":"/2024/01/16/浮动/","content":"1.浮动在最初，浮动是用来实现文字环绕图片效果的，现在浮动是主流的页面布局方式之一。 浮动后的特点： 🤢脱离文档流。 😊不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高。 😊不会独占一行，可以与其他元素共用一行。 😊不会 margin 合并，也不会 margin 塌陷，能够完美的设置四个方向的 margin和padding。 😊不会像行内块一样被当做文本处理（没有行内块的空白问题）。 2.浮动产生的影响2.1 元素浮动后会有哪些影响对兄弟元素的影响：如果父元素没有高度，会产生高度塌陷， 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。 对父元素的影响： 不能撑起父元素的高度，导致 父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。 2.2 解决浮动产生的影响（清除浮动）解决方案： 方案一： 给父元素指定高度。 方案二： 给父元素也设置浮动，带来其他影响。 方案三： 给父元素设置 overflow:hidden 。 前三种可以解决父元素高度塌陷的问题，但不能解决兄弟元素被覆盖的问题。 4.方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both 。 意思是清除前面所有兄弟的浮动产生的影响，前提是这个元素不浮动并且不是行内元素。 5.方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推荐使用 但是使用时前面的兄弟元素必须全为浮动元素。 12345.parent::after &#123; content: &quot;&quot;; display: block; clear:both;&#125; 布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"定位","path":"/2024/01/16/定位/","content":"1.相对定位1、 如何设置相对定位？给元素设置 position:relative 即可实现相对定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、 相对定位的参考点在哪里？相对自己原来的位置 3、相对定位的特点： 不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 默认规则是： 定位的元素会盖在普通元素之上。都发生定位的两个元素，后写的元素会盖在先写的元素之上。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 相对定位的元素，也能继续浮动，但不推荐这样做。 相对行为的元素，也能通过 margin 调整位置，但不推荐这样做。 注意：绝大多数情况下，相对定位，会与绝对定位配合使用。 4.使用场景 1.对位置微调 2.配合绝对定位适用 2.绝对定位1、 如何设置绝对定位？给元素设置 position: absolute 即可实现绝对定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、绝对定位的参考点在哪里？参考它的包含块。 什么是包含块？ 对于没有脱离文档流的元素：包含块就是父元素； 对于脱离文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都没定位，那包含块就是整个页面）。 3、 绝对定位元素的特点： 脱离文档流，会对后面的兄弟元素、父元素有影响。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 绝对定位、浮动不能同时设置，如果同时设置，浮动失效，以定位为主。 绝对定位的元素，也能通过 margin 调整位置，但不推荐这样做。 无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了定位元素。 何为定位元素？ —— 默认宽、高都被内容所撑开，且能自由设置宽高。 3.固定定位1、 如何设置为固定定位？给元素设置 position: fixed 即可实现固定定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。 2、定定位的参考点在哪里？参考它的视口 什么是视口？—— 对于 PC 浏览器来说，视口就是我们看网页的那扇“窗户”。 3、 固定定位元素的特点 脱离文档流，会对后面的兄弟元素、父元素有影响。 left 不能和 right 一起设置， top 和 bottom 不能一起设置。 固定定位和浮动不能同时设置，如果同时设置，浮动失效，以固定定位为主。 固定定位的元素，也能通过 margin 调整位置，但不推荐这样做。 无论是什么元素（行内、行内块、块级）设置为固定定位之后，都变成了定位元素 4.粘性定位1、如何设置为粘性定位？给元素设置 position:sticky 即可实现粘性定位。 可以使用 left 、 right 、 top 、 bottom 四个属性调整位置，不过最常用的是 top 值。 2、粘性定位的参考点在哪里？离它最近的一个拥有“滚动机制”的祖先元素，即便这个祖先不是最近的真实可滚动祖先。 3、粘性定位元素的特点不会脱离文档流，它是一种专门用于窗口滚动时的新的定位方式。 最常用的值是 top 值。 粘性定位和浮动可以同时设置，但不推荐这样做。 粘性定位的元素，也能通过 margin 调整位置，但不推荐这样做。 粘性定位和相对定位的特点基本一致，不同的是：粘性定位可以在元素到达某个位置时将其固定。 5.定位层级 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 如果位置发生重叠，默认情况是：后面的元素，会显示在前面元素之上。 可以通过 css 属性 z-index 调整元素的显示层级。 z-index 的属性值是数字，没有单位，值越大显示层级越高。 只有定位的元素设置 z-index 才有效。 如果 z-index 值大的元素，依然没有覆盖掉 z-index 值小的元素，那么请检查其包含块的层级。 6.定位的特殊应用定位可以越过父元素的padding注意： 发生固定定位、绝对定位后，元素都变成了定位元素，默认宽高被内容撑开，且依然可以设置宽高。 发生相对定位后，元素依然是之前的显示模式。 以下所说的特殊应用，只针对 绝对定位 和 固定定位 的元素，不包括相对定位的元素 1、让定位元素的宽充满包含块定位元素可以没有宽高。 块宽想与包含块一致，可以给定位元素同时设置 left 和 right 为 0 。 高度想与包含块一致， top 和 bottom 设置为 0 。 2、让定位元素在包含块中居中这种情况需要子元素有宽和高。 12345left:0;right:0;top:0;bottom:0;margin:auto; 或者 1234left: 50%;top: 50%;margin-left: 负的宽度一半;margin-top: 负的高度一半;","tags":["CSS","前端"],"categories":["CSS"]},{"title":"重置默认样式","path":"/2024/01/16/布局/","content":"重置默认样式 很多元素都有默认样式，比如： p 元素有默认的上下 margin 。 h1~h6 标题也有上下 margin ，且字体加粗。 body 元素有默认的 8px 外边距。 超链接有默认的文字颜色和下划线。 ul 元素有默认的左 pading 。 方案一：使用全局选择器此种方法，在简单案例中可以用一下，但实际开发中不会使用，因为 * 选择的是所有元素，而并 不是所有的元素都有默认样式；而且我们重置时，有时候是需要做特定处理的，比如：想让 a 元 素的文字是灰色，其他元素文字是蓝色。 方案二：reset.css选择到具有默认样式的元素，清空其默认的样式。 经过 reset 后的网页，好似“一张白纸”，开发人员可根据设计稿，精细的去添加具体的样式。 { margin: 0; padding: 0; …… } 方案三：Normalize.cssNormalize.css 是一种最新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式。 官网地址：http://necolas.github.io/normalize.css/ 相对于 reset.css ， Normalize.css 有如下优点： 保护了有价值的默认样式，而不是完全去掉它们。 为大部分HTML元素提供一般化的样式。 新增对 HTML5 元素的设置。 对并集选择器的使用比较谨慎，有效避免调试工具杂乱。 备注： Normalize.css 的重置，和 reset.css 相比，更加的温和，开发时可根据实际情况进行 选择。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"盒子模型","path":"/2024/01/16/盒子模型/","content":"1.长度单位 px ：像素。 em ：相对元素 font-size 的倍数。如果子元素没有，就往父元素上找。 rem ：相对根字体大小，html标签就是根。 % ：相对父元素计算。 2.元素的显示模式2.1块元素（block）&lt;div&gt; 又称：块级元素 特点： 在页面中独占一行，不会与任何元素共用一行，是从上到下排列的。 默认宽度：撑满父元素。 默认高度：由内容撑开。 可以通过 CSS 设置宽高。 2.2行内元素（inline）&lt;span&gt; 又称：内联元素 特点: 1.在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列 2.默认宽度：由内容撑开。 &#x2F;* 自定义鼠标光标 *&#x2F; cursor: url(“.&#x2F;arrow.png”),pointer; 3. 默认高度：由内容撑开。 4.无法通过 CSS 设置宽高。 2.3行内块元素（inline-block）&lt;img&gt; 又称：内联块元素 特点： 1.在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。 2.默认宽度：由内容撑开。 3.默认高度：由内容撑开。 4.可以通过 CSS 设置宽高。 注意：元素早期只分为：行内元素、块级元素，区分条件也只有一条：”是否独占一行”，如果按照这种分类方式，行内块元素应该算作行内元素。 3.总结块元素（block） 主体结构标签： &lt;html&gt; 、 &lt;body&gt; 排版标签： &lt;h1&gt; ~ &lt;h6&gt; 、 &lt;hr&gt; 、 &lt;p&gt; 、 &lt;pre&gt; 、 &lt;div&gt; 列表标签： &lt;ul&gt; 、 &lt;ol&gt; 、 &lt;li&gt; 、 &lt;dl&gt; 、 &lt;dt&gt; 、 &lt;dd&gt; 表格相关标签： &lt;table&gt; 、 &lt;tbody&gt; 、 &lt;thead&gt; 、 &lt;tfoot&gt; 、 &lt;tr&gt; 、 &lt;caption&gt; &#x20; 5.&lt;form&gt; 与 &lt;option&gt; 行内元素（inline） 文本标签： &lt;br&gt; 、 &lt;em&gt; 、 &lt;strong&gt; 、 &lt;sup&gt; 、 &lt;sub&gt; 、 &lt;del&gt; 、 &lt;ins&gt; &lt;a&gt; 与 &lt;label&gt; 行内块元素（inline-block） 图片： &lt;img&gt; 单元格： &lt;td&gt; 、 &lt;th&gt; 表单控件： &lt;input&gt; 、 &lt;textarea&gt; 、 &lt;select&gt; 、 &lt;button&gt; 框架标签： &lt;iframe&gt; 4.修改元素的显示模式通过 CSS 中的 display 属性可以修改元素的默认显示模式，常用值如下： none：元素会被隐藏。 block：元素将作为块级元素显示。 inline：元素将作为内联元素显示。 inline-block：元素将作为行内块元素显示 5.盒子模型组成 margin（外边距）： 盒子与外界的距离。 border（边框）： 盒子的边框。 padding（内边距）： 紧贴内容的补白区域。 content（内容）：元素中的文本或后代元素都是它的内容。 盒子的大小 &#x3D; content + 左右 padding + 左右 border 。 5.1 paddingpadding 复合属性的使用规则： padding: 10px; 四个方向内边距都是 10px 。 padding: 10px 20px; 上 10px ，左右 20px 。（上下、左右） padding: 10px 20px 30px; 上 10px ，左右 20px ，下 30px 。（上、左右、下） padding: 10px 20px 30px 40px; 上 10px ，右 20px ，下 30px ，左 40px 。（上、右、 下、左） 注意点： padding 的值不能为负数。 行内元素 的 左右内边距是没问题的，上下内边距不能完美的设置。 块级元素、行内块元素，四个方向内边距都可以完美设置。 5.2 margin注意事项 子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着子元素） 上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素的位置。 块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右margin 可以完美设置，上下 margin 设置无效。 margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级元素会在父元素中水平居中。 margin 的值可以是负值。 5.3 margin塌陷问题什么是 margin 塌陷？第一个子元素的上 margin 会作用在父元素上，最后一个子元素的下 margin 会作用在父元素上。如何解决 margin 塌陷？方案一： 给父元素设置不为 0 的 padding 。方案二： 给父元素设置宽度不为 0 的 border 。方案三：给父元素设置 css 样式 overflow:hidden 5.4 margin合并问题什么是 margin 合并？ 上面兄弟元素的下外边距和下面兄弟元素的上外边距会合并，取一个最大的值，而不是相加。 如何解决 margin 塌陷？ 无需解决，布局的时候上下的兄弟元素，只给一个设置上下外边距就可以了。 6.内容溢出 7.隐藏元素方式一：visibility 属性 visibility 属性默认值是 show ，如果设置为 hidden ，元素会隐藏。 元素看不见了，还占有原来的位置（元素的大小依然保持）。 方式二： display 属性 设置 display:none ，就可以让元素隐藏。 彻底地隐藏，不但看不见，也不占用任何位置，没有大小宽高。 8.样式的继承有些样式会继承，元素如果本身设置了某个样式，就使用本身设置的样式；但如果本身没有设置某个样式，会从父元素开始一级一级继承（优先继承离得近的祖先元素）。 会继承的 css 属性： 字体属性、文本属性、文字颜色等 不会继承的 css 属性： 边框、背景、内边距、外边距、宽高、溢出方式等 一个规律：能继承的属性，都是不影响布局的，简单说：都是和盒子模型没关系的。 9.默认样式元素一般都有默认的样式，例如： &lt;a&gt; 元素：下划线、字体颜色、鼠标小手。 &lt;h1&gt; ~ &lt;h6&gt; 元素： 文字加粗、文字大小、上下外边距。 &lt;p&gt; 元素：上下外边距 &lt;ul&gt; 、 ol 元素：左内边距 body 元素： 8px 外边距（4个方向） 优先级：元素的默认样式 &gt; 继承的样式，所以如果要重置元素的默认样式，选择器一定要直接选择器到该元素。 10.布局效果1.行内元素、行内块元素，可以被父元素当做文本处理 即：可以像处理文本对齐一样，去处理：行内、行内块在父元素中的对齐。 例如： text-align 、 line-height 、 text-indent 等。 2.如何让子元素，在父亲中 水平居中： 若子元素为块元素，给父元素加上： margin:0 auto; 。 若子元素为行内元素、行内块元素，给父元素加上： text-align:center 。 📌3.如何让子元素，在父亲中 垂直居中： 若子元素为块元素，给子元素加上： margin-top ，值为：(父元素 content －子元素盒子 总高) &#x2F; 2。 若子元素为行内元素、行内块元素： 让父元素的 height &#x3D; line-height ，每个子元素都加上： vertical-align:middle; 。 补充：若想绝对垂直居中，父元素 font-size 设置为 0 。 11.元素之间的空白问题产生的原因： 行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符。 解决方案： 方案一： 去掉换行和空格（不推荐）。 方案二： 给父元素设置 font-size:0 ，再给需要显示文字的元素，单独设置字体大小（推 荐）。 12.行内块的幽灵空白问题产生原因： 行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的。 解决方案： &#x20;方案一： 给行行内块设置 vertical ，值不为 baseline 即可，设置为 middel 、 bottom 、top 均可。 方案二： 若父元素中只有一张图片，没有文字，设置图片为 display:block 。 方案三： 给父元素设置 font-size: 0 。如果该行内块内部还有文本，则需单独设置 font-size 。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"常用属性","path":"/2024/01/16/常用属性/","content":"1.字体font-size：字体的大小font-family：控制字体类型。可以设置多个字体，按照从左到右的顺序逐个查找，找到就用，没有找到就使用后面 的，且通常在最后写上 serif （衬线字体）或 sans-serif （非衬线字体）。 font-style：字体是否为斜体常用值： normal ：正常（默认值） italic ：斜体（使用字体自带的斜体效果） oblique ：斜体（强制倾斜产生的斜体效果） 实现斜体时，更推荐使用 italic 。 font-weight：控制字体的粗细。 lighter ：细 normal ： 正常 bold ：粗 bolder ：很粗 （多数字体不支持） 字体复合写法属性名： font ，可以把上述字体样式合并成一个属性。 作用：将上述所有字体相关的属性复合在一起编写。 编写规则： 字体大小、字体族必须都写上。 字体族必须是最后一位、字体大小必须是倒数第二位。 各个属性间用空格隔开。 实际开发中更推荐复合写法，但这也不是绝对的，比如只想设置字体大小，那就直接用 font- size 属性 2.文本color： 颜色名 rgb 或 rgba HEX 或 HEXA （十六进制） HSL 或 HSLA 开发中常用的是： rgb&#x2F;rgba 或 HEX&#x2F;HEXA （十六进制）。 间距：字母间距： letter-spacing 单词间距： word-spacing （通过空格识别词，每个中文算一个letter） 属性值为像素（ px ），正值让间距增大，负值让间距缩小。 text-decoration:控制文本的各种装饰线。可选值： none ： 无装饰线（常用） underline ：下划线（常用） overline ： 上划线 line-through ： 删除线 可搭配如下值使用： dotted ：虚线 wavy ：波浪线 也可以指定颜色 text-indent：文本缩进作用：控制文本首字母的缩进。 属性值： css 中的长度单位，例如： px text-align：控制文本的水平对齐方式。常用值： left ：左对齐（默认值） right ：右对齐 center ：居中对齐 line-height：制一行文字的高度。可选值： normal ：由浏览器根据文字大小决定的一个默认值。 像素( px )。 数字：参考自身 font-size 的倍数（很常用）。 百分比：参考自身 font-size 的百分比。 注 ： line-height 过小会怎样？—— 文字产生重叠，且最小值是 0 ，不能为负数。 line-height 是可以继承的，且为了能更好的呈现文字，最好写数值。 line-height 和 height 是什么关系？ 设置了 height ，那么高度就是 height 的值。 不设置 height 的时候，会根据 line-height 计算高度 文本对齐_垂直 顶部：无需任何属性，在垂直方向上，默认就是顶部对齐。 居中：对于单行文字，让 height &#x3D; line-height 即可。 问题：多行文字垂直居中怎么办？—— 后面我们用定位去做。 3底部：对于单行文字，目前一个临时的方式： 让 line-height &#x3D; ( height × 2 ) - font-size - x 。 备注： x 是根据字体族，动态决定的一个值。 问题：垂直方向上的底部对齐，更好的解决办法是什么？—— 后面我们用定位去做。 vertical-align :垂直对齐方式用于指定同一行元素之间，或 表格单元格内文字的垂直对齐方式。 常用值： baseline （默认值）：使元素的基线与父元素的基线对齐。 top ：使元素的顶部与其所在行的顶部对齐。 middle ：使元素的中部与父元素的基线加上父元素字母 x 的一半对齐。 bottom ：使元素的底部与其所在行的底部对齐。 特别注意： vertical-align 不能控制块元素，只能控制父级元素里的子元素 3.列表属性 4.表格属性4.1边框属性 注意： 以上 4 个边框相关的属性，其他元素也可以用，这是我们第一次遇见它们。 4.2表格属性 5.背景属性 6.鼠标属性","tags":["CSS","前端"],"categories":["CSS"]},{"title":"三大特性","path":"/2024/01/16/三大特性/","content":"1.层叠性概念：如果发生了样式冲突，那就会根据一定的规则（选择器优先级），进行样式的层叠（覆 盖）。 2.继承性概念：元素会自动拥有其父元素、或其祖先元素上所设置的某些样式。 规则：优先继承离得近的。 常见的可继承属性： 3.优先级!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; * &gt; 继承的样 式。 见选择器","tags":["CSS","前端"],"categories":["CSS"]},{"title":"选择器","path":"/2024/01/16/选择器/","content":"1.基本选择器1.1 通配选择器作用：可以选中所有的 HTML 元素。 语法： 123* &#123; color：orange&#125; 备注：清除样式时，会对我们有很大帮助 1.2元素选择器作用：为页面中某种元素统一设置样式。 语法： 1234h1 &#123; color: red; font-size: 40px;&#125; 1.3 类选择器作用：根据元素的 class 值，来选中某些元素。 123.button_choose&#123; color:red;&#125; 注： 一个元素的 class 属性，能写多个值，要用空格隔开，例如： 1&lt;h1 class=&quot;speak big&quot;&gt;你好&lt;/h1&gt; 1.4 ID选择器作用：根据元素的 id 值，来选中某个元素。 123#button_choose&#123; color:red;&#125; 注： 一个元素的 class 属性，能写多个值，要用空格隔开，例如： 1&lt;h1 class=&quot;speak big&quot;&gt;你好&lt;/h1&gt; 注： 1、id 属性值：尽量由字母、数字、下划线( _ )、短杠( - )组成，最好以字母开头、不要包含空 格、区分大小写。 2、一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同。 3、一个元素可以同时拥有 id 和 class 属性。 2.复合选择器2.1交集选择器交集选择器中不可能出现两个元素选择器，因为一个元素，不可能即是 p 元素又是 span 元 素 用的最多的交集选择器是：元素选择器配合类名选择器，例如： p.beauty 。 12345678/* 选中：类名为beauty的p元素，为此种写法用的非常多！！！！ */p.beauty &#123; color: blue;&#125;/* 选中：类名包含rich和beauty的元素 */.rich.beauty &#123; color: green;&#125; 2.2 并集选择器12345678/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */#peiqi,.rich,.beauty &#123; font-size: 40px; background-color: skyblue; width: 200px;&#125; 2.3 后代选择器&#x20;&#x20;子、孙子、重孙子、重重孙子 …… 统称后代 12345678910111213141516/* 选中ul中的所有li */ul li &#123; color: red;&#125;/* 选中ul中所有li中的a */ul li a &#123; color: orange;&#125;/* 选中类名为subject元素中的所有li */.subject li &#123; color: blue;&#125;/* 选中类名为subject元素中的所有类名为front-end的li */.subject li.front-end &#123; color: blue;&#125; 2.4 子代选择器选择器之间，用 &gt; 隔开， &gt; 可以理解为：” xxx 的子代”，其实就是儿子的意思。 只选儿子 12345678/* div中的子代a元素 */div&gt;a &#123; color: red;&#125;/* 类名为persons的元素中的子代a元素 */.persons&gt;a&#123; color: red;&#125; 2.5 兄弟选择器2.5.1相邻兄弟选择器作用：选中指定元素后，符合条件的相邻兄弟元素。 所谓相邻，就是紧挨着他的下一个，简记：睡在我下铺的兄弟。 123456789101112131415161718&lt;html&gt; &lt;style&gt; /* 选中div后相邻的兄弟p元素 */ div+p &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 使用场景： 想让23都变为红色 1234567891011121314&lt;html&gt; &lt;style&gt; li+li &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 2.5.2通用兄弟选择器作用：选中指定元素后，符合条件的所有兄弟元素。（简记：睡在我下铺的所有兄弟） 123456789101112131415&lt;html&gt; &lt;style&gt; /* 选中div后的所有的兄弟p元素 */ div~p &#123; color:red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 注意：两种兄弟选择器，选择的是下面的兄弟。 2.6 属性选择器作用：选中属性值符合一定要求的元素。 语法： [属性名] 选中具有某个属性的元素。 [属性名&#x3D;”值”] 选中包含某个属性，且属性值等于指定值的元素。 [属性名^&#x3D;”值”] 选中包含某个属性，且属性值以指定的值开头的元素。 [属性名$&#x3D;”值”] 选中包含某个属性，且属性值以指定的值结尾的元素。 [属性名 *&#x3D;“值”] 选择包含某个属性，属性值包含指定值的元素 1234567891011/* 选中具有title属性的元素 */div[title]&#123;color:red;&#125;/* 选中title属性值为atguigu的元素 */div[title=&quot;atguigu&quot;]&#123;color:red;&#125;/* 选中title属性值以a开头的元素 */div[title^=&quot;a&quot;]&#123;color:red;&#125;/* 选中title属性值以u结尾的元素 */div[title$=&quot;u&quot;]&#123;color:red;&#125;/* 选中title属性值包含g的元素 */div[title*=&quot;g&quot;]&#123;color:red;&#125; 2.7 伪类选择器作用：选中特殊状态的元素。 2.7.1动态伪类1. :link 超链接未被访问的状态。 2. :visited 超链接访问过的状态。 3.:hover 鼠标悬停在元素上的状态。 4.:active 元素激活的状态。 激活：按下鼠标不松开。 注意点：遵循 LVHA 的顺序，即： link 、 visited 、 hover 、 active 。 5.:focus 获取焦点的元素。 表单类元素才能使用 :focus 伪类。 当用户点击元素、触摸元素、或通过键盘的 “ tab ” 键等方式，选择元素时，就是获得焦点。 2.7.2 结构伪类1.常用的 :first-child 所有兄弟元素中的第一个。 :last-child 所有兄弟元素中的最后一个。 :nth-child(n) 所有兄弟元素中的第 n 个。 :first-of-type 所有同类型兄弟元素中的第一个。 :last-of-type 所有同类型兄弟元素中的最后一个。 :nth-of-type(n) 所有同类型兄弟元素中的 第n个 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;09_伪类选择器_结构伪类_1&lt;/title&gt; &lt;style&gt; /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的） —— 看结构1 */ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的） —— 看结构2 选不到 因为span是第一个儿子*/ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的后代p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子（按照所有兄弟计算的） 所以测试三和测试二会变红—— 看结构3 */ /* div p:first-child &#123; color: red; &#125; */ /* 选中的是p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子（按照所有兄弟计算的） —— 看结构3 测试一测试二测试三都变红 */ p:first-child &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 结构1 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构2 --&gt; &lt;!-- &lt;div&gt; &lt;span&gt;张三：98分&lt;/span&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构3 --&gt; &lt;p&gt;测试1&lt;/p&gt; &lt;div&gt; &lt;p&gt;测试2&lt;/p&gt; &lt;marquee&gt; &lt;p&gt;测试3&lt;/p&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;/marquee&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注：关于 n 的值： 0 或 不写 ：什么都选不中 —— 几乎不用。 n ：选中所有子元素 —— 几乎不用。 1~正无穷的整数 ：选中对应序号的子元素。 2n 或 even ：选中序号为偶数的子元素。 2n+1 或 odd ：选中序号为奇数的子元素。 -n+3 ：选中的是前 3 个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;10_伪类选择器_结构伪类_2&lt;/title&gt; &lt;style&gt; /* 选中的是div的第一个儿子p元素（按照所有兄弟计算的）—— 结构1*/ /* div&gt;p:first-child &#123; color: red; &#125; */ /* 选中的是div的最后一个儿子p元素（按照所有兄弟计算的）—— 结构1*/ /* div&gt;p:last-child &#123; color: red; &#125; */ /* 选中的是div的第n个儿子p元素（按照所有兄弟计算的）—— 结构1 */ /* div&gt;p:nth-child(3) &#123; color: red; &#125; */ /* 选中的是div的偶数个儿子p元素（按照所有兄弟计算的）—— 结构2 */ /* 关于n的值 —— 结构2： 1. 0或不写：什么都选不中 —— 几乎不用。 2. n ：选中所有子元素 —— 几乎不用。 3. 1 ~ 正无穷的整数，选中对应序号的子元素。 4. 2n 或 even ：选中序号为偶数的子元素。 5. 2n+1 或 odd ：选中序号为奇数的子元素。 6. -n+3 : 选中前三个。 */ /* div&gt;p:nth-child(2n) &#123; color: red; &#125; */ /* 选中的是div的第一个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:first-of-type&#123; color: red; &#125; */ /* 选中的是div的最后一个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:last-of-type&#123; color: red; &#125; */ /* 选中的是div的第n个儿子p元素（按照所有同类型兄弟计算的）—— 结构3 */ /* div&gt;p:nth-of-type(5) &#123; color: red; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 结构1 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;p&gt;孙七：58分&lt;/p&gt; &lt;p&gt;老八：48分&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构2 --&gt; &lt;!-- &lt;div&gt; &lt;p&gt;第1个&lt;/p&gt; &lt;p&gt;第2个&lt;/p&gt; &lt;p&gt;第3个&lt;/p&gt; &lt;p&gt;第4个&lt;/p&gt; &lt;p&gt;第5个&lt;/p&gt; &lt;p&gt;第6个&lt;/p&gt; &lt;p&gt;第7个&lt;/p&gt; &lt;p&gt;第8个&lt;/p&gt; &lt;p&gt;第9个&lt;/p&gt; &lt;p&gt;第10个&lt;/p&gt; &lt;/div&gt; --&gt; &lt;!-- 结构3 --&gt; &lt;!-- &lt;div&gt; &lt;span&gt;测试1&lt;/span&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;span&gt;测试2&lt;/span&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;span&gt;测试3&lt;/span&gt; &lt;p&gt;孙七：58分&lt;/p&gt; &lt;span&gt;测试4&lt;/span&gt; &lt;p&gt;老八：48分&lt;/p&gt; &lt;span&gt;测试5&lt;/span&gt; &lt;/div&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 了解： :nth-last-child(n) 所有兄弟元素中的倒数第 n 个。 :nth-last-of-type(n) 所有同类型兄弟元素中的 倒数第n个 。 :only-child 选择没有兄弟的元素（独生子女）。 :only-of-type 选择没有同类型兄弟的元素。 :root 根元素。 :empty 内容为空元素（空格也算内容）。 2.7.3 否定伪类:not(选择器) 排除满足括号中条件的元素。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;12_伪类选择器_否定伪类&lt;/title&gt; &lt;style&gt; /* 选中的是div的儿子p元素，但是排除类名为fail的元素 */ /* div&gt;p:not(.fail) &#123; color: red; &#125; */ /* 选中的是div的儿子p元素，但是排除title属性值以“你要加油”开头的 */ /* div&gt;p:not([title^=&quot;你要加油&quot;]) &#123; color: red; &#125; */ /* 选中的是div的儿子p元素，但排除第一个儿子p元素 */ div&gt;p:not(:first-child) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;张三：98分&lt;/p&gt; &lt;p&gt;李四：88分&lt;/p&gt; &lt;p&gt;王五：78分&lt;/p&gt; &lt;p&gt;赵六：68分&lt;/p&gt; &lt;p class=&quot;fail&quot; title=&quot;你要加油啊！孙七&quot;&gt;孙七：58分&lt;/p&gt; &lt;p class=&quot;fail&quot; title=&quot;你要加油啊！老八&quot;&gt;老八：48分&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.7.4 UI伪类:checked 被选中的复选框或单选按钮。 :enable 可用的表单元素（没有 disabled 属性） :disabled 不可用的表单元素（有 disabled 属性）。 2.7.3 目标伪类:target 选中锚点指向的元素 2.7.4 语言伪类:lang() 根据指定的语言选择元素（本质是看 lang 属性的值）。 2.8 伪元素选择器作用：选中元素中的一些特殊位置。 常用伪元素： ::first-letter 选中元素中的第一个文字。 ::first-line 选中元素中的第一行文字。 ::selection 选中被鼠标选中的内容。 ::placeholder 选中输入框的提示文字。 ::before 在元素最开始的位置，创建一个子元素（必须用 content 属性指定内容）。 ::after 在元素最后的位置，创建一个子元素（必须用 content 属性指定内容）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;16_伪元素选择器&lt;/title&gt; &lt;style&gt; /* 什么是伪元素？ —— 很像元素，但不是元素（element），是元素中的一些特殊位置 */ /* 选中的是div中的第一个文字 */ div::first-letter &#123; color: red; font-size: 40px; &#125; /* 选中的是div中的第一行文字 */ div::first-line &#123; background-color: yellow; &#125; /* 选中的是div中被鼠标选择的文字 */ div::selection &#123; background-color: green; color: orange; &#125; /* 选中的是input元素中的提示文字 */ input::placeholder &#123; color: skyblue; &#125; /* 选中的是p元素最开始的位置，随后创建一个子元素 */ p::before &#123; content:&quot;￥&quot;; &#125; /* 选中的是p元素最后的位置，随后创建一个子元素 */ p::after &#123; content:&quot;.00&quot; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt quibusdam amet eligendi velit dolore sequi, exercitationem consequatur, quis maiores tempore accusantium ipsum aspernatur iusto fugiat fuga natus est placeat. Accusamus maiores culpa et sunt dolorum incidunt. Ducimus in odio tempora minima provident deleniti, ex voluptatem facere, molestias unde exercitationem pariatur rem vero ut quidem quaerat aliquam, nam debitis perspiciatis. Facere?&lt;/div&gt; &lt;br&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的用户名&quot;&gt; &lt;p&gt;199&lt;/p&gt; &lt;p&gt;299&lt;/p&gt; &lt;p&gt;399&lt;/p&gt; &lt;p&gt;499&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.选择器优先级行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配选择器。 详细描述： 计算方式：每个选择器，都可计算出一组权重，格式为： (a,b,c) a : ID 选择器的个数。 b : 类、伪类、属性 选择器的个数。 c : 元素、伪元素 选择器的个数。 比较规则：按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比，例如： (1,0,0) &gt; (0,2,2) (1,1,0) &gt; (1,0,3) (1,1,3) &gt; (1,1,2) 特殊规则： 行内样式权重大于所有选择器。 !important 的权重，大于行内样式，大于所有选择器，权重最高！","tags":["CSS","前端"],"categories":["CSS"]},{"title":"Javascript变量与常量","path":"/2024/01/16/变量与常量/","content":"typeof 结果 {} object [] object null object undefined undefined NaN number 0 number true boolean ‘’ string let与var与constvar的特点1、var的作用域 var 声明的作用域是全局的或函数&#x2F;局部的。 当 var 变量在函数外部声明时，作用域是全局的。这意味着在函数体外用 var 声明的任何变量都可以在整个窗口中使用。 var 在函数中声明时，它的作用域是在函数体内。这意味着它只能在该函数中被访问。 2、var 变量可以重新声明和更新 3、var的提升 提升（hoisting）是一种 JavaScript 机制，其中变量和函数声明在代码执行之前被移动到其作用域的顶部。 let的特点1、let是块级作用域 块是由 &#123;&#125; 界定的代码块。一个块存在于花括号中。花括号内的任何内容都是一个块。 因此，在带有 let 的块中声明的变量只能在该块中使用。 2、let可以更新但不能重新声明 就像 var 一样，使用 let 声明的变量可以在其作用域内更新。与 var 不同，let 变量不能在其作用域内重新声明。 3、let的提升 就像 var 一样，let 声明被提升到顶部。与初始化为 undefined 的 var 不同，let 关键字未初始化。所以如果你在声明之前尝试使用 let 变量，你会得到一个 Reference Error。 const的特点1、const 声明是块作用域 与 let 声明一样，const 声明只能在它们声明的块内访问。 2、const 不能更新或重新声明 这意味着用 const 声明的变量的值在其作用域内保持不变。它不能被更新或重新声明。 3、const 的提升 就像 let 一样，const 声明被提升到顶部但没有被初始化。 区别 var 声明是全局作用域或函数作用域，而 let 和 const 是块作用域。 var 变量可以在其作用域内更新和重新声明；let 变量可以更新但不能重新声明；const 变量既不能更新也不能重新声明。 它们都被提升到了作用域的顶部。但是，var 变量是用 undefined 初始化的，而 let 和 const 变量不会被初始化。 var 和 let 可以在不初始化的情况下声明，而 const 必须在声明时初始化。 类型转换 理解弱类型语言的特征，掌握显式类型转换的方法 在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。 隐式转换某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 +号两边只要有一个是字符串，都会把另外一个转成字符串 除了+以外的算术运算符，比如 - * &#x2F; 等都会把数据转成数字类型。 +号作为正号解析可以转换成数字型 任何数据和字符串相加结果都是字符串 有字符串的加法“”+1，结果是“1” 减法-（像大多数数学运算一样）只能用于数字，它会使空字符串””转换为0 null经过数字转换之后会变为0 undefined经过数字转换之后会变为NaN 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript 基础 - 隐式转换&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let num = 13 // 数值 let num2 = &#x27;2&#x27; // 字符串 // 结果为 132 // 原因是将数值 num 转换成了字符串，相当于 &#x27;13&#x27; // 然后 + 将两个字符串拼接到了一起 console.log(num + num2) // 结果为 11 // 原因是将字符串 num2 转换成了数值，相当于 2 // 然后数值 13 减去 数值 2 console.log(num - num2) let a = prompt(&#x27;请输入一个数字&#x27;) let b = prompt(&#x27;请再输入一个数字&#x27;) alert(a + b); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换。 补充介绍模板字符串的拼接的使用 显式转换编写程序时过度依靠系统内部的隐式转换是不严谨的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 转为Number1、通过 Number 显示转换成数值类型，当转换失败时结果为 NaN（Not a Number）即不是一个数字。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JavaScript 基础 - 隐式转换&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let t = &#x27;12&#x27; let f = 8 // 显式将字符串 12 转换成数值 12 t = Number(t) // 检测转换后的类型 // console.log(typeof t); console.log(t + f) // 结果为 20 // 并不是所有的值都可以被转成数值类型 let str = &#x27;hello&#x27; // 将 hello 转成数值是不现实的，当无法转换成 // 数值时，得到的结果为 NaN （Not a Number） console.log(Number(str)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果字符串内容里有非数字，转换失败时结果为 NaN（Not a Number）即不是一个数字 NaN也是number类型的数据，代表非数字 特殊转换： Number转换 结果 Number({}) NaN Number([]) 0 Number(‘’) 0 Number(null) 0 Number(undefined) undefined Number(NaN) NAN Number(false) 0 Number(true) 1 2、parseInt(数据) 只保留整数，数字只能在字符串开头，否则NaN。 3、parseFloat(数据) 可以保留小数，数字只能在字符串开头，否则NaN。 转换为字符型123String(数据)\t1.对于Number 和 Boolean 实际就是调用 toString()\t2.对于undefined 和 null 是直接转换为 &quot;undefined&quot; 和 &quot;null&quot; 123变量.toString(进制) 1.该方法不会影响原变量 2.Null, Undefined 没有 toString()方法，使用会报错 1234任意数据类型 + &quot;&quot; 1.隐式转换 2.任何数据类型与字符串相加都是先调用 String() 转为字符串再拼接 3.最常用⭐ 转换为Boolean值‘’、0、undefined、null、false、NaN转换为布尔值后都是false,其余则为true Null和Undefined123456789101112131415161718&lt;body&gt; &lt;script&gt; // 1. true false 是布尔型字面量 // console.log(3 &gt; 4) // let isCool = false // console.log(isCool) // 2. 未定义类型 弱数据类型 声明一个变量未赋值就是 undefined // let num // console.log(num) // 3. null 空的 // let obj = null // console.log(obj) // 计算有区别 console.log(undefined + 1) // NaN console.log(null + 1) // 1 &lt;/script&gt;&lt;/body&gt; null 和 undefined 区别：undefined 表示没有赋值null 表示赋值了，但是内容为空 null 开发中的使用场景：官方解释：把 null 作为尚未创建的对象大白话： 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null","tags":["前端","Javascript"],"categories":["Javascript"]},{"title":"样式表优先级","path":"/2024/01/15/样式表优先级/","content":"优先级规则：行内样式 &gt; 内部样式 &#x3D; 外部样式 遵循后来者居上原则。CSS写在后面的起作用。","tags":["CSS","前端"],"categories":["CSS"]},{"title":"H5新增内容","path":"/2024/01/15/H5/","content":"1、语义化标签1.1 布局标签 关于 article 和 section ： artical 里面可以有多个 section 。 section 强调的是分段或分块，如果你想将一块内容分成几段的时候，可使用 section 元素。 article 比 section 更强调独立性，一块内容如果比较独立、比较完整，应该使用article 元素。 1.2 状态标签1、meter标签 语义：定义已知范围内的标量测量。也被称为 gauge （尺度），双标签，例如：电量、磁盘用量 等。 常用属性： 2、progeress标签 语义：显示某个任务完成的进度的指示器，一般用于表示进度条，双标签，例如：工作完成进度 等。 1.3列表标签 1.4新增文本标签1、文本注音 1234&lt;ruby&gt;&lt;span&gt;魑魅魍魉&lt;/span&gt;&lt;rt&gt;chī mèi wǎng liǎng &lt;/rt&gt;&lt;/ruby&gt; 2、文本标记 2、新增表单功能2.1表单控件新增属性 2.2 input新增属性值 2.3 form新增属性 3 多媒体标签3.1 视频标签&lt;video&gt; 标签用来定义视频，它是双标签。 3.2 音频标签 4.新增全局属性 5. 兼容性处理添加元信息，让浏览器处于最优渲染模式。 1234&lt;!--设置IE总是使用最新的文档模式进行渲染--&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;!--优先使用 webkit ( Chromium ) 内核进行渲染, 针对360等壳浏览器--&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 使用 html5shiv 让低版本浏览器认识 的语义化标签。 123&lt;!--[if lt ie 9]&gt;&lt;script src=&quot;../sources/js/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 扩展 lt 小于 lte 小于等于 gt 大于 gte 大于等于 ! 逻辑非 示例： 123456&lt;!--[if IE 8]&gt;仅IE8可见&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;仅IE8以上可见&lt;![endif]—&gt;&lt;!--[if lt IE 8]&gt;仅IE8以下可见&lt;![endif]—&gt;&lt;!--[if gte IE 8]&gt;IE8及以上可见&lt;![endif]—&gt;&lt;!--[if lte IE 8]&gt;IE8及以下可见&lt;![endif]—&gt;&lt;!--[if !IE 8]&gt;非IE8的IE可见&lt;![endif]--&gt;","tags":["前端","html"],"categories":["html"]},{"title":"补充标签","path":"/2024/01/15/补充标签/","content":"&lt; br&gt;换行 &lt; pre&gt;按原文显示 &lt; hr&gt;分割 隐藏域： &lt;input type&#x3D;”hidden” name&#x3D;”tag” value&#x3D;”100” &gt; 用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据。 name 属性：指定数据的名称。 value 属性：指定的是真正提交的数据。 &lt;label&gt;: label 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点。 两种与 label 关联方式如下： 让 label 标签的 for 属性的值等于表单控件的 id 。 把表单控件套在 label 标签的里面。 &lt;iframe&gt;嵌入内容","tags":["前端","html"],"categories":["html"]},{"title":"字符实体","path":"/2024/01/15/字符实体/","content":"空格的字符实体&amp;nbsp; &amp;#160 标签&lt;&gt;的字符实体&amp;lt; h1 &amp;gt; &amp;的字符实体&amp;amp;&#x20; 人民币的字符实体&amp;yen; 版权的字符实体&amp;copy; 乘号的字符实体&amp;times; 除号的字符实体&amp;divide;","tags":["前端","html"],"categories":["html"]},{"title":"表格","path":"/2024/01/15/表格/","content":"结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;table border=&quot;1&quot;&gt;&lt;!-- 表格标题 --&gt;&lt;caption&gt;学生信息&lt;/caption&gt;&lt;!-- 表格头部 --&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;民族&lt;/th&gt;&lt;th&gt;政治面貌&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;2. 常用属性&lt;!-- 表格主体 --&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;汉族&lt;/td&gt;&lt;td&gt;团员&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;满族&lt;/td&gt;&lt;td&gt;群众&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;王五&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;回族&lt;/td&gt;&lt;td&gt;党员&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;赵六&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;td&gt;壮族&lt;/td&gt;&lt;td&gt;团员&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;!-- 表格脚注 --&gt;&lt;tfoot&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;共计：4人&lt;/td&gt;&lt;/tr&gt;&lt;/tfoot&gt;&lt;/table&gt; 属性 一般table的属性height意义为最小高度。table会通过自动调整tbody来让整个table高度达到最小高度。","tags":["前端","html"],"categories":["html"]},{"title":"块级元素、行内元素、行内块元素","path":"/2024/01/15/块级元素、行内元素、行内块元素/","content":"块级元素blockquote、address 独占一行。 行内元素文本标签（&lt;em&gt;&lt;strong&gt;&lt;span&gt;&lt;a&gt;等） 不独占一行 规则1：块级元素中能写行内元素、块级元素。 规则2：行内元素中能写行内元素，不能写块级元素 特殊规则: H1-H6不能嵌套 特殊规则：p标签中不能写块元素 特殊规则：a标签内可以包含除自身之外的任何元素 行内块元素IMG","tags":["前端","html"],"categories":["html"]},{"title":"函数式组件","path":"/2023/06/28/函数式组件/","content":"12345678910111213141516171819&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;test&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../react.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../react-dom.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../babel.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;function demo()&#123;console.log(this);//此处的this是undefined，因为babel编译后开启了严格模式return &lt;h2&gt;我是用函数定义的组件&lt;/h2&gt;&#125; &lt;/script&gt;&lt;/html&gt;","tags":["前端","react","组件"],"categories":["react"]},{"title":"jsx基础知识","path":"/2023/06/18/jsx/","content":"jsx语法JSX是类似于XML的js扩展语法，其本质是React.createElement(component,props,…children)方法的语法糖 注：XML早期用于存储和传输数据。 XML格式如下： 1234&lt;student&gt;&lt;name&gt;Tom&lt;/name&gt;&lt;age&gt;19&lt;/age&gt;&lt;/student&gt; JSON格式如下： 1&quot;&#123;&quot;name&quot;：&quot;Tom&quot;,&quot;age&quot;:19&#125;&quot; jsx语法规则1、定义虚拟DOM时，不要写引号。 12345const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&quot;test&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 2、标签里如果要用JS的表达式，要用{}。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&#123;myID.toLowerCase()&#125;&gt; &lt;span&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 3、写样式时指定类名不用class，用className。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 className=&quot;title&quot; id=&#123;myID.toLowerCase()&#125;&gt; &lt;span&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 12345&lt;style&gt;.title&#123;background:red;&#125;&lt;/style&gt; 4、写内联样式时用style&#x3D;\"{{kay:value}}\"的样式。 1234567const myID=&quot;Test&quot;;const string1=&quot;Hello,React&quot;const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 className=&quot;title&quot; id=&#123;myID.toLowerCase()&#125;&gt; &lt;span style=&#123;&#123;color:&#x27;white&#x27;,fontSize:&#x27;29px&#x27;&#125;&#125;&gt;&#123;string1.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt;)//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;)). 5、虚拟DOM必须只有一个根标签。 6、标签必须闭合。 7、标签首字母 1）若小写字母开头，则将标签转为html中同名元素，若html中不存在同名元素，则报错。 2）若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。 注：区分js语句和js表达式 1、表达式：会产生一个值，可以放在任何一个需要值的地方。如a、a+b、demo(1)、arr.map()、function test（）{} 2、语句（代码）： 比如if(){}、for(){}、switch（）{case: ….}","tags":["前端","react","jsx"],"categories":["react"]},{"title":"虚拟DOM创建","path":"/2023/06/18/虚拟DOM创建/","content":"1.用jsx创建虚拟DOM1234const VDOM=( /* 此处一定不要写引号，因为不是字符串 */ &lt;h1 id=&quot;title&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;)ReactDOM.render(VDOM,document.querySelector(&#x27;.test&#x27;)) 2.用js创建虚拟DOM1234//1.创建虚拟DOM,创建嵌套格式的domconst VDOM=React.createElement(&#x27;h1&#x27;,&#123;id:&#x27;title&#x27;&#125;,React.createElement(&#x27;span&#x27;,&#123;&#125;,&#x27;hello,React&#x27;))//2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.querySelector(&#x27;.test&#x27;)). 3.虚拟DOM与真实DOM的区别1、虚拟DOM本质上就是Object类型的对象 2、虚拟DOM较为轻量级，真实DOM较为重量级，因为虚拟DOM运用于React内部，无需真实DOM上的过多属性。 3、虚拟DOM最终会被React转化为真实DOM。","tags":["前端","react"],"categories":["react"]},{"title":"类式组件","path":"/2023/06/18/类式组件/","content":"类123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt;class Person&#123;constructor(name,age)&#123;//构造器方法//构造器中的this是类的实例对象this.name=namethis.age=age&#125;//一般方法speak()&#123;//speak方法放在了类的原型对象上，供实例使用console.log(`我叫$(this.name),我的年龄是$(this.age)`)&#125;&#125;class Student extends Person&#123; constructor(name,age,grade)&#123; super(name,age) this.grade=grade; &#125; speak()&#123; console.log(`我叫$&#123;this.name&#125;,我的年龄是$&#123;this.age&#125;,我的年纪是$&#123;this.grade&#125;`) &#125;&#125;const p1=new Person(&#x27;tom&#x27;,18)const p2=new Person(&#x27;jerry&#x27;,19)const s1=new Student(&#x27;zhang&#x27;,15,&#x27;高一&#x27;)p1.speak()p2.speak()s1.speak()&lt;/script&gt; 注： 1、类的构造器不是一定要写的 2、如果a类继承于b类，且a类中写了构造器，则a类构造器中super必须要调用。 3、类定义的方法，都放在类的原型对象上，共实例使用 创建类组件12345678910111213&lt;script type=&quot;text/babel&quot;&gt;class MyComponent extends React.Component&#123;//这里Component的c要大写//render是放在MyComponent原型对象上，供实例使用的render()&#123;return&#123;//render中的this是MyComponent的实例对象&lt;h2&gt;我是类定义的组件&lt;/h2&gt;&#125;&#125;&#125;ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;test&#x27;))&lt;/script&gt; 执行ReactDOM.render（&lt;MyComponent&#x2F;&gt;）之后。发生了什么？ 1、react解析组件标签，找到MyComponent组件 2、发现组件是使用类定义的，随后new出该类的实例，并通过该实例调用到原型上的render方法 3、将render返回的虚拟dom转为真实dom，随后呈现在页面中。","tags":["前端","react","组件"],"categories":["react"]},{"title":"Hello","path":"/2023/04/15/testlx/","content":"Do not go gentle into that good night.","tags":["随笔"],"categories":["随笔"]},{"path":"/index.html","content":"欢迎来到小璇妙妙屋 About Me计算机科学与技术专业研二在读吭哧吭哧学习前端中酷爱听歌，并且什么风格都听MBTI：ENTP SOSTaylorSwiftNewJeansNewJeansDavid TaoBeauty Behind The Madness 今年第一个小目标 O1 2024年的小目标：完成目前的论文写作并收到accept 正常 17% KR1 跑通实验，确定代码的架构不再改动 跑通原本算法的代码 已完成跑通修改后的版本的代码 已完成敲定修改后的代码，并确认大的架构不再改动 50 未完成 70% KR2 完成中文版本论文的写作 完成引言和背景介绍部分 0完成算法本身描述部分 0完成实验结果对比和分析部分 0完成总结和引用部分 0 未完成 0% KR3 完成英文版本论文的写作 简单翻译 0自己润色 0老师修改 0完成润色 0 未完成 0% KR-4 投出并根据反馈修改 待续… 未完成 0% Did You Know that there's a tunnel under Ocean BlvdDesire,I Want To Turn Into YoumelodramaNorman Fucking RockwellMr. Morale & The Big Steppersasuka 今年第二个小目标 O1 2024年的小目标：找到合适的实习/工作 正常 17% KR1 准备简历，完善经历 完成简历 已完成准备八股 80准备算法题 60 未完成 50% KR2 投出简历，在面试的同时查漏补缺 投出简历 40开始面试 0总结分析 0 未完成 0% KR3 拿到offer！ 未完成 0%"},{"title":"friends","path":"/friends/index.html","content":"fengASENNIUM3jinxsherlockxing5sqyuyu"}]